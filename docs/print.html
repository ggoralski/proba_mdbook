<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Filogenetyka roślin</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="wyklady/02-Podstawy_filogenetyki.html"><strong aria-hidden="true">1.</strong> Wstęp do filogenetyki molekularnej i tworzenia drzew filogenetycznych</a></li><li><a href="wyklady/03-Dopasowanie_sekwencji.html"><strong aria-hidden="true">2.</strong> Dopasowanie sekwencji</a></li><li><a href="wyklady/04-Modele_ewolucji_molekularnej.html"><strong aria-hidden="true">3.</strong> Modele ewolucji molekularnej</a></li><li><a href="wyklady/05-Drzewa_filogenetyczne.html"><strong aria-hidden="true">4.</strong> Drzewa filogenetyczne</a></li><li><a href="wyklady/06-HGT.html"><strong aria-hidden="true">5.</strong> Horyzontalny transfer genów (HGT)</a></li><li><a href="cwiczenia/11-praca_w_linuksie.html"><strong aria-hidden="true">6.</strong> Podstawy pracy w systemie Linux</a></li><li><a href="cwiczenia/12-pliki_tekstowe.html"><strong aria-hidden="true">7.</strong> Praca z plikami tekstowymi w linii komend</a></li><li><a href="cwiczenia/13-edytory_tekstu.html"><strong aria-hidden="true">8.</strong> Edytory tekstu</a></li><li><a href="cwiczenia/14-skrypty.html"><strong aria-hidden="true">9.</strong> Skrypty powłoki</a></li><li><a href="cwiczenia/15-warsztat.html"><strong aria-hidden="true">10.</strong> Warsztat pracy</a></li><li><a href="cwiczenia/16-genbank-www.html"><strong aria-hidden="true">11.</strong> Bazy sekwencji DNA, GenBank</a></li><li><a href="cwiczenia/17-genbank-cli.html"><strong aria-hidden="true">12.</strong> Pobieranie sekwencji z bazy GenBank i praca w plikami FASTA przy pomocy linii komend</a></li><li><a href="cwiczenia/18-blast.html"><strong aria-hidden="true">13.</strong> BLAST - wyszukiwanie podobnych sekwencji</a></li><li><a href="cwiczenia/19-dopasowanie_sekwencji.html"><strong aria-hidden="true">14.</strong> Dopasowanie sekwencji</a></li><li><a href="cwiczenia/20-dopasowanie_modelu.html"><strong aria-hidden="true">15.</strong> Dopasowanie modelu substytucji</a></li><li><a href="cwiczenia/21-konstruowanie-drzew.html"><strong aria-hidden="true">16.</strong> Konstruowanie drzew</a></li><li><a href="cwiczenia/22-wizualizacja-drzew.html"><strong aria-hidden="true">17.</strong> Wizualizacja drzew</a></li><li><a href="cwiczenia/23-zegar-molekularny.html"><strong aria-hidden="true">18.</strong> Drzewa filogenetyczne i zegar molekularny</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Filogenetyka roślin</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#wstęp-do-filogenetyki-molekularnej-i-tworzenia-drzew-filogenetycznych" id="wstęp-do-filogenetyki-molekularnej-i-tworzenia-drzew-filogenetycznych"><h1>Wstęp do filogenetyki molekularnej i tworzenia drzew filogenetycznych</h1></a>
<a class="header" href="#czym-się-zajmuje-filogenetyka-molekularna" id="czym-się-zajmuje-filogenetyka-molekularna"><h2>Czym się zajmuje filogenetyka molekularna?</h2></a>
<p><strong>Filogenetyka</strong> to nauka zajmująca się badaniem historii ewolucyjnej (filogenezy) organizmów lub ich grup z użyciem różnych metod w tym paleontologicznych, anatomii porównawczej, genetyki itd. <strong>Filogenetyka molekularna</strong>, jak wskazuje nazwa, skupia się na badaniach cząsteczek (DNA, białek) w celu rekonstrukcji filogenezy. W dalszej części mówiąc o filogenetyce będę miał na myśli głównie filogenetykę molekularną. Zwykle badania filogenetyczne zmierzają do stworzenia <strong>drzewa filogenetycznego</strong>, które w formie wizualnej pozwala przedstawić pokrewieństwa taksonów (zwykle gatunków) w badanej grupie, kolejność ich wyodrębniania oraz szacowane różnice genetyczne między nimi.</p>
<a class="header" href="#etapy-tworzenia-drzew-filogenetycznych" id="etapy-tworzenia-drzew-filogenetycznych"><h2>Etapy tworzenia drzew filogenetycznych</h2></a>
<p>Proces tworzenia drzew filogenetycznych składa się z kilku etapów:</p>
<ul>
<li>Wybór rodzaju sekwencji odpowiedniej dla zestawu badanych taksonów (zmienność, dostępność sekwencji etc.)</li>
<li>Zebranie sekwencji (sekwencje własne, bazy danych)</li>
<li>Wybór algorytmów/oprogramowania do dopasowania sekwencji, budowy drzewek oraz ich wizualizacji</li>
<li>Wstępne automatyczne dopasowanie sekwencji</li>
<li>Ręczne poprawki: dokładniejsze dopasowanie sekwencji, przycięcie</li>
<li>Wybranie modelu ewolucji molekularnej</li>
<li>Budowanie drzewa</li>
<li>Tworzenie filogramu/kladogramu</li>
<li>Poprawki: wskazanie outgrupy, obracanie gałęzi, wybór typu drzewa itp.</li>
</ul>
<p>Teraz omówimy szerzej pierwszy etap, pozostałe tylko w zarysie, wrócimy do nich osobno w części teoretycznej i/lub praktycznej.</p>
<a class="header" href="#wybór-sekwencji-do-badań" id="wybór-sekwencji-do-badań"><h2>Wybór sekwencji do badań</h2></a>
<p>Pierwszym krokiem w badaniach filogenetycznych jest wybór odpowiednich sekwencji do analiz.
Tego typu analizy opierają się na założeniu, że jeśli porównuje się odpowiadające sobie sekwencje (na przykład konkretnego genu) to u organizmów bliżej ze sobą spokrewnionych powinny być one bardziej podobne do siebie niż w przypadku taksonów bardziej odległych ewolucyjnie. Wynika to z losowego gromadzenia mutacji - im więcej czasu minęło od rozdzielenia się w toku ewolucji badanych grup, tym więcej mutacji powinno się skumulować w DNA. Takie porównania sekwencji mają oczywiście sens tylko wtedy, gdy pochodzą one od wspólnego ,,molekularnego'' przodka, czyli są <strong>homologiczne</strong>. Na tym jednak nie koniec. Sekwencje homologiczne można bowiem podzielić na dwie kategorie:</p>
<ul>
<li><strong>ortologi</strong>: sekwencje, które miały wspólnego przodka zaraz przed procesem specjacji</li>
<li><strong>paralogi</strong>: sekwencje, które powstały w skutek duplikacji, czyli miały wspólnego przodka przed zduplikowaniem.
Do badań filogenetycznych należy wybierać ortologi.</li>
</ul>
<p>Trzeba pamiętać, że samo podobieństwo badanych odcinków DNA jeszcze nie przesądza o ich homologiczności. Podobne sekwencje mogą bowiem powstać z niespokrewnionych sekwencji
w wyniku dostosowania genów do pełnienia tych samych funkcji. Takie podobieństwo nazywamy <strong>homoplazją</strong> a geny <strong>analogicznymi</strong>. Oczywiście nie nadają się one do badań filogenetycznych.</p>
<p>Kolejnym aspektem, który należy wziąć pod uwagę przy wyborze sekwencji jest ich tempo ewolucji. Różne sekwencje DNA mają różne tempo gromadzenia mutacji. Generalnie niekodujące sekwencje DNA zmieniają się w toku ewolucji dużo szybciej niż geny. Przyczyną tej różnicy nie jest różne tempo mutacji ale presja selekcyjna. Drobne zmiany fragmentów nieaktywnych DNA nie mają na ogół wpływu na organizm. Mutacje w ich obrębie mogą się więc kumulować w kolejnych pokoleniach praktycznie bez przeszkód. W przypadku sekwencji kodujących mutacje nawet pojedynczych nukleotydów, zwłaszcza jeśli są to delecje lub insercje (zbiorczo nazywane <strong>indelami</strong>) często wpływają negatywnie na funkcjonowanie produkowanych przez gen białek lub cząsteczek RNA, zmniejszając szanse lub uniemożliwiając nosicielowi mutacji przetrwanie i przekazanie mutacji następnym pokoleniom. Mutacje genów są więc w pewnym stopniu usuwane przez dobór. W jakim stopniu - to zależy od rodzaju genu.</p>
<p>Geny różnią się ,,wrażliwością'' na mutacje. W niektórych z nich niemal każda zmiana prowadzi do upośledzenia właściwego funkcjonowania kodowanego białka - są to <strong>geny konserwatywne</strong>. Do najbardziej skrajnych przykładów należą białka histonowe odpowiedzialne za strukturę chromatyny - nawet mała zmiana w ich strukturze ma niekorzystny wpływ na funkcjonowanie całego aparatu genetycznego, kluczowego dla działania komórki i organizmu. Inne geny wykazują większą tolerancję. Zatem im bardziej gen jest konserwatywny tym mniej różnic zauważymy między sekwencjami pochodzącymi od badanych organizmów.</p>
<p>Ważną konsekwencją omawianych różnic w tempie ewolucji jest to, że przy podejmowaniu decyzji którą sekwencję będzie się badać, należy wziąć pod uwagę stopień pokrewieństwa badanej grupy organizmów. Ogólna zasada jest taka, że im bliżej są one spokrewnione tym bardziej zmienne sekwencje należy wybrać. Tak więc na przykład przy badaniu gatunków w obrębie rodzaju praktyczniej jest wybrać sekwencję niekodującą lub mało konserwatywny gen, natomiast do analizy powiązań filogenetycznych pomiędzy przedstawicielami rodzin czy wyższych jednostek taksonomicznych raczej będą przydatne mniej zmienne geny. Jest to oczywiste w przypadku wyboru zbyt konserwatywnych genów. Jeśli wybierze się sekwencję o zbyt małej zmienności, może okazać się, że nie ma różnic między badanymi cząsteczkami u blisko spokrewnionych organizmów albo jest ich zbyt mało aby wyciągnąć sensowne wnioski. Mniej oczywiste są konsekwencje wyboru zbyt zmiennej sekwencji. Mogłoby się wydawać, że nie powinno to szkodzić badaniom. W końcu im więcej mutacji tym więcej informacji którą można wykorzystać przy badaniach. Kłopot w tym, że także w tym wypadku nadmiar może być szkodliwy - zbyt wiele zmian może na tyle zatrzeć podobieństwa a także poprzednie mutacje, że sekwencje nie będą się nadawać do badań filogenetycznych. Wrócimy tego tematu przy okazji omawiania modeli ewolucji molekularnej.</p>
<p>Przy wyborze rodzaju sekwencji do badań należy także wziąć pod uwagę aspekty praktyczne związane z sekwencjonowaniem DNA a także dostępność sekwencji w bazach danych (wtedy nie trzeba ich sekwencjonować we własnym zakresie).</p>
<a class="header" href="#zbieranie-sekwencji" id="zbieranie-sekwencji"><h2>Zbieranie sekwencji</h2></a>
<p>Sekwencje używane w badaniach pochodzą zazwyczaj z dwóch źródeł:</p>
<ul>
<li>badania własne</li>
<li>bazy danych</li>
</ul>
<p>Z punktu widzenia ekonomicznego i praktycznego im więcej sekwencji można pobrać z baz danych tym lepiej. Z drugiej strony, sekwencje pochodzące z własnych badań mogą wzbogacić dostępne dla innych badaczy bazy danych, co samo w sobie jest jakimś wkładem w naukę.</p>
<a class="header" href="#badania-własne" id="badania-własne"><h3>Badania własne</h3></a>
<p>W badaniach własnych zazwyczaj otrzymuje się badane sekwencje w laboratorium a następnie DNA albo analizuje się w posiadanym sekwencjonatorze albo przesyła się próbki do wyspecjalizowanej firmy, która udostępnia wyniki sekwencjonowania. Zwykle to drugie podejście jest tańsze.</p>
<a class="header" href="#internetowe-bazy-danych" id="internetowe-bazy-danych"><h3>Internetowe bazy danych</h3></a>
<a class="header" href="#genbank-i-inne-bazy-sekwencji" id="genbank-i-inne-bazy-sekwencji"><h4>Genbank i inne bazy sekwencji</h4></a>
<p>Trzy najbardziej znane, dostępne publicznie bazy danych sekwencji DNA (oraz RNA i białek) to:</p>
<ul>
<li><a href="https://www.ncbi.nlm.nih.gov/genbank/"><strong>GenBank</strong></a> utrzymywany przez National Center for Biotechnology Information (NCBI)</li>
<li><a href="http://www.ddbj.nig.ac.jp">DNA DataBank of Japan</a> (DDBJ),</li>
<li><a href="http://www.ebi.ac.uk/ena">The European Nucleotide Archive</a> (ENA)</li>
</ul>
<p>Wszystkie trzy bazy współpracują ze sobą w ramach (International Nucleotide Sequence Database Collaboration](http://insdc.org)(INSDC) synchronizując dane. W dalszej części kursu skupimy się na bazie GenBank.</p>
<p>GenBank jako otwarta baza danych rozpoczęła swoją historię w 1982 roku. <a href="https://www.ncbi.nlm.nih.gov/genbank/statistics/">Statystyki podają</a>, że w grudniu pierwszego roku działalności zawierała 606 sekwencji o łącznej długości (680 338) nukleotydów. Dziesięć lat później było ich już 97 084 (120 242 234), po kolejnej dekadzie 22 318 883 (28 507 990 166) a w grudniu 2012 r. już 161 140 325 (148 390 863 904). Dzisiaj (stan na czerwiec 2017) w GenBanku zebrano 201 663 568 sekwencji odpowiadających 234 997 362 623 zasadom. Ocenia się, że liczba sekwencji w GenBanku podwaja się średnio co ok. 18 miesięcy.</p>
<p>Jak widać ilość danych gwałtownie wzrasta. W dodatku wraz z rozwojem możliwości badań materiału genetycznego organizmów w bazie pojawia się coraz więcej sekwencji genomów wirusowych, bakteryjnych, jądrowych, mitochondrialnych i plastydowych.  Efektywne zbieranie i wyszukiwanie takich ilości danych nie byłoby możliwe, gdyby nie komputerowe, dostępne publicznie repozytoria danych. Do najbardziej niezbędnych umiejętności w badaniach filogenetycznych należy zatem przynajmniej podstawowa umiejętność wyszukiwania i pobierania danych z tego typu baz.</p>
<p>Baza GenBank pozwala wyszukiwać sekwencje na kilka sposobów. Zapewne najczęściej używana jest metoda zbliżona do wyszukiwarek internetowych, polegająca na wpisywaniu tekstu, np. nazw organizmów czy sekwencji, w okienko i przeglądaniu wyników wyszukiwania. Można przy tym wybierać spośród wielu dostępnych kategorii, m. in. sekwencje nukleotydów, genomy, taksony, białka. Przykładowo, jeśli chcemy wyszukać sekwencje ITS dla rodzaju <em>Rumex</em>, możemy wpisać <code>Rumex ITS</code>:</p>
<p><img src="pics-podstawy/genbank-wyszukiwanie.png" alt="Proste wyszukiwanie" /></p>
<p>Trzeba jednak uważać na kilka potencjalnych problemów. Po pierwsze przynajmniej obecnie, baza GenBank nie jest tak ,,domyślna'' jak np. wyszukiwarka Google. Przykładowo jeśli zrobimy literówkę, i zamiast <code>Rumex ITS</code> wpiszemy <code>Ramex ITS</code> to nie ujrzymy podpowiedzi w rodzaju <code>Czy chodziło Ci o Rumex ITS?</code>, tylko baza nie zwróci żadnych wyników.</p>
<p><img src="pics-podstawy/genbank-literowka.png" alt="Genbank - literówka" /></p>
<p>Jeśli wyszukiwanie nie zwraca wyników a jesteśmy pewni, że wpisaliśmy zapytanie prawidłowo, można spróbować inaczej je sformułować, na przykład zamiast używania skróconych nazw sekwencji wpisać pełną nazwę, lub jej fragment. Dzięki temu można czasem znaleźć to o co chodziło ale wyniki mogą też zaskakiwać. Przykładowo wpisanie zapytania <code>Rumex rbcL</code> zwraca 196 wyników:</p>
<p><img src="pics-podstawy/genbank-nazwa-skrot.png" alt="Genbank - nazwa skrótowa" /></p>
<p>Wpisane długiej nazwy, którą widać w opisie pierwszych sekwencji (<code>Rumex ribulose-1,5-bisphosphate carboxylase/oxygenase large subunit</code>) nie przynosi żadnych wyników:</p>
<p><img src="pics-podstawy/genbank-nazwa-pelna.png" alt="Genbank - nazwa pełna" /></p>
<p>Natomiast zapytanie <code>Rumex biposphate large subunit</code> zwraca 147 sekwencji:</p>
<p><img src="pics-podstawy/genbank-nazwa-czesciowa.png" alt="Genbank - nazwa częściowa" /></p>
<a class="header" href="#blast" id="blast"><h4>Blast</h4></a>
<p>GenBank i inne podobne do niego bazy sprawdzają się dobrze, gdy wyszukujemy sekwencje po ich nazwie, opisie czy nazwie taksonu. Ale często trzeba podejść do problemu z drugiej strony - mamy sekwencję nukleotydów i chcemy znaleźć inne, podobne do niej. Jest tak na przykład gdy nie wiemy czy odpowiada ona jakiemuś konkretnemu genowi albo gdy chcemy sprawdzić u jakiego organizmu występuje sekwencja najbardziej podobna (np. jeśli badamy odcinek DNA niewiadomego pochodzenia). W takich sytuacjach z pomocą przychodzi <a href="https://blast.ncbi.nlm.nih.gov">Blast</a> (Basic Local Alignment Search Tool).</p>
<p><img src="pics-podstawy/blast.png" alt="Blast" /></p>
<p>Jak widać serwis umożliwia wyszukiwanie sekwencji nukleotydowych a także białkowych. W najprostszym przypadku na stronie wyszukiwania w odpowiednim okienku wpisujemy szukaną sekwencję i wciskamy przycisk ,,Blast'' na dole strony. Po dłuższej lub krótszej chwili oczekiwania wyświetlane są wyniki. Na górze strony mają one postać graficzną:</p>
<p><img src="pics-podstawy/blast-wyniki-graficzne.png" alt="Blast - wyniki graficzne" /></p>
<p>Poniżej widnieje lista z krótką informacją na temat znalezionych sekwencji</p>
<p><img src="pics-podstawy/blast-wyniki-tekstowe.png" alt="Blast - wyniki tekstowe" /></p>
<p>Pod nimi znajdują się dokładniejsze dane, schematyczne przedstawienie przyrównania sekwencji szukanej i znalezionej a także odsyłacze prowadzące do dalszych informacji dotyczących sekwencji w bazie GenBank.</p>
<p><img src="pics-podstawy/blast-wyniki-szczegoly.png" alt="Blast - wyniki szczegółowe" /></p>
<p>Do dokładniejszego omówienia korzystania z obu baz a także pobierania z nich danych wrócimy w części praktycznej.</p>
<a class="header" href="#zbieranie-sekwencji-1" id="zbieranie-sekwencji-1"><h3>Zbieranie sekwencji</h3></a>
<p>Do badań filogenetycznych sekwencje zapisuje się zwykle w plikach tekstowych w formacie <strong>FASTA</strong>. Zapis danych w pliku tekstowym ma wiele zalet. Może być edytowany w dowolnym edytorze tekstu (np. Vim, Emacs, Notepad++, Atom, TextMate, Jed, Pico), a także łatwo używać do pracy z nimi licznych dostępnych w systemach Uniksowych (np. w Linuksie) narzędzi ułatwiających na przykład wyciąganie z nich konkretnych danych. Z niektórymi z nich zapoznamy się w części praktycznej. Uwaga: Word NIE jest edytorem tekstu, plik zapisany w formacie Worda NIE jest plikiem tekstowym.</p>
<p>Plik zawierający sekwencje nukleotydów w formacie  FASTA może wyglądąć np. tak:</p>
<pre><code>&gt;KC879635_Magnolia_stellata             
CTGCTAACTCTCAGTTTGGTCCTACTTCTGGTTCATTTTGTTACTAAAAACGGAGGGGGAA
ACTCAGTACCAAATGCTTGGCAATCCTTGGTAGAGCTTATTCATGATTTCGTGCCGAACCC
GGTAAACGAACAAATAGGTGGTCTTTCCGGAAATGTTCAACAAAAGTTTTCCCCTCGCATC
TCGGTCACTTCTACTTTTTCGTTATTTCGTAATCCCCAGGGTATGATACCTTATAGCTTCA
CAGTCACAAGTCATTTTCTCATTACTTTGGGTCTCTCATTTCCGATTTTTATTGGCATTAC
TATAGTGGGATTTCAAAGAAATGGGCTTCATTTTTTAAGCATCTCATTACCCGCAGGAGTC
CCACTGCCGTTAGCACCTTTTTTAGTACTCCTTGAGCTAATCCCTCATTGTTTTCGCGCAT
TAAGCTCAGGAATACGTTTATTTGCTAATATGATGGCCGGTCATAGTTCAGTAAAGATTTT
AAGTGGGTCCGCTTGGACTATGCTATGTATGAATGATCTTTTTTATTTCATAGGAGATCCT
GGTCCTTTATTTATAGTTCTTGCATTAACCGGTCCGGAATTAGGTGTAGCTATATCACAAG
CTCATGTTTCTACGATCTCAATCTGTATTTAC
&gt;AF095276_Solanum_tuberosum             
CTACTAACTCTCAGTTTGGTCCTACTTTTGGTTTATTTTGTTACTAAAAAGGGAGGAGGAA
ACTCAGTACCAAATGCTTGGCAATCCTTGGTAGAGCTTATTTATGATTTCGTGCTGAACCC
GGTAAACGAACAAATAGGTGGTCTTTCCGGAAATGTTAAACAAAAGTTTTCCCCTCGCATC
TCGGTCACTTTTACTTTTTCGTTATTTTGTAATCCCCAGGGTATGATACCTTATAGCTTCA
CAGTTACAAGTCATTTTCTCATTACTTTGGGTCTCTCATTTTCTATTTTTATTGGCATTAC
TATAGTGGGATTTCAAAAAAATGGGCTTCATTTTTTAAGCTTCTTATTACCCGCGGGAGTC
CCGCTGCCATTAGCACCTTTTTTAGTACTCCTTGAGCTAATCCCTTATTGTTTTCGAGCAT
TAAGCTCAGGAATACGTTTATTTGCTAATATGATGGCCGGTCATAGTTCAGTAAAGATTTT
AAGTGGGTTCGCTTGGACTATGCTATGTATGAATGATCTTTTCTATTTCATAGGGGATCTT
GGTCCTTTATTTATAGTTCTTGCATTAACCGGTCTGGAATTAGGTGTAGCTATATCACAAG
CTCATGTTTCTACGATCTTAATCTGTATTTAC
&gt;JN098455_Mimulus_guttatus              
CTACTCACTCTCAGTTTGGTCCTACTTTTTGTTCATTTTGTTACTAAAAAGGGAGGAGGAA
ACTCAGTACCAAATGCTTGGCAATCCTTGGTAGAGCTTATTTATGATTTCGTGCCGAACCT
GGTAAACGAACAAATAGGTGGTCTTTCCGGAAATGTGAAACAAAAGTTTTTCCCTTGCATC
TCGGTTACTTTTACTTTTTCGTTATTTCGTAATCTTCAGGGTATGATACCTTATAGCTTCA
CAGTTACAAGTCATTTTCTCATTACTTTGGGTCTCTCATTTTCTCTTTTTATTGGCATTAC
TATAGTGGGATTTCAAAAAAATGGGCTTCATTTTTTAAGCTTCTCATTACCCGCAGGAGTC
CCACTGCCGTTAGCACCTTTTTTAGTACTACTTGAGCTAATCCCTCATTGTTTTCGCGCAT
TAAGCTTAGGAATACGTTTATTTGCTAATATGATGGCCGGTCATAGTTCAGTAAAGATTTT
AAGTGGGTCCGCTTGGACTATGCTATGTATGAATGATCTTTTCTATTTCATAGGGGATCCT
GGTCCTTTATTTATAGTTCTTGCATTAACCGGTCTGGAATTAGGTGTAGCTATATCACAAG
CTCATGTTTCTACGATCTCAATCTGTATTTAC
</code></pre>
<p>Każda sekwencja nukleotydów poprzedzona jest linią zaczynającą się znakiem <code>&gt;</code>. Po tym znaku powinien znajdować się opis sekwencji. W powyższym przykładzie jest on dość lakoniczny, zawiera tylko numer dostępowy GenBank oraz nazwę taksonu, ale można tam zawrzeć też dużo więcej informacji. Tak na przykład wygląda nagłówek jednej z sekwencji pobranej z bazy GenBank:</p>
<p><code>&gt;KX282989.1 Rumex vesicarius voucher EDNA15-0042869 ribulose-1,5-bisphosphate carboxylase/oxygenase large subunit (rbcL) gene, partial cds; chloroplast</code></p>
<p>Po linii z opisem zapisana jest sekwencja nukleotydów lub aminokwasów. Może ona znajdować się w jednej lub wielu liniach, zasada jest taka, że wszystkie linie aż do następnego znaku <code>&gt;</code> na początku linii powinny zawierać tylko i wyłącznie sekwencję. Niekoniecznie musi ona zawierać wyłącznie litery oznaczające nukleotydy lub aminokwasy, mogą tam także znajdować się dodatkowe oznaczenia np. niejednoznacznych lub nieznanych nukleotydów czy miejsc delecji. Stosuje się tu konwencję oznaczeń <a href="http://www.iupac.org">IUPAC</a>.</p>
<table><thead><tr><th align="center"> <strong>Symbol IUPAC</strong> </th><th align="center">    <strong>znaczenie</strong></th></tr></thead><tbody>
<tr><td align="center">        A         </td><td align="center">       Adenina</td></tr>
<tr><td align="center">        C         </td><td align="center">      Cytozyna</td></tr>
<tr><td align="center">        G         </td><td align="center">       Guanina</td></tr>
<tr><td align="center">    T (lub U)     </td><td align="center"> Tymina (lub Uracyl)</td></tr>
<tr><td align="center">        R         </td><td align="center">       A lub G</td></tr>
<tr><td align="center">        Y         </td><td align="center">       C lub T</td></tr>
<tr><td align="center">        S         </td><td align="center">       G lub C</td></tr>
<tr><td align="center">        W         </td><td align="center">       A lub T</td></tr>
<tr><td align="center">        K         </td><td align="center">       G lub T</td></tr>
<tr><td align="center">        M         </td><td align="center">       A lub C</td></tr>
<tr><td align="center">        B         </td><td align="center">    C lub G lub T</td></tr>
<tr><td align="center">        D         </td><td align="center">    A lub G lub T</td></tr>
<tr><td align="center">        H         </td><td align="center">    A lub C lub T</td></tr>
<tr><td align="center">        V         </td><td align="center">     A or C or G</td></tr>
<tr><td align="center">        N         </td><td align="center"> nieznany nukleotyd</td></tr>
<tr><td align="center">     - lub .      </td><td align="center">   brak nukleotydu</td></tr>
</tbody></table>
<p>Czasem pomiędzy końcem sekwencji a nagłówkiem kolejnej dodawana jest pusta linia co może zwiększać czytelność dla człowieka.</p>
<p>Format FASTA jest najprostszy i najpopularniejszy ale istnieją także inne, np. phylip, nexus, fastq.</p>
<a class="header" href="#dopasowanie-sekwencji" id="dopasowanie-sekwencji"><h2>Dopasowanie sekwencji</h2></a>
<p>Jak wspomniałem wcześniej sekwencje używane do badan filogenetycznych powinny być homologiczne. Dopasowanie wybranych sekwencji polega na tym aby ustawione w kolejnych liniach sekwencje miały w kolejnych kolumnach <strong>homologiczne</strong> względem siebie <strong>nukleotydy</strong>.</p>
<p>Dopasowanie sekwencji składa się zwykle z dwóch etapów:</p>
<ul>
<li>Wstępne dopasowanie automatyczne dokonywane przez odpowiednie programy</li>
<li>Poprawki dokonywane przez człowieka</li>
</ul>
<p>Do wstępnego automatycznego wyrównania stosowanych jest wiele programów, które używają różnych algorytmów. W dodatku na sposób i efektywność działania każdego z nich duży wpływ mają parametry, które ustawia się przy ich uruchamianiu. Dlatego na pytania w rodzaju ,,<em>który program jest najlepszy do dopasowania sekwencji?</em>'' nie ma dobrej odpowiedzi. Bardzo duże znaczenie ma tu rodzaj dopasowywanych sekwencji i ustawienia programów. Do najpopularniejszych programów tego typu należą m. in. <code>clustalw</code>, <code>muscle</code>, <code>mafft</code>, <code>probcons</code>.</p>
<p>Jeśli porównywane sekwencje są stosunkowo mało zmienne i nie mają indeli (insercji i/lub delecji) automatyczne dopasowanie może nie wymagać ręcznych poprawek albo są one ograniczone do przycięcia końców sekwencji tak aby miały równą długość. Jeśli jednak tak nie jest,etap ręcznych poprawek może być długi i żmudny a  końcowy efekt może być w większym lub mniejszym stopniu niepewny.</p>
<p>Do pracy nad wstępnie wyrównanym zestawem sekwencji używać można edytorów tekstu, najlepiej z odpowiednimi skryptami/wtyczkami ułatwiającymi czytelne przedstawienie wyrównywanych sekwencji co związane jest z ich odpowiednim wyświetleniem oraz zwykle kolorowaniem. Na poniższej ilustracji przedstawiony jest edytor Vim (MacVim) z odpowiednimi udogodnieniami zaprogramowanymi przez autora tego tekstu:</p>
<p><img src="pics-podstawy/vim-fasta.png" alt="Vim i FASTA" /></p>
<p>Częściej jednak, używa się w tym celu dedykowanych programów, które zwykle są wzbogacone w wiele dodatkowych funkcji ułatwiających pracę z plikami FASTA jak wyrównywanie sekwencji, zmiana na sekwencje odwrócone komplementarne, eksport do innych formatów  a także dodatkowymi czynnościami jak wyszukiwanie sekwencji w bazach czy tworzenie drzewek filogenetycznych. Przykładami są program AliView i Jalview:</p>
<p><img src="pics-podstawy/aliview-fasta.png" alt="AliView - wyrównane sekwencje" /></p>
<p><img src="pics-podstawy/jalview-fasta.png" alt="Jalview - wyrównane sekwencje" /></p>
<a class="header" href="#wybór-modelu-ewolucji-molekularnej" id="wybór-modelu-ewolucji-molekularnej"><h2>Wybór modelu ewolucji molekularnej</h2></a>
<p>Kolejnym etapem w drodze do stworzenia drzewa filogenetycznego powinien być wybór modelu ewolucji molekularnej. Modele ewolucji molekularnej a dokładniej modele substytucji (podstawień) nukleotydów, opisują w jaki sposób mogły ewoluować badane sekwencje. Główne znaczenie ma tu prawdopodobieństwo zmian jednych nukleotydów w inne. W najprostszych modelach szansa na zajście każdej z możliwych substytucji jest taka sama, w bardziej złożonych, jak łatwo się domyślić, prawdopodobieństwa różnią się.</p>
<p>Wybór modelu odpowiedniego dla badanego zestawu sekwencji odbywa się za pomocą odpowiednich programów. Niektóre z nich dedykowane są wyłącznie do tego zadania, na przykład <code>jModelTest 2</code>, ale niektóre programy przeznaczone do obliczania drzew, (np. <code>IQTree</code>) mogą automatycznie dobrać model.</p>
<a class="header" href="#konstruowanie-drzew-i-szacowanie-ich-wiarygodności" id="konstruowanie-drzew-i-szacowanie-ich-wiarygodności"><h2>Konstruowanie drzew i szacowanie ich wiarygodności</h2></a>
<p>Mając dopasowane sekwencje nukleotydów oraz znaleziony model podstawień nukleotydów można przystąpić do konstruowania drzewa. Także na tym etapie napotykamy na dość duży wybór metod i programów, które służą wyliczeniu najbardziej prawdopodobnych związków filogenetycznych pomiędzy badanymi organizmami, które w kolejnym kroku będzie można przedstawić w formie graficznej.</p>
<p>Najbardziej znane metody używane przy konstruowaniu drzew to:</p>
<ul>
<li>UPGMA (Unweighted Pair-Group Method using arithmetic Averages)</li>
</ul>
<!---
  * Metoda minimalnej ewolucji (ME - Minimum Evolution)
-->
  * Metoda najbliższego sąsiada (NJ - NeighborJoining)
  * Metoda największej oszczędności (MP - Maximum Parsimony)
  * Metoda największej wiarygodności (ML - Maximum Likelihood)
  * Metody bayesowskie (Bayesian Methods)
<p>Możemy je wykorzystać w programach, które zazwyczaj implementują jedną z metod, choć często z pewnymi modyfikacjami i dodatkami. Należą do nich <code>PhyML</code>, <code>IQ-tree</code>, <code>RAxML</code>, <code>PHYLIP</code>, <code>PAUP*</code>, <code>mrBAYES</code>, <code>BEAST</code>. Istnieją także ,,kombajny'', jak np. <code>MEGA</code>, które pozwalają liczyć drzewa na kilka sposobów.</p>
<p>Konstruowaniu drzew towarzyszy zazwyczaj szacowanie ich wiarygodności. W większości przypadków stosuje się tu metodę <strong>bootstrap</strong> (samopróbkowania), dla metod bayesowskich wyliczane jest prawdopodobieństwo bayesowskie.</p>
<p>Po zakończeniu obliczeń otrzymujemy wynik zazwyczaj w formie pliku tekstowego, który jest sformatowany w taki sposób, że zawiera informacje na temat relacji pomiędzy badanymi taksonami a także inne parametry drzew (np. wartości bootstap).</p>
<a class="header" href="#wizualizacja-drzew" id="wizualizacja-drzew"><h2>Wizualizacja drzew</h2></a>
<p>Forma graficzna drzewa filogenetycznego jest znacznie bardziej przejrzysta dla człowieka niż prezentowany powyżej zapis tekstowy. Pozwała łatwo uchwycić pokrewieństwa i odległości ewolucyjne pomiędzy badanymi organizmami, choć ich prawidłowe odczytanie wymaga jednak nieco wiedzy i wprawy.</p>
<p><img src="pics-podstawy/circle.png" alt="Drzewa filogenetyczne" /></p>
<a class="header" href="#dopasowanie-sekwencji---zasady-i-algorytmy" id="dopasowanie-sekwencji---zasady-i-algorytmy"><h1>Dopasowanie sekwencji - zasady i algorytmy</h1></a>
<p>Etap dopasowania sekwencji jest kluczowy dla powodzenia całej procedury tworzenia drzew filogenetycznych. Zadanie polega na tym aby tak dopasować poszczególne nukleotydy (i miejsca gdzie ich brak) aby były względem siebie w kolumnach homologiczne - czyli miały wspólne pochodzenie. Jej trudność i stopień wiarygodności otrzymanych rezultatów zależy przede wszystkim od zróżnicowania porównywanych sekwencji a zwłaszcza od tego czy zawierają one liczne indele (insercje i delecje).</p>
<a class="header" href="#ogólne-zasady-dopasowania" id="ogólne-zasady-dopasowania"><h2>Ogólne zasady dopasowania</h2></a>
<p>Rozpatrzmy na początek dwie sekwencje:</p>
<pre><code>CCCGATAAGGATCAATCACATACAGTT
CCCAGGATCAATCACATACAACAGTT
</code></pre>
<p>Można zauważyć, że mają identyczną część wspólną, więc łatwo je ze sobą zestawić. Znaki <code>-</code> oznaczają brakujący nukleotyd, który odpowiada indelowi:</p>
<pre><code>CCCGATAAGGATCAATCACATACA---GTT
CCC----AGGATCAATCACATACAACAGTT
</code></pre>
<p>Ale po bliższym przyjrzeniu się, pojawiają się też inne możliwości:</p>
<pre><code>CCCGATAAGGATCAATCACATA---CAGTT
CCC-A---GGATCAATCACATACAACAGTT
</code></pre>
<p>albo:</p>
<pre><code>CCC-G-AT-AAGGATCAATCA--CATACAGTT
CCCAGGATCAA---TCA--CATACA-ACAGTT
</code></pre>
<p>itd...</p>
<p>Jak widać, nawet dwie sekwencje można dopasować na wiele sposobów. Intuicja zapewne podpowiada nam, że spośród pokazanych, ten pierwszy jest ,,najwłaściwszy''. Ale dlaczego właśnie ten a nie inny? To zestawienie jest ,,najprostsze'' - do wyjaśnienia różnic pomiędzy sekwencjami wystarczy przyjąć powstanie dwóch indeli co jest bardziej prawdopodobne niż powstanie ich trzech czy siedmiu. Ale to jest tylko najbardziej prawdopodobne wyjaśnienie co nie musi oznaczać, że jest prawdziwe.
Ten prosty przykład, w którym przecież nie uwzględniliśmy możliwości substytucji nukleotydów pokazuje, że dopasowanie sekwencji rzeczywiście może być skomplikowane a wynik nie jest pewny. Nie istnieje żaden złoty zestaw reguł, który pozwoliłby uzyskać zawsze najlepsze dopasowanie - gdyby taki istniał nie byłoby konieczności ręcznych poprawek wykonywanych po dopasowaniu automatycznym. Chodzi o to, aby znaleźć takie dopasowanie, które odpowiadałoby najbardziej prawdopodobnej ewolucji obu sekwencji. Kluczowe znaczenie w dokonywaniu dopasowań jest szacowanie prawdopodobieństwa wydarzeń. Przyjmuje się np., że powstanie substytucji jest bardziej prawdopodobne niż powstanie indelu a z kolei powstanie długiego indelu jest częstsze niż powstanie kilku mniejszych. W szacowaniu prawdopodobieństwa poszczególnych wydarzeń pomaga znajomość procesów biorących udział w powstawaniu mutacji. Na przykład indele mogą powstawać na różne sposoby, m.in.:</p>
<ul>
<li>pojedyncze nukleotydy mogą wypaść lub być wstawione w wyniku prostych błędów replikacji DNA: <code>ACGAGA</code> -&gt; <code>ACAGAGA</code></li>
<li>nierówny <em>crossing-over</em> w mejozie może spowodować wstawienie (lub wypadnięcie) szeregu nukleotydów: <code>ACGAGA</code> -&gt; <code>ACGCCATAAGA</code></li>
<li>,,poślizg'' polimerazy DNA może spowodować powtórzenie danej sekwencji: <code>ACGAGA</code> -&gt; <code>ACGAGA</code> -&gt; <code>ACGAGAAGA</code></li>
<li>dłuższe fragmenty nici mogą zostać wstawione w wyniku translokacji z innej części tej samej nici czy innego chromosomu a także jako efekt działania transpozonów czy wirusów.</li>
</ul>
<p>Istnieje także możliwość, że brakujący lub nadmiarowy nukleotyd pojawił się w sekwencji w wyniku błędu sekwencjonowania lub niewłaściwej interpretacji chromatogramu. Zwłaszcza ,,podejrzane'' są indele o liczbie różnej niż trzy (długość) kodonu w przypadku badania funkcjonujących genów. Jak wiadomo, tego typu mutacje zmieniają sens dalszej części sekwencji co skutkuje zazwyczaj pozbawieniem funkcjonalności białka, które gen koduje. Dlatego w przypadku pojawienia się tego typu indeli w sekwencjach warto, o ile to możliwe, upewnić się, że nie jest to wynik błędu, na przykład poprzez ponowną analizę chromatogramów.</p>
<a class="header" href="#jak-można-przedstawić-dopasowanie" id="jak-można-przedstawić-dopasowanie"><h2>Jak można przedstawić dopasowanie?</h2></a>
<p>Najprostszy sposób prezentacji dopasowania sekwencji widać poniżej. Sekwencje znajdują się bezpośrednio pod sobą, w odpowiednich miejscach występują znaki <code>-</code> oznaczające brakujące nukleotydy (lub aminokwasy). W niektórych programach, zwłaszcza z interfejsem graficznym stosuje się kolorowanie poszczególnych zasad co pozwala na łatwiejszą wizualną identyfikację miejsc dopasowanych i niedopasowanych.</p>
<p><img src="pics-dopasowanie/dopasowanie-kolorowe.png" alt="Dopasowane kolorowane" /></p>
<p>Dopasowane miejsca mogą być także oznaczone w specjalny sposób, np. za pomocą znaku <code>*</code>:</p>
<pre><code>AAAGATACTGATA-CTTAG
ATAGATACT-ATATTTTAG
* ******* ***  ****
</code></pre>
<p>Pomiędzy sekwencjami można także dodać dodatkową linię, w której znak <code>|</code> wskazuje na dopasowanie. Ten sposób nadaje się zwłaszcza do prezentacji przyrównania dwóch sekwencji, przy ich większej liczbie jest raczej nieczytelny. Wykorzystywany jest np. przy prezentacji wyników przez <a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi">BLAST</a>:</p>
<pre><code>AAAGATACTGATA-CTTAG
| ||||||| |||  ||||
ATAGATACT-ATATTTTAG
</code></pre>
<p>Można także dodatkowo oznaczyć kropkami miejsca gdzie nukleotydy nie pasują do siebie:</p>
<pre><code>AAAGATACTGATA-CTTAG
|.||||||| ||| .||||
ATAGATACT-ATATTTTAG
</code></pre>
<p>Oczywiście istnieją jeszcze inne sposoby prezentacji wyników dopasowania, których jednak nie będę tu przedstawiał.</p>
<a class="header" href="#systemy-punktacji" id="systemy-punktacji"><h2>Systemy punktacji</h2></a>
<p>Wspomniane powyżej zasady przyrównania sekwencji, jakkolwiek przydatne przy ręcznych poprawkach dopasowania sekwencji, muszą zostać skonkretyzowane jeśli mają zostać zastosowane w programach komputerowych. Temu właśnie służą <strong>systemy punktacji</strong>, które pozwalają porównać jakość dopasowań za pomocą liczb. W takim ujęciu porównuje się poszczególne miejsca dopasowania przyznając każdemu z nich odpowiednią liczbę punktów. W najprostszym przypadku można przyjąć, że jeśli dwa nukleotydy są takie same, to przyznany zostaje jeden punkt, jeśli się różnią to punkt nie zostaje przyznany. W najprostszym przypadku zakładamy, że różne substytucje są równie prawdopodobne, ale możemy też przyjąć inne założenia z przyczyn o których będzie mowa przy okazji omawiania modeli substytucji.</p>
<p>Dla przerw (odpowiadających indelom)  można przyjąć, że liczba karnych punktów za dany indel odpowiada liczbie miejsc w przerwie pomnożonej przez wartość kary. Można także przyznać karę za otwarcie przerwy, czyli samą obecność indelu i karę za każdy kolejny brakujący nukleotyd co pozwala na odróżnienie jednego długiego indelu od wielu krótszych.</p>
<p>Jeśli badamy funkcjonujące geny to oprócz analizy nukleotydów warto przyjrzeć się sekwencjom aminokwasów, które wynikają z różnych dopasowań. Bardziej prawdopodobne są mutacje, które nie zmieniają znaczenia kodonu (degeneracja kodu genetycznego) a jeśli zmieniają to w taki sposób, który nie wpływa na strukturę białka. Oczywiście sprawdzenie tego ostatniego wymaga użycia dodatkowych narzędzi.</p>
<p>Bardziej złożone są systemy punktacji przy przyrównywaniu aminokwasów. Opierają się one na właściwościach kodu genetycznego, cechach fizykochemicznych aminokwasów lub na badaniach empirycznych. Przedstawia się je zwykle w postaci macierzy zawierających punkty dla poszczególnych kombinacji aminokwasów. Macierze oparte na badaniach empirycznych uważane są za bardziej wiarygodne, należą do nich macierze <strong>PAM</strong> (Point Accepted Mutation) i <strong>BLOSUM</strong> (BLOcks SUbstitution Matrix).</p>
<a class="header" href="#dopasowanie-metodą-programowania-dynamicznego" id="dopasowanie-metodą-programowania-dynamicznego"><h2>Dopasowanie metodą programowania dynamicznego</h2></a>
<p>Poszukiwanie optymalnego dopasowania polega w ogólnym zarysie na porównywaniu wszystkich możliwych dopasowań. Oczywiście proces ten jest tym bardziej czasochłonny im sekwencje są dłuższe. Można to robić metodą <em>brute force</em>, czyli składać sekwencje kolejno na wszelkie możliwe sposoby i za każdym razem obliczać jakość dopasowania. Jest to jednak sposób, który choć gwarantuje znalezienie optymalnego rozwiązania, jest bardzo mało efektywny co jest związane z tym, że wielokrotnie przeprowadzane są te same obliczenia. Jeśli obliczymy wartość jednego dopasowania a potem będziemy oceniać inne dopasowanie, różniące się od poprzedniego tylko położeniem jednonukleotydowej przerwy to i tak trzeba będzie obliczyć wartości dopasowania dla wszystkich pozostałych miejsc.</p>
<p>Proces ten ułatwiają metody programowania dynamicznego (dynamicznej optymalizacji) polegające na tym, że złożony problem dzieli się na wiele mniejszych, które rozwiązuje się osobno. Rozwiązania mniejszych problemów zostają zapamiętane, kiedy ponownie się na nie natrafia, nie rozwiązuje się ich ponownie ale wykorzystuje wcześniejszy wynik. Pozwala to na znaczną oszczędność w obliczeniach. W bioinformatyce programowanie dynamiczne stosuje się w przy wielu złożonych problemach jak np. przewidywanie struktury białek i RNA, wiązania białek z DNA czy właśnie przyrównanie sekwencji nukleotydów.   Zobaczmy zatem jak to działa na nieco uproszczonym przykładzie.</p>
<p>Przypuśćmy, że mamy do dopasowania dwie sekwencje:</p>
<p><img src="pics-dopasowanie/pd-sekwencje.png" alt="Sekwencje, które chcemy dopasować" /></p>
<p>Zaczynamy od stworzenia tablicy (macierzy). Na górze, w nagłówkach kolumn tabeli, umieszczamy jedną sekwencję, z boku, w kolejnych rzędach, drugą sekwencję:</p>
<p><img src="pics-dopasowanie/pd-tablica.png" alt="Tabela z sekwencjami" /></p>
<p>Przyjmujemy punktację:</p>
<ul>
<li>dopasowane zasady: 1</li>
<li>niedopasowane zasady: 0</li>
<li>indel: -1</li>
</ul>
<p>Teraz czas na wypełnienie tablicy wartościami.</p>
<p><img src="pics-dopasowanie/pd-wypelnianie.png" alt="Wypełnianie tablicy" /></p>
<ol>
<li>W lewym górnym rogu zaznaczamy kwadrat obejmujący cztery sąsiednie komórki. Wypełniamy wartości komórek górnych i znajdującej się po lewej stronie w drugim rzędzie wartościami wg. powyższej punktacji. <code>G-G</code> -&gt; 1, <code>G-C</code> -&gt; 0, <code>T-G</code> -&gt; 0. Komórka w dolnym prawym rogu pozostaje na razie pusta.</li>
<li>Obliczamy wartość dla pustej komórki: znajdujemy najwyższą wartość w sąsiadujących komórkach w szarym kwadracie. Jest to wartość 1 (pomarańczowa strzałka). Następnie dodajemy do niej punkty za dopasowanie (w tym przypadku jest to 0 ponieważ T nie pasuje do C) i wpisujemy otrzymany wynik (1).</li>
<li>Przesuwamy szary kwadrat w prawo i uzupełniamy brakujące wartości analogicznie to punktu powyżej.</li>
<li>Podobnie postępujemy z kolejnymi komórkami tabeli. Tu dochodzimy do końca rzędu, ponieważ w ostatniej komórce zasady pasują do siebie, do przepisanej 1 dodajemy 1, otrzymując 2.</li>
<li>Przesuwamy kwadrat o rząd niżej i uzupełniamy brakujące wartości.</li>
<li>W kolejnym kroku trzy wartości w kwadracie są takie same, przepisujemy 1.</li>
<li>Ponieważ <code>A</code> pasuje do <code>A</code> ponownie zwiększamy wartość w prawej dolnej komórce</li>
<li>Kontynuujemy wypełnianie tabeli do końca</li>
</ol>
<p>Po wypełnieniu tablicy czas na ,,odczytanie'' dopasowania. Polega ono na znalezieniu ścieżki o największej liczbie punktów od prawego dolnego do lewego górnego rogu macierzy. Poruszamy się zatem w odwrotnym kierunku niż przy wpisywaniu wartości. Kierunek ruchu wyznacza największa liczba sąsiadująca z daną komórką ale tym razem będziemy przyznawać punkty karne za indele (-1), które oznaczone są poziomymi lub pionowymi czerwonymi strzałkami. Oczywiście nie wolno poruszać się w prawo ani w dół.</p>
<p><img src="pics-dopasowanie/pd-sciezka1.png" alt="Odczytanie dopasowania" /></p>
<ol>
<li>Zaczynamy od ostatniej komórki o wartości 4, sąsiaduje ona z komórkami o wartości 3. Wybieramy drogę na ukos, nieobciążoną karą za indel. Mamy 4 + 3 = 7 punktów. Nasze dopasowanie wygląda tak (pionowa kreska oznacza dopasowane zasady, jej brak wskazuje na brak dopasowania):</li>
</ol>
<pre><code>  A T
  | |
  A T
</code></pre>
<ol start="2">
<li>Teraz komórka o najwyższej wartości znajduje się po lewej, co będzie oznaczało indel i punkty karne: 7 + 2 - 1 = 8. Uzupełniamy zatem wynik dopasowania:</li>
</ol>
<pre><code>  A A T
    | |
  - A T
</code></pre>
<ol start="3">
<li>W kolejnym kroku kierujemy się ukośnie w górę na lewo. 8 + 1 = 9.</li>
</ol>
<pre><code>  C A A T
      | |
  T - A T
</code></pre>
<ol start="4">
<li>Dochodzimy do początku tabeli. 9 + 1 = 10. Otrzymujemy dopasowanie końcowe:</li>
</ol>
<pre><code>  G C A A T
  |     | |
  G T - A T
</code></pre>
<p>Zauważ, że można też wykreślić alternatywną ścieżkę, o takiej samej liczbie punktów:</p>
<p><img src="pics-dopasowanie/pd-sciezka2.png" alt="Odczytanie dopasowania" /></p>
<p>W tym wypadku otrzymane dopasowanie będzie wyglądało tak:</p>
<pre><code>  G C A A T
  |   |   |
  G T A - T
</code></pre>
<p>Trudno powiedzieć, które z uzyskanych dopasowań jest lepsze, w takim przypadku wybór jest arbitralny.</p>
<p>Jak wspomniałem powyżej pokazany algorytm jest bardzo uproszczony a co za tym idzie, niedoskonały. Nie uwzględnia na przykład możliwości indeli na końcach dopasowań. Toteż realnie stosowane algorytmy są bardziej złożone.</p>
<p>[TODO? - może wrzucić bardziej złożony przykład.]</p>
<a class="header" href="#dopasowanie-globalne-i-lokalne" id="dopasowanie-globalne-i-lokalne"><h2>Dopasowanie globalne i lokalne</h2></a>
<p>Proste przyrównywanie sekwencji i ocena ich jakości za pomocą nieskomplikowanych systemów punktacji może prowadzić na manowce. Rozważmy na przykład dwie sekwencje:</p>
<pre><code>&gt;seq1
AAGACTTCACTAACGTGATTGATAGCATCGAATACTGACGAGACG
&gt;seq2
TACTGACTAGCTTCGAATACTGGGATCGTTGAAAATCACCTCCG
</code></pre>
<p>Można je przyrównać w ten sposób:</p>
<pre><code>-A---A--GACTTC-ACTAACGTGATTGATAGCATCGAATACTGACGAGACG
 |   |    |||| | ||  | ||| | |   |   |   |        ||
TACTGACTAGCTTCGAATACTGGGATCGTTGAAAATCACCTC--------CG
</code></pre>
<p>Jeśli teraz przyjmiemy system punktacji: 1 za dopasowaną parę nukleotydów, -1 za indel. Otrzymamy:</p>
<p>20 dopasowań - 15 indeli = 5 punktów</p>
<p>Teraz przyjrzyjmy się alternatywnemu dopasowaniu:</p>
<pre><code>AAGACTTCACTAACGTGATTGATAGCATCGAATACT--GA-CGA--GA----------CG
          || | |||    |||| |||||||||  || ||   ||          ||
----------TA-C-TGA--C-TAGCTTCGAATACTGGGATCG-TTGAAAATCACCTCCG
</code></pre>
<p>Co prawda widać, że jest tu więcej pasujących par zasad, ale także znacznie więcej indeli. Policzmy więc punkty:</p>
<p>27 dopasowań - 32 ideli = -5 punktów</p>
<p>Z prostego liczenia punktów wynikałoby, że to drugie dopasowanie jest znacznie gorsze. Ale czy tak jest w rzeczywistości?
Przyjrzyjmy się środkowej części dopasowania. Widać tam wyraźne nagromadzenie pasujących do siebie nukleotydów. Widać, że ten fragment w obu sekwencjach jest mało zmienny. Odpowiada on fragmentowi konserwatywnemu w obu sekwencjach, który otoczony jest przez fragmenty zmienne. Biorąc pod uwagę sens dopasowania sekwencji, polegający na tym aby dopasowane nukleotydy były względem siebie homologiczne, to drugie dopasowanie jest właściwsze.</p>
<p>Powyższy problem związany jest z dwoma podstawowymi typami dopasowań: globalnym i lokalnym.</p>
<p>Algorytmy <strong>dopasowania globalnego</strong> służą tworzeniu przyrównania sekwencji na całej długości. Podobnie jak w pokazanym powyżej przykładzie algorytmu programowania dynamicznego, przy szukaniu optymalnej ścieżki w macierzy, poruszamy się od lewego dolnego rogu do prawego górnego. Dopasowanie globalne sprawdza się zatem dobrze gdy przyrównujemy sekwencje o zbliżonej liczbie nukleotydów, podobne (homologiczne) do siebie na całej długości. Przykładem algorytmu przyrównania globalnego jest <a href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm">algorytm Needlemana-Wunscha</a> opublikowany w 1970 roku.</p>
<p>Jak widać na powyższym przykładzie takie postępowanie nie zawsze się dobrze sprawdza. Na przykład kiedy przyrównujemy sekwencje, które są do siebie podobne tylko w niektórych fragmentach, albo gdy w długim odcinku DNA szukamy miejsca podobnego do danej, znacznie krótszej sekwencji znacznie lepiej sprawdza się <strong>dopasowanie lokalne</strong>. W tym przypadku priorytetem jest wyszukiwanie krótszych odcinków w obu sekwencjach, które są do siebie dobrze dopasowane.  Może natomiast prowadzić do uzyskania kilku dopasowań. Klasycznym przykładem algorytmu dopasowania lokalnego jest <a href="https://en.wikipedia.org/wiki/Smith%E2%80%93Waterman_algorithm">algorytm Smitha-Watermana</a> zaprezentowany w 1981 r. Bazuje on na algorytmie Needlemana-Wunscha ale różni się od niego sposobem punktacji przy wypełnianiu matrycy a także sposobem poszukiwania ścieżki powrotnej. Rozpoczyna się nie od końca tablicy, ale w miejscu o najwyższej punktacji i niekonieczne prowadzi do jej początku ale do miejsca gdzie kończy się lokalne dopasowanie.</p>
<a class="header" href="#dopasowanie-wielu-sekwencji" id="dopasowanie-wielu-sekwencji"><h2>Dopasowanie wielu sekwencji</h2></a>
<p>Dopasowanie wielu sekwencji jest zadaniem, co oczywiste, znacznie bardziej skomplikowanym niż powyżej rozpatrywane przyrównanie pary z nich. Istnieją różne algorytmy, które mają za zadanie ten proces usprawnić i możliwie ograniczyć czas niezbędny do obliczeń. Poniżej krótko charakteryzuję kilka z nich, należy jednak pamiętać, że w poszczególnych programach są one w różny sposób implementowane i modyfikowane.</p>
<ul>
<li><strong>Metoda progresywna</strong>: Sekwencje są porównywane parami (metodą programowania dynamicznego). Następnie na podstawie ich podobieństw tworzone jest drzewo filogenetyczne, zwane drzewem przewodnim lub naprowadzającym (ang. <em>guide tree</em>). Następnie z blisko spokrewnionych sekwencji tworzy się sekwencję konsensusową. Zawiera ona wspólne/najczęściej spotykane nukleotydy w kolejnych miejscach. Dopasowuje się do niej kolejną, pod względem podobieństwa sekwencję, lub sekwencję konsensusową z innej, pobliskiej filogenetycznie grupy sekwencji. Proces trwa aż zostaną przyrównane wszystkie sekwencje. Opiera się na przyrównywaniu globalnym.</li>
<li><strong>Przyrówanie iteracyjne</strong>: Jest to <a href="https://pl.wikipedia.org/wiki/Heurystyka_(informatyka)">metoda heurystyczna</a>, zatem nie dająca gwarancji uzyskania optymalnego wyniku. Opiera się na iteracyjnym (powtarzającym się) udoskonalaniu pierwotnego dopasowania. Przy każdej iteracji kolejność przyrównywanych sekwencji jest inna. Podobnie jak metoda progresywna opiera się na przyrównywaniu globalnym.</li>
<li><strong>Przyrówanie blokowe</strong>: W przeciwieństwie do dwóch powyższych metod opiera się na przyrównywaniu lokalnym. Polega na poszukiwaniu fragmentu sekwencji, która nie zawiera przerw i jest wspólna dla wszystkich sekwencji (blok).</li>
<li><strong>Metoda dziel i zwyciężaj (<em>divide and conquer</em>)</strong>: Metoda heurystyczna. Sekwencje są dzielone na krótkie odcinki, które są możliwie dokładnie dopasowywane, po czym są z nich z powrotem składane sekwencje wyjściowe. Istotnym krokiem jest znalezienie odpowiednich miejsc ,,cięcia'' sekwencji.</li>
</ul>
<p>Do znanych programów komputerowych służących dopasowywaniu wielu sekwencji należą: Clustal W, MAFFT, MUSCLE, T-Coffee czy nowszy PRANK. Ich bardziej kompletną listę można znaleźć np. na <a href="https://en.wikipedia.org/wiki/List_of_sequence_alignment_software">Wikipedii</a></p>
<a class="header" href="#ręczne-redagowanie-dopasowania" id="ręczne-redagowanie-dopasowania"><h2>Ręczne redagowanie dopasowania</h2></a>
<p>W zależności od stosowanych algorytmów (programów) oraz sekwencji na których pracują, wyniki dopasowania mogą być mniej lub bardziej optymalne. Zwłaszcza dotyczy do sytuacji gdy sekwencje są wysoce zmienne i zawierają liczne indele. Ludzki mózg w wielu przypadkach pozwala dostrzec pewne podobieństwa między sekwencjami, których nie potrafią zidentyfikować algorytmy. Dlatego przy dopasowywaniu sekwencji konieczne są zwykle poprawki nanoszone bezpośrednio przez badacza. Duże znaczenie ma tu nie tylko wiedza dotycząca mechanizmów ewolucji sekwencji ale także praktyczne doświadczenie.</p>
<p>Przydatne programy, które mogą ułatwić taką pracę to np. dostępne na główne systemy operacyjne (Linux, macOS, Windows) programy z interfejsem graficznym: <a href="http://www.ormbunkar.se/aliview/">AliView</a>, <a href="http://www.jalview.org/">JalView</a>, <a href="http://ugene.net/">UGENE</a> czy <a href="http://www.megasoftware.net/">MEGA</a>, która jednak posiada wersję z GUI tylko dla Windows i macOS. Posiadają one także możliwość uruchamiania zewnętrznych programów, m. in. dopasowujących sekwencje, co znacznie ułatwia cały proces.</p>
<a class="header" href="#modele-ewolucji-molekularnej" id="modele-ewolucji-molekularnej"><h1>Modele ewolucji molekularnej</h1></a>
<a class="header" href="#do-czego-służą-modele-ewolucji-molekularnej" id="do-czego-służą-modele-ewolucji-molekularnej"><h2>Do czego służą modele ewolucji molekularnej?</h2></a>
<p>Jeśli chcemy rozwikłać pokrewieństwa ewolucyjne między badanymi organizmami, co jest zasadniczym celem badań filogenetycznym, powinniśmy dysponować jakąś metodą oceny odległości ewolucyjnych między nimi. Organizmy o mniejszej odległości będą uważane za bliżej spokrewnione między sobą niż taksony bardziej od siebie oddalone. Najprostszym sposobem, który przychodzi do głowy jest proste porównanie sekwencji i wyliczenie w ilu miejscach się one różnią - im więcej różnic tym większa odległość ewolucyjna. Tak obliczoną odległość możemy określić jako <em>p</em> i wyrazić ją w procentach lub w proporcji, wtedy mieszczą się w wartościach między 0 a 1. Na przykład jeśli dwie sekwencje o długości 100 miejsc będą się różnić w 17 miejscach, to <em>p</em>=17% lub <em>p</em>=0,17.
Takie podejście co prawda pozwala ocenić różnice między sekwencjami ale niekoniecznie odzwierciedla rzeczywiste odległości ewolucyjne, zwłaszcza jeśli porównywane są sekwencje z dużą liczbą różnic. Niekoniecznie jest to intuicyjnie oczywiste ale wynika to ze sposobu w jaki zmieniają się nici DNA w czasie.</p>
<p>Rozważmy hipotetyczną ewolucję dwu sekwencji, przedstawioną na poniższym rysunku:</p>
<p><img src="pics-modele/ewolucja-dwu-sekwencji.png" alt="Ewolucja sekwencji" /></p>
<p>Początkowo wygląda ona tak <code>ATACCTGCATG</code>.</p>
<p>(1) - Dochodzi do specjacji, powstają dwa gatunki, sekwencje są na początku identyczne, ale dalej ewoluują niezależnie od siebie</p>
<p>(2) - W obu sekwencjach dochodzi do mutacji (C-&gt;A, A-T).</p>
<p>(3) - W lewej sekwencji ostatni nukleotyd mutuje (G-&gt;C).</p>
<p>(4) - W lewej sekwencji piąty nukleotyd, który już wcześniej mutował, ponownie zmienia się (A-&gt;T), w prawej sekwencji w drugiej pozycji także dochodzi do substytucji (T-&gt;G).</p>
<p>(5) - W prawej sekwencji doszło do substytucji (T-&gt;A).</p>
<p>(6) - W obu sekwencjach dochodzi do substytucji (T-&gt;G, C-&gt;A), zauważ, że w lewej mutacji doszło do zmiany analogicznej do tej, która wydarzyła się w sekwencji prawej w kroku 4.</p>
<p>W sumie w obu sekwencjach doszło do ośmiu substytucji. Dopasujmy teraz obie sekwencje do siebie:</p>
<p><img src="pics-modele/ewolucja-dwu-sekwencji-dopasowanie.png" alt="Porównanie sekwencji" /></p>
<p>Jak widać mutacje są widoczne w czterech pozycjach i sześciu nukleotydach z czego dwa mutowały dwukrotnie. Zaznaczmy teraz miejsca gdzie widoczne są różnice:</p>
<p><img src="pics-modele/ewolucja-dwu-sekwencji-roznice.png" alt="Porównanie sekwencji" /></p>
<p>Okazuje się, że sekwencje różnią się tylko w dwu miejscach, mimo że w sumie wydarzyło się w nich osiem mutacji. Powyższy przykład pokazuje mechanizm ,,ukrywania się'' mutacji. Porównując dwie sekwencje, jeśli widzimy różnicę między nukleotydami w danym miejscu, nie jesteśmy w stanie stwierdzić, czy jest ona wynikiem jednej czy wielu mutacji. Co więcej, następujące po sobie mutacje mogą najpierw sprawić, że nukleotydy będą się różnić a później, że będą takie same (choć niekoniecznie takie jak na początku). Im więcej czasu upływa i im więcej zachodzi mutacji w badanych sekwencjach, tym większy odsetek zmian zostaje ,,zatarty''. O ile możemy przyjąć, że liczba mutacji w czasie rośnie w sposób liniowy, to liczba obserwowanych różnic rośnie liniowo tylko na początku (dla małej liczby różnic) a później coraz wolniej, ponieważ coraz więcej zmian wydarza się w tych samych miejscach. Liczba różnic zmienia się, dla sekwencji o równych proporcjach rodzajów nukleotydów, do wartości 3/4 liczby nukleotydów, przy czym zmierza do tej granicy coraz wolniej. Trzeba też pamiętać o tym, że zasady prawdopodobieństwa wskazują, że dla dwu losowo wybranych sekwencji DNA o tej samej długości 1/4 miejsc powinna być zgodna.</p>
<p>[TODO: zrobić symulację mutacji i różnic między sekwencjami]</p>
<p>Jak widać, prosta metoda obliczania różnic między sekwencjami jest zawodna. Konieczne zatem okazało się stworzenie modeli, które w bardziej realistyczny sposób pozwalałyby oszacować odległości ewolucyjne.
Poniżej znajduje się opis kilku, najpopularniejszych o różnym stopniu skomplikowania.</p>
<!---
your comment goes here
and here
-->
<a class="header" href="#model-junkes-cantor-jc-jc69" id="model-junkes-cantor-jc-jc69"><h2>Model Junkes-Cantor (JC, JC69)</h2></a>
<p>Najprostszy model, nazwany od nazwisk autorów <strong>modelem Junkesa-Cantora</strong> (w skrócie <strong>JC</strong>, lub <strong>JC69</strong> uwzględniając rok publikacji: 1969) oparty jest na założeniu, że nukleotydy mogą ulegać podmianie każdy z każdym z takim samym prawdopodobieństwem. Można to przedstawić za pomocą macierzy:</p>
<table><thead><tr></tr></thead><tbody>
<tr><td align="center">     </td><td align="center">  T             </td><td align="center">  C             </td><td align="center">           A    </td><td align="center">           G    </td></tr>
<tr><td align="center">  T  </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$ \alpha $$   </td></tr>
<tr><td align="center">  C  </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$ \alpha $$   </td></tr>
<tr><td align="center">  A  </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha $$   </td></tr>
<tr><td align="center">  G  </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$     -    $$ </td></tr>
</tbody></table>
<p>Wartość $$ \alpha $$ oznacza prawdopodobieństwo zmiany jednego nukleotydu w drugi w określonej jednostce czasu na przykład na rok. Wynika z tego, że prawdopodobieństwo zmiany danego nukleotydu w jakikolwiek inny nukleotyd w danym okresie czasu wynosi:</p>
<p>$$ r=3\alpha $$</p>
<p>Z kolei odległość między dwoma sekwencjami po czasie $$ t $$ będzie wynosić:</p>
<p>$$ d=3\alpha t$$</p>
<p>Wartości, tu oznaczone znakiem <code>-</code>, na przekątnych wynoszą ujemną sumę wartości w rzędach. W powyższym przypadku będzie to  $$-3\alpha$$ a np. dla modelu
K80 (poniżej) jest to $$ -\alpha -2\beta $$ itd.</p>
<!--
Rozważmy teraz dwie sekwencje, które początkowo są identyczne ale później ewoluują niezależnie gromadząc różnice. Proporcję identycznych nukleotydów (w tych samych miejscach) w danym momencie oznaczmy jako $$ q_{t} $$. Proporcja miejsc z różnymi nukleotydami wyniesie zatem $$ p_{t}=1-q_{t} $$.
Skoro szansa, że dany nukleotyd zmutuje po upływie kolejnej jednostki czasu ($$ t+1 $$) wynosi $$ r^2 $$, zatem prawdopodobieństwo, że się nie zmieni równe jest: 
<p>$$ (1-r)^2 = 1^2 + 2r + r^2 $$</p>
<p>Ponieważ wartość $$ r $$ jest mała, można $$ r^2 $$ pominąć i uprościć wzór do postaci:</p>
<p>$$ 1-2r $$.</p>
<p>Jakie z kolei jest prawdopodobieństwo, że dwa różne nukleotydy (np. <code>A</code> i <code>T</code>) w obu sekwencjach staną się takie same? Może się to zdarzyć na dwa sposoby:</p>
<ol>
<li><code>A</code> zmienia się w <code>T</code> a <code>T</code> się nie zmienia</li>
<li><code>T</code> zmienia się w <code>A</code> a <code>A</code> się nie zmienia</li>
</ol>
<p>Ignorujemy tu możliwość, że oba nukleotydy mutują w taki sam trzeci nukleotyd. Szansa każdego z dwu przypadków jest taka sama i jest ona iloczynem dwu wydarzeń: zmiany jednego nukleotydu i braku tej zmiany w drugim. Możemy ją wyrazić wzorem: $$ \alpha (1-r) $$.</p>
<p>Ponieważ $$ r=3\alpha $$ to $$ \alpha (1-r) = \frac{r(1-r)}{3} $$.</p>
<p>Po dodaniu obu prawdopodobieństw otrzymujemy: $$ \frac{2r(1-r)}{3} = \frac{2r - 2r^2}{3} $$.</p>
<p>Jeśli zignorujemy $$ r^2 $$ wzór na ujednolicenie pozycji w obu sekwencjach wyniesie (w przybliżeniu): $$ \frac{2}{3}r $$</p>
<p>Wzór na udział takich samych nukleotydów w poszczególnych pozycjach obu sekwencji po upływie jednostki czasu powinien równać się sumie prawdopodobieństwa braku zmiany pomnożonej przez udział nukleotydów identycznych oraz prawdopodobieństwa ujednolicenia nukleotydów pomnożonych przez udział miejsc z różnymi nukleotydami:</p>
<p>$$ p_{t+1}=(1-2r)q_{t} + \frac{2}{3}r(1-q_{t}) $$</p>
<p>Przekształćmy to równanie tak, aby otrzymać wzór na zmianę wartości $$ q $$ w odcinku czasu:</p>
<p>$$ p_{t+1}=q_{t} - 2r q_{t} + \frac{2}{3}r - \frac{2}{3}rq_{t} $$</p>
<p>$$ p_{t+1}=q_{t} - \frac{6}{3}r q_{t} - \frac{2}{3}r q_{t} + \frac{2}{3}r  $$</p>
<p>$$ p_{t+1}=q_{t} - \frac{8}{3}r q_{t} + \frac{2}{3}r  $$</p>
<p>$$ p_{t+1} - q_{t} = \frac{2r}{3}- \frac{8r}{3}q_{t} $$</p>
<p>Otrzymany wzór możemy przekształcić w równanie różniczkowe:</p>
<p>$$ \frac{dq}{dt} = \frac{2r}{3} - \frac{8r}{3}q $$</p>
<p>Dla wartości początkowych <em>q</em> = 1 i <em>t</em>=0 rozwiązaniem tego równania będzie:</p>
<p>$$ q = 1 - \frac{3}{4}(1 - e^{\frac{-8rt}{3}}) $$</p>
<p>$$ 2rt $$ jest spodziewaną liczbą mutacji dla dwu sekwencji. Po oznaczeniu jej literą  $$d $$ i przekształceniu wzoru tak aby móc ją wyliczyć z wartości $$ p $$ otrzymamy równanie:</p>
<p>$$ d = -\frac{3}{4}ln (1 - \frac{4}{3} p) $$</p>
<p>Teraz można wzór zmodyfikować dla obserwowanej wartości $$ p $$ ($$ p = 1 -q $$), którą oznaczymy jako $$ \hat{p} $$ otrzymując wzór na spodziewany dystans między sekwencjami ($$ \hat{d} $$)</p>
<p>$$ \hat{d} = -\frac{3}{4}ln (1 - \frac{4}{3} \hat{p}) $$
--&gt;</p>
<a class="header" href="#model-kimura-k80" id="model-kimura-k80"><h2>Model Kimura (K80)</h2></a>
<p>Model Kimury zakłada, że prawdopodobieństwo wystąpienia tranzycji i transwersji jest różne. Tranzycje to zmiana puryny w inną purynę (<code>A</code> ↔ <code>G</code>) lub pirymidyny w pirymidynę (<code>T</code> ↔ <code>C</code>), transwersje polegają na zmianie puryny w pirymidynę lub odwrotnie (<code>A</code> ↔ <code>C</code>, <code>T</code> ↔ <code>G</code>, <code>A</code> ↔ <code>T</code>, <code>C</code> ↔ <code>G</code>).</p>
<p>Na poniższej ilustracji tranzycje zaznaczono zielonymi strzałkami a transwersje czerwonymi:</p>
<p><img src="pics-modele/substytucje.png" alt="Tranzycje i transwersje" /></p>
<p>Macierz prawdopodobieństw substytucji dla modelu Kimury wygląda następująco:</p>
<table><thead><tr></tr></thead><tbody>
<tr><td align="center">     </td><td align="center">  T             </td><td align="center">  C             </td><td align="center">           A    </td><td align="center">           G    </td></tr>
<tr><td align="center">  T  </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$ \beta $$    </td><td align="center"> $$ \beta $$    </td></tr>
<tr><td align="center">  C  </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \beta $$    </td><td align="center"> $$ \beta $$    </td></tr>
<tr><td align="center">  A  </td><td align="center"> $$ \beta $$    </td><td align="center"> $$ \beta $$    </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha $$   </td></tr>
<tr><td align="center">  G  </td><td align="center"> $$ \beta $$    </td><td align="center"> $$ \beta $$    </td><td align="center"> $$ \alpha $$   </td><td align="center"> $$     -    $$ </td></tr>
</tbody></table>
<p>Prawdopodobieństwo tranzycji oznaczono jako $$ \alpha $$ a transwersji literą $$ \beta $$</p>
<p>Ponieważ badania rzeczywistych częstości substytucji wskazują, że zwykle tranzycje są częstsze niż transwersje, $$ \alpha $$ przyjmuje zazwyczaj większą wartość niż $$ \beta $$.</p>
<p>W powyższym modelu spodziewana liczba tranzycji przypadających na miejsce w sekwencji wynosi $$ \alpha t $$, natomiast transwersji równe jest  $$ 2\beta $$, toteż dystans miedzy sekwencjami po czasie $$ t $$ wyniesie $$ d=(\alpha + 2\beta)t $$.</p>
<a class="header" href="#model-felenstein-f81" id="model-felenstein-f81"><h2>Model Felenstein (F81)</h2></a>
<p>Ten model jest rozwinięciem modelu JC, uwzględnia jednak fakt, że w realnie występujących sekwencjach poszczególne rodzaje nukleotydów występują w różnych częstościach, które oznaczymy tu jako: $$ \pi_{T} $$, $$ \pi_{C} $$, $$ \pi_{A} $$ oraz $$ \pi_{G} $$, prawdopodobieństwo zmian pozostaje stałe:</p>
<table><thead><tr></tr></thead><tbody>
<tr><td align="center">     </td><td align="center">  T             </td><td align="center">  C             </td><td align="center">           A    </td><td align="center">           G    </td></tr>
<tr><td align="center">  T  </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha\pi_{C} $$   </td><td align="center"> $$ \alpha\pi_{A} $$    </td><td align="center"> $$ \alpha\pi_{G} $$    </td></tr>
<tr><td align="center">  C  </td><td align="center"> $$ \alpha\pi_{T} $$   </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha\pi_{A} $$    </td><td align="center"> $$ \alpha\pi_{G} $$    </td></tr>
<tr><td align="center">  A  </td><td align="center"> $$ \alpha\pi_{T} $$    </td><td align="center"> $$ \alpha\pi_{C} $$    </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha\pi_{G} $$   </td></tr>
<tr><td align="center">  G  </td><td align="center"> $$ \alpha\pi_{T} $$    </td><td align="center"> $$ \alpha\pi_{C} $$    </td><td align="center"> $$ \alpha\pi_{A} $$   </td><td align="center"> $$     -    $$ </td></tr>
</tbody></table>
<a class="header" href="#model-hasegawa-kishino-i-yano-hky-hky85" id="model-hasegawa-kishino-i-yano-hky-hky85"><h2>Model Hasegawa, Kishino i Yano (HKY, HKY85)</h2></a>
<p>Kolejny model z przedstawionych, uwzględnia zarówno różnice występowania poszczególnych rodzajów nukleotydów jak i różnice prawdopodobieństw tranzycji i transwersji:</p>
<table><thead><tr></tr></thead><tbody>
<tr><td align="center">     </td><td align="center">  T             </td><td align="center">  C             </td><td align="center">           A    </td><td align="center">           G    </td></tr>
<tr><td align="center">  T  </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha\pi_{C} $$   </td><td align="center"> $$ \beta\pi_{A} $$    </td><td align="center"> $$ \beta\pi_{G} $$    </td></tr>
<tr><td align="center">  C  </td><td align="center"> $$ \alpha\pi_{T} $$   </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \beta\pi_{A} $$    </td><td align="center"> $$ \beta\pi_{G} $$    </td></tr>
<tr><td align="center">  A  </td><td align="center"> $$ \beta\pi_{T} $$    </td><td align="center"> $$ \beta\pi_{C} $$    </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha\pi_{G} $$   </td></tr>
<tr><td align="center">  G  </td><td align="center"> $$ \beta\pi_{T} $$    </td><td align="center"> $$ \beta\pi_{C} $$    </td><td align="center"> $$ \alpha\pi_{A} $$   </td><td align="center"> $$     -    $$ </td></tr>
</tbody></table>
<a class="header" href="#model-tamura-i-nei-tn93" id="model-tamura-i-nei-tn93"><h2>Model Tamura i Nei (TN93)</h2></a>
<p>Model TN93 jest podobny do modelu HKY ale rozróżnia częstość występowania tranzycji <code>T</code> ↔ <code>C</code> oraz <code>A</code> ↔ <code>G</code>.</p>
<table><thead><tr></tr></thead><tbody>
<tr><td align="center">     </td><td align="center">  T             </td><td align="center">  C             </td><td align="center">           A    </td><td align="center">           G    </td></tr>
<tr><td align="center">  T  </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha_{1}\pi_{C} $$   </td><td align="center"> $$ \beta\pi_{A} $$    </td><td align="center"> $$ \beta\pi_{G} $$    </td></tr>
<tr><td align="center">  C  </td><td align="center"> $$ \alpha_{1}\pi_{T} $$   </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \beta\pi_{A} $$    </td><td align="center"> $$ \beta\pi_{G} $$    </td></tr>
<tr><td align="center">  A  </td><td align="center"> $$ \beta\pi_{T} $$    </td><td align="center"> $$ \beta\pi_{C} $$    </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha_{2}\pi_{G} $$   </td></tr>
<tr><td align="center">  G  </td><td align="center"> $$ \beta\pi_{T} $$    </td><td align="center"> $$ \beta\pi_{C} $$    </td><td align="center"> $$ \alpha_{2}\pi_{A} $$   </td><td align="center"> $$     -    $$ </td></tr>
</tbody></table>
<a class="header" href="#model-general-time-reversible-gtr" id="model-general-time-reversible-gtr"><h2>Model <em>General Time Reversible</em> (GTR)</h2></a>
<p>Nazwa tego modelu wskazuje, że ma on charakter ogólny i zakłada odwracalność (substytucji) w czasie. Odwracalność w tym przypadku oznacza, że substytucje dla danej pary nukleotydów wydarzają się z takim samym prawdopodobieństwem w obie strony. A więc np. szansa, że <code>A</code> zmieni się w <code>T</code> jest taka sama jak mutacja <code>T</code> w <code>A</code>. Natomiast ogólność oznacza, że model uwzględnia indywidualne wartości frekwencji poszczególnych nukleotydów a także prawdopodobieństw mutacji pomiędzy parami zasad. Macierz dla modelu GTR wygląda zatem tak:</p>
<table><thead><tr></tr></thead><tbody>
<tr><td align="center">     </td><td align="center">  T             </td><td align="center">  C             </td><td align="center">           A    </td><td align="center">           G    </td></tr>
<tr><td align="center">  T  </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \alpha\pi_{C} $$   </td><td align="center"> $$ \beta\pi_{A} $$    </td><td align="center"> $$ \gamma\pi_{G} $$    </td></tr>
<tr><td align="center">  C  </td><td align="center"> $$ \alpha\pi_{T} $$   </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \delta\pi_{A} $$    </td><td align="center"> $$ \epsilon\pi_{G} $$    </td></tr>
<tr><td align="center">  A  </td><td align="center"> $$ \beta\pi_{T} $$    </td><td align="center"> $$ \delta\pi_{C} $$    </td><td align="center"> $$     -    $$ </td><td align="center"> $$ \eta\pi_{G} $$   </td></tr>
<tr><td align="center">  G  </td><td align="center"> $$ \gamma\pi_{T} $$    </td><td align="center"> $$ \epsilon\pi_{C} $$    </td><td align="center"> $$ \eta\pi_{A} $$   </td><td align="center"> $$     -    $$ </td></tr>
</tbody></table>
<p>Można powiedzieć, że model GTR jest najbardziej uniwersalny z przedstawionych i pozwala na opis ewolucji najbardziej zbliżony do rzeczywistego.</p>
<a class="header" href="#zróżnicowane-tempo-substytucji-w-różnych-odcinkach-sekwencji-g-gamma----gamma--oraz-i" id="zróżnicowane-tempo-substytucji-w-różnych-odcinkach-sekwencji-g-gamma----gamma--oraz-i"><h2>Zróżnicowane tempo substytucji w różnych odcinkach sekwencji (G (gamma - $$ \Gamma $$) oraz I)</h2></a>
<p>Większość z powyższych modeli pozwala zróżnicować tempo ewolucji w poszczególnych miejscach sekwencji DNA ze względu na rodzaj substytucji ale nie uwzględnia ich położenia. W rzeczywistości badana sekwencja, zwłaszcza jeśli zawiera kodujące obszary, może ewoluować z różną szybkością w poszczególnych odcinkach. Może to wynikać z tego, że mutacje zdarzają się z różną częstotliwością w różnych odcinkach DNA ale także z działania doboru naturalnego. Mutacje, które wydarzą się w miejscach kodujących kluczowe fragmenty białka, często powodują jego inaktywację lub nieprawidłowe funkcjonowanie, w związku z czym nosiciele takich mutacji giną lub zostawiają mniej potomstwa niż konkurenci. W konsekwencji mutacje w tych miejscach zostają usunięte z populacji i nie pozostawiają śladów w DNA następnych pokoleń. Tak więc, porównując homologiczne sekwencje różnych organizmów, zazwyczaj stwierdzimy, że niektóre odcinki będą bardziej zmienne, inne mniej.</p>
<p>Co więcej, może się okazać, że w badanych sekwencjach niektóre pozycje w ogóle nie będą wykazywały zmienności. Można to zauważyć na poniższej ilustracji pokazującej fragment sekwencji mitochondrialnego genu <em>atp6</em> badanych gatunków roślin.</p>
<p><img src="pics-modele/zmiennosc.png" alt="Zmienne tempo ewolucji" /></p>
<p>Zwłaszcza dotyczy to sekwencji kodujących, co wynika z właściwości kodu genetycznego. Jak wiadomo, zmiany w kodonach na 1, 2 i 3 miejscu mają różny wpływ na ich znaczenie. Na przykład prolinę kodują cztery kodony różniące się w trzeciej pozycji. Zatem każda zmiana 1 i 2 pozycji kodonu powoduje zmianę jego znaczenia, natomiast żadna zmiana na ostatnim miejscu nie ma na niego wpływu. Jeśli zatem od obecności proliny w konkretnym miejscu zależy prawidłowe działanie jakiegoś kluczowego dla organizmu białka, możemy się spodziewać, że w kodującym ją kodonie na 1 i 2 miejscu nie znajdziemy zmienności, natomiast może być ona widoczna na 3 miejscu.</p>
<p>Uwzględnienie powyższych zjawisk pozwala na bardziej realistyczne oszacowanie odległości ewolucyjnych. Jeśli w badanych sekwencjach występują fragmenty o zróżnicowanym tempie zmian lub w ogóle nie ewoluujące i nie uwzględnimy tego w obliczeniach, otrzymamy niedoszacowane wartości odległości ewolucyjnych. Jest ono tym większe, im większe są odległości. Dlatego w analizach filogenetycznch oprócz dobrania odpowiedniego modelu substytucji, uwzględnia się także rozkład gamma (G, $$ \Gamma $$) pozwalający uwzględnić zmienne tempo ewolucji oraz parametr I opisujący udział miejsc niezmiennych. O ile oczywiście badane sekwencje tego wymagają. Jeśli w publikacji znajdziemy opis stosowanego modelu, który będzie wyglądał np. tak: <code>GTR+G+I</code> albo: <code>GTR+InvGamma</code> będzie to oznaczało, że zastosowano model <code>GTR</code> z uwzględnieniem zmiennego tempa ewolucji w sekwencji oraz miejsc niezmiennych.</p>
<a class="header" href="#rozkład-gamma-g--gamma-" id="rozkład-gamma-g--gamma-"><h3>Rozkład gamma (G, $$ \Gamma $$)</h3></a>
<p>Parametr gamma oznaczany łacińską literą G lub grecką $$ \Gamma $$ pozwala uwzględnić zmienne tempo ewolucji w różnych fragmentach badanych nici DNA. Stosuje się w tym celu rozkład gamma opisany wzorem:</p>
<p>$$ f(r,a) = const \cdot r^{\alpha - 1} e^{-\alpha r} $$</p>
<p>Gdzie $$ r $$ - tempo podstawień względem średniego dla całej sekwencji, $$ \alpha $$ - parametr określający kształt krzywej (rozkładu).</p>
<p>Poniższa ilustracja pokazuje kilka wykresów rozkładu gamma dla różnych wartości $$ \alpha $$.</p>
<p><img src="pics-modele/wartosci-alfa-gamma.png" alt="Rozkład gamma" /></p>
<p>Można na nim zauważyć jaki wpływ mają jej różne wartości na kształt krzywej a co za tym idzie na charakterystkę zmienności ewolucyjnej różnych pozycji w sekwencji DNA:</p>
<p>$$ \alpha $$ &lt; 1 - wartości rozkładu są tym większe im znajdują się bliżej $$ r $$ = 0, co wskazuje na duży udział pozycji mało zmiennych i niezmiennych</p>
<p>$$ \alpha $$ = 1 - krzywa równoważna wykładniczej</p>
<p>$$ \alpha $$ &gt; 1 - wykresy przyjmują kształt ,,dzwonowaty''- widać maksimum które wraz z rosnącymi wartościami $$ \alpha $$, znajduje coraz bliżej  $$ r $$ = 1, przyjmuje coraz wyższe wartości a także ,,pik'' się zwęża. Oznacza to, że wysokie wartości $$ \alpha $$ wskazują na bardzo małe zróżnicowanie tempa ewolucji dla różnych pozycji sekwencji.</p>
<p>Co prawda nie ma biologicznego powodu dla którego zmienność tempa ewolucji miałaby akurat pasować do rozkładu gamma, jednak jego zastosowanie pozwala na wygodne, bo wymagające sprecyzowania jednego parametru ($$ \alpha $$), przybliżenie rzeczywistości.</p>
<a class="header" href="#parametr-i-invariable-sites" id="parametr-i-invariable-sites"><h3>Parametr I (Invariable sites)</h3></a>
<p>Jak sama nazwa wskazuje, parametr I określa udział miejsc, które nie wykazują zmienności. Należy przy tym pamiętać, że niekoniecznie rzeczywiście nie podlegają one ewolucji. Jeśli będziemy badać taksony blisko ze sobą spokrewnione a dane miejsce w sekwencji DNA ewoluuje powoli, to może nie wykazywać zmienności, ponieważ ,,nie zdążyło'' jeszcze zmutować.</p>
<a class="header" href="#drzewa-filogenetyczne" id="drzewa-filogenetyczne"><h1>Drzewa filogenetyczne</h1></a>
<a class="header" href="#odległości-ewolucyjne-i-macierze-odległości" id="odległości-ewolucyjne-i-macierze-odległości"><h2>Odległości ewolucyjne i macierze odległości</h2></a>
<p>Dla dopasowanych sekwencji można wyliczyć macierze zawierające odległości pomiędzy wszystkimi badanymi sekwencjami. W najprostszym przypadku mogą to być liczby różnic pomiędzy nimi:</p>
<pre><code>      A      B      C      D      E      F      G      H      I      
A	
B    112      
C    105     33      
D    102     38     9      
E    99      30     18     21      
F    97      31     19     20     9      
G    96      41     30     35     27     25      
H    96      126    116    113    113    113    108      
I    121     138    134    128    132    135    130    39      
</code></pre>
<p>Można też je przedstawić w formie różnic przypadających na jedną zasadę:</p>
<pre><code>    A       B       C       D       E       F       G       H      I      
A	
B   0,141   
C   0,133   0,039   
D   0,129   0,045   0,011   
E   0,126   0,036   0,021   0,025   
F   0,124   0,037   0,022   0,024   0,011   
G   0,119   0,049   0,036   0,042   0,033   0,030   
H   0,160   0,203   0,188   0,183   0,183   0,183   0,177   
I   0,182   0,208   0,202   0,193   0,199   0,202   0,193   0,068   

</code></pre>
<p>Bardziej realistyczne macierze odzwierciedlające odległości ewolucyjne uwzględniają modele ewolucyjne. Na przykład macierz odległości liczona z użyciem modelu JC (Jukes-Cantor) może wyglądać tak:</p>
<pre><code>    A       B       C       D       E       F       G       H       I       
A
B   0,157   
C   0,147   0,040	
D   0,142   0,046   0,011	
E   0,138   0,037   0,022   0,025	
F   0,135   0,038   0,023   0,024   0,011	
G   0,129   0,051   0,037   0,043   0,033   0,031   
H   0,180   0,237   0,216   0,210   0,210   0,209   0,202   
I   0,208   0,244   0,236   0,224   0,232   0,236   0,223   0,071   
    
</code></pre>
<p>Obliczanie macierzy odległości ewolucyjnych jest kluczowym krokiem przy konstruowaniu drzew filogenetycznych.</p>
<a class="header" href="#struktura-drzewa-filogenetycznego" id="struktura-drzewa-filogenetycznego"><h2>Struktura drzewa filogenetycznego</h2></a>
<p>Zanim przejdziemy do algorytmów wykorzystywanych przy konstruowaniu drzew filogenetycznych, zwanych też <strong>dendrogramami</strong>, przyjrzyjmy się pokrótce ich podstawowym formom i strukturze.</p>
<p>Drzewa filogenetyczne najczęściej przedstawiane są w dwu formach: Ukośnej i prostokątnej.</p>
<p><img src="pics-drzewa/drzewo-formy.png" alt="Formy drzewa filogenetycznego" /></p>
<p>Podstawowe elementy drzewa filogenetycznego to: liście, gałęzie i węzły.</p>
<p><img src="pics-drzewa/drzewo-struktura.png" alt="Struktura drzewa filogenetycznego" /></p>
<ul>
<li><strong>Gałęzie</strong> pokazują związki pomiędzy nimi. Ich długość może (w zależności od rodzaju drzewa) odpowiadać zmianom w sekwencjach nagromadzonych podczas ewolucji. Można wyróżnić gałęzie wewnętrzne prowadzące do węzłów i gałęzie zewnętrzne zakończone liśćmi.</li>
<li><strong>Węzły</strong> to miejsca łączenia się gałęzi - reprezentują jednostki taksonomiczne (gatunki, osobniki, odmiany itd.). Węzły wewnętrzne (nie będące liśćmi) reprezentują hipotetycznego wspólnego przodka kladu (zob. niżej)</li>
<li><strong>Liście</strong> są końcowymi (terminalnymi) węzłami, odpowiadają badanym sekwencjom/taksonom</li>
</ul>
<p>Grupa taksonów pochodzących od wspólnego przodka nazywana jest <strong>kladem</strong>. Niekoniecznie poszczególne klady wyróżnia się wizualnie na drzewie, ale jest to termin stosowany w opisie zależności filogenetycznych.</p>
<p>Wzorzec rozgałęzienia drzewa nazywany jest <strong>topologią drzewa</strong>. Drzewa o takiej samej topologii mogą mieć inną reprezentację graficzną, wynikającą np. z obracania gałęzi względem węzła. Przykładowo poniższe dwa drzewa mają taką samą topologię mimo innego wyglądu:</p>
<p><img src="pics-drzewa/topologie.png" alt="Drzewa o takiej samej topologii" /></p>
<p><strong>Drzewa nieukorzenione</strong> przedstawiają wzajemne podobieństwa ale nie pozwalają określić w jakiej kolejności poszczególne taksony się od siebie oddzielały. <strong>Drzewa ukorzenione</strong> posiadają węzeł, który odpowiada ostatniemu wspólnemu przodkowi badanych taksonów. Często wyznacza się go (jest to tzw. ,,ukorzenianie drzewa'') wskazując na <strong>grupę zewnętrzną</strong>, zwaną także <strong>outgrupą</strong> (ang. <em>outgroup</em>). Jest to takson (lub grupa taksonów), który jest dalej spokrewniony z pozostałymi badanymi, niż one między sobą. Innymi słowy, oddzielił się on najwcześniej podczas ewolucji. Przykładowo, gdybyśmy badali genetycznie gatunki <em>Homo</em>, grupą zewnętrzną mógłby być szympans.</p>
<p>Ukorzenianie drzewa pozwala ustalić kolejność oddzielania się poszczególnych kladów i liści w toku ewolucji. Grupa zewnętrzna może być wyznaczona przez niektóre algorytmy budujące drzewo ale nie zawsze jest ona zgodna z rzeczywistym przebiegiem ewolucji. Dlatego, jeśli zależy nam na prawidłowym ukorzenieniu drzewa należy do zestawu badanych sekwencji dodać także należącą do taksonu o którym z góry wiemy, że jest outgrupą. Później, gdy otrzymamy drzewo nieukorzenione, lub ukorzenione niewłaściwie, wskazujemy w odpowiednim programie grupę zewnętrzną, dzięki czemu możemy drzewo prawidłowo ukorzenić.</p>
<p>Jeśli nie mamy określonej outgrupy ale wiemy, gdzie na drzewie powinien znajdować się wspólny przodek, można ukorzenić drzew wskazując to miejsce. Na przykład jeśli drzewo zawiera sekwencje grzybów i roślin, wiemy że wspólny przodek powinien znajdować się pomiędzy tymi dwoma kladami. Ukorzeniamy zatem drzewo tam, gdzie rozdzielają się te dwie grupy organizmów.</p>
<p><img src="pics-drzewa/drzewo-ukorzenianie.png" alt="Drzewo nieukorzenione i ukorzenione" /></p>
<p>Jak wcześniej wspomniałem, długość gałęzi drzewa może odzwierciedlać odległość ewolucyjną badanych sekwencji, wtedy drzewo nazywamy <strong>filogramem</strong>. <strong>Kladogram</strong> natomiast pokazuje jedynie pokrewieństwa między badanymi taksonami. Wizualnie można go poznać po tym, że wszystkie gałęzie kończą się wzdłuż jednej linii (pionowej lub poziomej).</p>
<p><img src="pics-drzewa/drzewo-filogram-kladogram.png" alt="Filogram i kladogram" /></p>
<p>Niektóre metody konstruowania drzew generują nie jedno, ale wiele drzew o takiej samej, lub podobnej jakości (prawdopodobieństwie). Zwykle w takich przypadkach tworzy się <strong>drzewo konsensusowe</strong> (uzgodnione). Jest to drzewo, które powinno odzwierciedlać wspólne cechy grupy drzew, które służą do jego tworzenia.  Do konstrukcji takiego drzewa można podejść w różny sposób. Pierwszy z nich zakłada, że rozgałęzienia dychotomiczne na drzewie konsensusowym pojawiają się wtedy, gdy znajdują się na wszystkich wyjściowych drzewach, w innym wypadku tworzone są wielokrotne rozgałęzienia. Nieco mniej rygorystyczne podejście polega na przyjęciu pewnego progu - np. jeśli dane dychotomiczne rozgałęzienie pojawi się u przynajmniej 50% drzew to jest ono umieszczane na drzewie konsensusowym..</p>
<a class="header" href="#konstruowanie-drzew" id="konstruowanie-drzew"><h2>Konstruowanie drzew</h2></a>
<p>Konstruowanie drzew polega na znalezieniu, na podstawie podobieństw i różnic sekwencji nukleotydów, aminokwasów czy innych cech, najbardziej prawdopodobnych pokrewieństw badanych organizmów, a także  kolejności wyodrębniania się w toku ewolucji poszczególnych taksonów.  Znanych jest szereg algorytmów wykorzystywanych w tym celu. Poniżej znajduje się krótka charakterystyka kilku z nich.</p>
<a class="header" href="#upgma-unweighted-pair-group-method-using-arithmetic-averages" id="upgma-unweighted-pair-group-method-using-arithmetic-averages"><h3>UPGMA (Unweighted Pair-Group Method using arithmetic Averages)</h3></a>
<p>Najpierw obliczana jest macierz odległości ewolucyjnych między badanymi sekwencjami. Następnie wybierane są dwie sekwencje o najmniejszej odległości od siebie i tworzony jest między nimi węzeł a obie sekwencje traktuje się jako nową jednostkę (klaster) dla której oblicza się odległości do wszystkich pozostałych sekwencji. Najbliższą sekwencję znów łączy się z poprzednio wydzielonym klastrem i w ten sposób postępuje się aż wszystkie badane taksony zostaną połączone w drzewo. Ostatnią przyłączoną do drzewa sekwencję traktuje się jako grupę zewnętrzną.</p>
<!--
  * Metoda minimalnej ewolucji (ME - Minimum Evolution)
-->
<a class="header" href="#metoda-najbliższego-sąsiada-nj---neighbor-joining" id="metoda-najbliższego-sąsiada-nj---neighbor-joining"><h3>Metoda najbliższego sąsiada (NJ - Neighbor Joining)</h3></a>
<p>Metoda polega na znalezieniu drzewa, które ma najmniejszą sumaryczną długość.</p>
<p>Najpierw obliczana jest macierz odległości między sekwencjami. Następnie obliczane są wartości $$ Q  $$ dla każdej pary sekwencji.</p>
<p>Wartość $$ Q  $$ wynosi:</p>
<p>$$ Q(i,j)=(n-2)d(i,j)-\sum_{k=1}^n d(i,k) - \sum_{k=1}^n d(j,k)  $$</p>
<p>Gdzie $$ n  $$ jest liczbą sekwencji, $$ d(i,j)  $$ jest odległością pomiędzy sekwencjami $$ i  $$ oraz $$ j  $$.</p>
<p>Zostaje też utworzone początkowe ,,drzewo'', w którym wszystkie sekwencje połączone są z jednym węzłem - ma więc formę gwiazdy.</p>
<p>W kolejnym kroku znajdywane są sekwencje pomiędzy którymi wartość $$ Q  $$ jest najmniejsza. Zostaje utworzony między nimi nowy węzeł (ancestralny) odpowiadający hipotetycznemu przodkowi. Obliczane są odległości pomiędzy połączonymi liśćmi a węzłem ancestralnym a także pomiędzy nim a pozostałymi sekwencjami.</p>
<p>Znów poszukiwane są sekwencje o najmniejszych odległościach i łączone ze sobą. Operacje są powtarzane aż do utworzenia drzewa o najmniejszej długości. Nie jest ono ukorzenione.</p>
<a class="header" href="#metoda-największej-oszczędności-mp---maximum-parsimony" id="metoda-największej-oszczędności-mp---maximum-parsimony"><h3>Metoda największej oszczędności (MP - Maximum Parsimony)</h3></a>
<p>W metodzie największej oszczędności poszukiwane jest drzewo, którego powstanie wymagałoby najmniejszej liczby zmian w sekwencjach (brzytwa Ockhama). Czyli poszukiwane jest jak najkrótsze drzewo, które wyjaśniałoby różnice między badanymi sekwencjami.</p>
<!---
Według zasady MP, jeśli np. w danym miejscu `A` występuje w taksonach A i B, natomiast `T` znajdujemy u C i D to przyjmuje się, że A i B są ze sobą bliżej spokrewnione niż z C i D, które mają swojego wspólnego przodka.
-->
Metoda ta ma także także zastosowanie w budowaniu drzew na postawie cech morfologicznych, które można przedstawić jako 1 (obecna) i 0 (nieobecna).
<p>Poszczególne kolumny w dopasowanych sekwencjach odpowiadają stanowi danej cechy. Przyjmuje się, że jeżeli w danej kolumnie występują przynajmniej dwa rodzaje nukleotydów (lub innych stanów) a każdy z nich jest obecny co najmniej dwa razy to niesie ona przydatną dla analizy informację, czyli  jest <strong>informatywna</strong>. W innym przypadku uznaje się ją za <strong>nieinformatywną</strong> i nie jest brana pod uwagę w dalszych analizach. Po zebraniu informatywnych kolumn analizuje się drzewa pod kątem znalezienia takiego, którego utworzenie można wyjaśnić zakładając jak najmniejszą liczbę zmian (mutacji).</p>
<p>W przeciwieństwie do poprzednio omawianych algorytmów, w tym przypadku drzewo jest nie tyle generowane co raczej wyszukiwane spośród wszystkich możliwych drzew dla danego zestawu danych. Jeśli liczba badanych sekwencji jest niewielka, można utworzyć wszystkie możliwe drzewa i obliczyć ich parametry. Dla dużych zestawów sekwencji, liczba kombinacji rośnie drastycznie, toteż wykorzystuje się różne metody heurystyczne pozwalające ograniczyć wymagane obliczenia.</p>
<a class="header" href="#metoda-największej-wiarygodności-ml---maximum-likelihood" id="metoda-największej-wiarygodności-ml---maximum-likelihood"><h3>Metoda największej wiarygodności (ML - Maximum Likelihood)</h3></a>
<p>Celem metody największej wiarygodności jest znalezienie najbardziej prawdopodobnego drzewa - czyli takiego, które jest najbardziej prawdopodobne dla danego zestawu sekwencji, przy uwzględnieniu przyjętego modelu ewolucji molekularnej. Podobnie jak w przypadku metody MP, generowanych jest wiele drzew z pośród których, szuka się tego, które najlepiej spełnia przyjęte założenia.</p>
<p>Ocena drzewa polega w skrócie na tym, że oblicza się dla niego prawdopodobieństwa wystąpienia danego zestawu nukleotydów dla kolejnych kolumn a następnie mnoży się je (albo po transformacji logarytmicznej sumuje) uzyskując prawdopodobieństwo dla całego drzewa. Drzewo, dla którego jest ono największe, jest uznane za drzewo o największej wiarygodności.</p>
<p>Metoda ta jest dość wymagająca pod względem obliczeniowym, zwłaszcza, że uwzględnia model ewolucji molekularnej. W związku z szybkim rozwojem technologii komputerowych, ta wada jest jednak z czasem coraz mniej istotna. Uwzględnianie modeli ewolucji, jest dodatkowym elementem pozwalającym na zwiększenie wiarygodności otrzymanych drzew, należy przy tym pamiętać, że przyjęcie różnych modeli może skutkować otrzymaniem różnych wyników.</p>
<a class="header" href="#metody-bayesowskie-bayesian-methods" id="metody-bayesowskie-bayesian-methods"><h3>Metody bayesowskie (Bayesian Methods)</h3></a>
<p>Kluczowym elementem metod bayesowskich jest liczenie prawdopodobieństwa <em>a posteriori</em>, uwzględniającego posiadane dane. Dla dwóch różnych wydarzeń dla których szukamy związku można przedstawić je wzorem:</p>
<p>$$  P(B|A)={\frac {P(A|B)P(B)}{P(A|B)P(B)+P(A|B')P(B')}}={\frac {P(A|B)P(B)}{P(A)}}  $$</p>
<p>Gdzie:</p>
<ul>
<li>$$ A  $$ i $$ B  $$ - dwa różne wydarzenia</li>
<li>$$ B'  $$ - wydarzenie alternatywne względem $$ B  $$</li>
<li>$$ P(B|A)  $$ - liczone prawdopodobieństwo <em>a posteriori</em> wydarzenia $$ B  $$ jeśli się wydarzy $$ A  $$.</li>
<li>$$ P(A|B)  $$ - prawdopodobieństwo warunkowe wydarzenia $$ A  $$ jeśli  $$ B  $$</li>
<li>$$ P(B)  $$ - prawdopodobieństwo <em>a priori</em> wydarzenia  $$ B  $$</li>
<li>$$ P(B')  $$ - prawdopodobieństwo wydarzenia alternatywnego względem  $$ B  $$</li>
</ul>
<p>Zobaczmy jak to działa na przykładzie.</p>
<p>Przypuśćmy, że badamy pacjenta na obecność wirusa. Test dał wynik pozytywny ale chcemy policzyć z jakim prawdopodobieństwem pacjent jest rzeczywiście zakażony. Używamy testu, który w przypadku obecności wirusa daje wynik pozytywny w 99%, natomiast u zdrowych ludzi daje (prawidłowy) wynik negatywny w 95% (czyli dla 5% mimo braku patogenu, da wynik fałszywy pozytywny). Wiemy też, że w badanej populacji odsetek osób zakażonych wynosi 2%.</p>
<ul>
<li>$$ B  $$ - pacjent jest naprawdę zakażony</li>
<li>$$ B'  $$ - pacjent nie jest zakażony</li>
<li>$$ A  $$ - test dał wynik pozytywny</li>
<li>$$ P(B)  $$ - prawdopodobieństwo, że losowy człowiek jest zakażony wirusem = 0,02</li>
<li>$$ P(B')  $$ - prawdopodobieństwo, że losowy człowiek nie jest zakażony wirusem = 0,98</li>
<li>$$ P(B|A)  $$ - liczone przez nas prawdopodobieństwo, że pacjent jest chory jeśli test dał wynik pozytywny</li>
<li>$$ P(A|B)  $$ - prawdopodobieństwo, że test dał wynik pozytywny, jeśli pacjent jest zakażony = 0,99</li>
<li>$$ P(A|B')  $$ - prawdopodobieństwo, że test dał wynik pozytywny, jeśli pacjent nie jest zakażony = 0,05</li>
</ul>
<p>Postawmy teraz dane do wzoru:</p>
<p>$$ P(B|A)={\frac {P(A|B)P(B)}{P(A|B)P(B)+P(A|B')P(B')} }= {\frac {0,99 \cdot 0,02}{0,99 \cdot 0,02 + 0,05 \cdot 0,98} } = {\frac {0,0198}{0,0198 + 0,049}} = 0,289 $$</p>
<p>Czyli wbrew temu co może nam podpowiadać intuicja, nawet jeśli w opisanej sytuacji test wyszedł pozytywnie, istnieje mniej niż 30% szans, że pacjent jest naprawdę zakażony.</p>
<p>Metody bayesowskie zdobyły w ostatnich latach dużą popularność jako stosunkowo szybkie i dające wiarygodne wyniki. Polegają na wyszukiwaniu najbardziej prawdopodobnych drzew dla danego zestawu sekwencji. Proces ten przebiega cyklicznie wg. schematu: Zostaje wybrane drzewo, liczone jest dla niego prawdopodobieństwo. Drzewo jest modyfikowane pod względem topologii lub długości gałęzi i liczone jest dla niego prawdopodobieństwo. Jeśli jest ono wyższe niż poprzednio, kolejny cykl zaczyna się od niego. W końcu zostaje znaleziona grupa drzew o najwyższym prawdopodobieństwie, dla których tworzone jest drzewo konsensusowe. W filogenetycznych badaniach bayesowskich przy obliczaniu prawdopodobieństw <em>a posteriori</em> wykorzystuje się dane dotyczące topologii drzewa, długości gałęzi i modelu ewolucji molekularnej. Tak naprawdę, poszukiwanie optymalnych drzew przebiega jednocześnie wieloma ,,ścieżkami'', które od czasu do czasu wymieniają się danymi. Pozwala to uniknąć pułapki lokalnego optymalnego drzewa.</p>
<a class="header" href="#szacowanie-wiarygodności" id="szacowanie-wiarygodności"><h2>Szacowanie wiarygodności</h2></a>
<p>Konstruowaniu drzew towarzyszy zazwyczaj szacowanie ich wiarygodności. W większości przypadków stosuje się tu metodę <strong>bootstrap</strong> (samopróbkowania) a dla metod bayesowskich wyliczane jest prawdopodobieństwo bayesowskie.</p>
<p>Samopróbkowanie w podstawowej formie polega na tym, że po utworzeniu optymalnego drzewa, z zestawu dopasowanych sekwencji losuje się kolumny zasad i tworzy się z nich kolejne zestawy ,,sekwencji'' o takiej samej długości jak sekwencje wyjściowe. Jest to losowanie ze zwracaniem, co oznacza, że te same kolumny mogą zostać wylosowane wielokrotnie a inne nie pojawiają się w ogóle w generowanych zestawach.</p>
<p>Na przykład dla przyrównania:</p>
<pre><code>0123456789
CAGTCCGATG
TAATCTGATA
TAGTTTGATA
TAGTTTGATA
TAGTTTGATA
TAGTTTGATA
</code></pre>
<p>można stworzyć m. in. takie pseudosekwencje:</p>
<pre><code>1735320955   8327248441   3124291662
AATCTGCGCC   TTGAGCTCCA   TAGCGGAGGG
AATTTATATT   TTAAACTCCA   TAACAAAGGA
AATTTGTATT   TTGAGTTTTA   TAGTGAAGGG
AATTTGTATT   TTGAGTTTTA   TAGTGAAGGG
AATTTGTATT   TTGAGTTTTA   TAGTGAAGGG
AATTTGTATT   TTGAGTTTTA   TAGTGAAGGG itd...
</code></pre>
<p>Dla każdego ,,pseudoprzyrównania'' liczone jest drzewo w taki sam sposób jak drzewo główne, a następnie sprawdzana jest obecność poszczególnych kladów na obu drzewach. Każdemu kladowi, który występuje na drzewie oryginalnym i wygenerowanym w procesie samopróbkowania przypisywany jest punkt. Im większa suma punktów, tym dany klad na drzewie jest bardziej wiarygodny. Wartości bootstrap przedstawia się zwykle w zakresie wartości 0-100, przy węzłach, co odpowiada procentowi wygenerowanych drzew w których występował dany klad.</p>
<p>Liczba bootstrapów, który jest zazwyczaj jednym z parametrów ustawianych w programach generujących drzewa, powinna wynosić minimum 100 a najlepiej osiągać 1000-2000. Ponieważ dla każdego zestawu pseudosekwencji generowane jest drzewo, w zależności od stosowanej metody, proces samopróbkowania może zająć mniej lub więcej czasu. Im metoda bardziej wymagająca obliczeniowo, tym wartości bootstrap będą liczone dłużej.</p>
<p>W przypadku metody bayesowskiej, prawdopodobieństwo <em>a posteriori</em> jest liczone przy okazji generowania drzew, wynikają z udziału drzew w których obecny jest badany klad. Ocena wiarygodności poszczególnych węzłów nie wymaga więc dodatkowych złożonych obliczeń. Jako wartości prawdopodobieństwa mieszczą się zakresie 0-1. Wartości liczone w ten sposób (przy uwzględnieniu innej skali) są zwykle wyższe niż uzyskane dla danego zestawu sekwencji za pomocą bootstrapu, należy jednak pamiętać, że wynikają one z wartości uzyskanych w dużej mierze z drzew znajdujących się blisko drzewa optymalnego i nie są to wartości w pełni porównywalne.</p>
<a class="header" href="#format-newick-i-wartości-dodatkowe-na-drzewie" id="format-newick-i-wartości-dodatkowe-na-drzewie"><h2>Format Newick i wartości dodatkowe na drzewie</h2></a>
<p>Po zakończeniu obliczeń otrzymujemy wynik zazwyczaj w formie pliku tekstowego, który jest sformatowany w taki sposób, że zawiera informacje na temat relacji pomiędzy badanymi taksonami a także inne parametry drzew (np. wartości bootstap).</p>
<p>Poniżej znajduje się przykładowy plik kladogramu zapisanego w formacie <code>newick</code>.</p>
<pre><code>((((B,((C,D),(E,F))),G),(H,I)),A);
</code></pre>
<p>Po przekształceniu go w formę graficzną uzyskujemy taki obraz:</p>
<p><img src="pics-drzewa/simple.png" alt="Kladogram prosty" /></p>
<p>Porównując powyższy plik w formacie <code>newick</code> z kladogramem można zrozumieć zasadę kodowania informacji w pierwszym z nich. W parze nawiasów zamykane się taksony należącego do wspólnego kladu.</p>
<p>W formacie <code>newick</code> można też zapisać inne dane, na przykład dotyczące długości gałęzi i wartości bootstrapu:</p>
<pre><code>(A:0.0611905636,((B:0.0271634370,((C:0.0024799833,D:0.0082762103)100:0.011585,
(E:0.0047747513,F:0.0060564542)81:0.002943)54:0.002522)95:0.009753,
G:0.0145402289)100:0.073576,(H:0.0374628169,I:0.0498809623)100:0.157039);
</code></pre>
<p>Poniżej znajduje się odpowiedni dendrogram:</p>
<p><img src="pics-drzewa/drzewo_z_oznaczeniami.png" alt="Dendrogram z oznaczeniami" /></p>
<p>Na zielono zaznaczono długości gałęzi (odpowiadające liczbie mutacji na miejsce), zaokrąglone do trzech miejsc po przecinku.
Na czerwono wartości bootstrap. W lewym dolnym rogu widać skalę drzewa, którą można odnieść do długości gałęzi (zwłaszcza gdy ich wartości nie są zaznaczone).</p>
<a class="header" href="#wizualizacja-drzew-1" id="wizualizacja-drzew-1"><h2>Wizualizacja drzew</h2></a>
<p>Forma graficzna drzewa filogenetycznego jest znacznie bardziej przejrzysta dla człowieka niż prezentowany powyżej zapis tekstowy. Pozwała łatwo uchwycić pokrewieństwa i odległości ewolucyjne pomiędzy badanymi organizmami, choć ich prawidłowe odczytanie wymaga jednak nieco wiedzy i wprawy.</p>
<p>Trzeba pamiętać, że opierając się na tych samych danych, można utworzyć bardzo różnie wyglądające drzewa.</p>
<p>Poniżej znajduje się zawartość pliku w formacie <code>newick</code> opisująca drzewo i kilka przykładów je przedstawić:</p>
<pre><code>((((B:0.027163437,((C:0.0024799833,D:0.00827621):0.011585,
(E:0.004774751,F:0.006056454):0.002943):0.002522):0.009753,G:0.014540229):0.073576,
(H:0.037462816,I:0.049880963):0.157039):0.003059528,A:0.058131035);
</code></pre>
<p><img src="pics-drzewa/tree-0.png" alt="Drzewo 1" />
<img src="pics-drzewa/tree-1.png" alt="Drzewo 2" />
<img src="pics-drzewa/tree-2.png" alt="Drzewo 3" />
<img src="pics-drzewa/tree-3.png" alt="Drzewo 4" />
<img src="pics-drzewa/tree-4.png" alt="Drzewo 5" />
<img src="pics-drzewa/tree-5.png" alt="Drzewo 6" />
<img src="pics-drzewa/tree-6.png" alt="Drzewo 7" /></p>
<p>Nie ma ,,najlepszej'' formy drzewa. To jakiej należy użyć, zależy od tego co i w jaki sposób chcemy pokazać, liczby danych, rodzaju odbiorcy itp. W pewnych sytuacjach najlepiej sprawdzi się forma drzewa ,,prostokątnego'' w innej drzewo ,,okrągłe''.</p>
<p>Na stronie <a href="http://itol.embl.de/itol.cgi">Interactive Tree of Life</a> można znaleźć, jak sama nazwa wskazuje, ,,drzewo życia&quot; które można modyfikować on-line, m. in. zmieniając jego formę, wyświetlane informacje itp.</p>
<a class="header" href="#horyzontalny-transfer-genów-hgt" id="horyzontalny-transfer-genów-hgt"><h1>Horyzontalny Transfer Genów (HGT)</h1></a>
<a class="header" href="#czym-jest-hgt" id="czym-jest-hgt"><h2>Czym jest HGT?</h2></a>
<p>Horyzontalny transfer genów (ang. <em>Horizontal Gene Transfer</em> - <em>HGT</em>) czasem zwany także poziomym transferem genów (ang. <em>Lateral Gene Transfer</em> - LGT) to proces przenoszenia materiału genetycznego pomiędzy organizmami w inny sposób niż rodzic-potomek (pionowy transfer genów, ang <em>vertical gene transfer</em> - VGT).</p>
<a class="header" href="#u-jakich-organizmów-występuje-hgt" id="u-jakich-organizmów-występuje-hgt"><h2>U jakich organizmów występuje HGT?</h2></a>
<p>Zjawisko po raz pierwszy odkryto w 1951 r. u maczugowca błonicy (<em>Corynebacterium diphtheriae</em>). Zauważono, że odpowiedzialny za patogenność gen pochodzenia wirusowego <em>tox</em> może przenosić się od bakterii patogennych do niepatogennych.
W 1959 wykazano, że tą droga mogą się przenosić bakteryjne geny odpowiedzialne za odporność na antybiotyki
Kolejne badania wskazały na dużą rolę HGT w wymianie materiału genetycznego u prokariontów. Kluczową rolę odgrywają w tej grupie organizmów takie procesy jakkoniugacja, transdukcja i transformacja.
Wykazano także, znaczny wpływ HGT na ewolucję eukariontów.
Przede wszystkim zwraca się uwagę na rolę tego procesów u protistów.
Obserwuje się je jednak u pozostałych grup <em>Eucaryota</em> i kolejne badania wskazują na istotną rolę w ewolucji tej grupy organizmów.</p>
<a class="header" href="#pomiędzy-jakimi-organizmami-występuje-hgt" id="pomiędzy-jakimi-organizmami-występuje-hgt"><h2>Pomiędzy jakimi organizmami występuje HGT?</h2></a>
<p>W przeciwieństwie do przenoszenia genów drogą krzyżowania międzygatunkowego, które ograniczone są do blisko spokrewnionych organizmów, wydaje się, że nie ma wyraźnych granic taksonomicznych dla HGT.
Znane są transfery pomiędzy różnymi gatunkami bakteriami czy roślin, ale także pomiędzy bakteriami i grzybami, bakteriami i roślinami, bakteriami i zwierzętami, grzybami i zwierzętami czy grzybami i roślinami.
Wydaje się zatem, że nie istnieją żadne bariery genetyczne ,,zakazujące'' przenoszenia się materiału genetycznego pomiędzy nawet odległymi ewolucyjnie organizmami.
Dalsze rozważania będą dotyczyć przede wszystkim roślin</p>
<a class="header" href="#w-jaki-sposób-przenoszą-się-sekwencje-dna" id="w-jaki-sposób-przenoszą-się-sekwencje-dna"><h2>W jaki sposób przenoszą się sekwencje DNA?</h2></a>
<p>Mechanizmy odpowiedzialne za HGT nie są dostatecznie wyjaśnione.
Zwykle wskazuje się na:</p>
<ul>
<li>Przenoszenie kwasów nukleinowych przez pośredników takich jak wirusy, bakterie, grzyby</li>
<li>Transpozony</li>
<li>Bezpośrednie pobieranie kwasów nukleinowych (zwłaszcza w układach pasożyt-żywiciel)</li>
</ul>
<p>Teoretycznie materiał genetyczny może przenosić się za pomocą fragmentów DNA lub poprzez mRNA, które następnie dzięki odwrotnej transkypcji mógłby z powrotem zostać przekształcony w DNA
Badania wskazują raczej na tą pierwszą możliwość.</p>
<a class="header" href="#hgt-u-eukariontów" id="hgt-u-eukariontów"><h2>HGT u eukariontów</h2></a>
<p>Uważa się, że procesowi HGT sprzyja długotrwały fizyczny kontakt pomiędzy organizmami
Taka sytuacja może dotyczyć np:</p>
<ul>
<li>Endosymbiontów</li>
<li>Układów pasożyt-żywiciel</li>
<li>Szczepień</li>
<li>Wchłaniania jednych organizmów przez inne (pierwotniaki)</li>
<li>Jeśli przeniesione sekwencje DNA mają być przekazane następnym pokoleniom, muszą przedostać się do linii generatywnej (o ile organizm nie rozmnaża się bezpłciowo) toteż skutecznemu HGT sprzyja fizyczna komórek rozrodczych i symbiontów lub ich kontakt ze środowiskiem zewnętrznym</li>
</ul>
<a class="header" href="#hgt-w-mitochondriach" id="hgt-w-mitochondriach"><h2>HGT w mitochondriach</h2></a>
<p>Mitochondria wydają się być szczególnie predysponowane do horyzontalnego transferu genów:</p>
<ul>
<li>Posiadają mechanizmy pobierania DNA i RNA z otoczenia.</li>
<li>Często ulegają fuzji.</li>
<li>Roślinne mitochondria mają system rekombinacji homologicznej.</li>
<li>Ich genomy mają strukturę dynamiczną i ulegają rearanżacjom</li>
<li>Genomy mitochondriów roślinnych zawierają kilkadziesiąt genów</li>
<li>Pomiędzy genami znajdują się niekodujące odcinki w które może się wbudowywać obce DNA.</li>
</ul>
<p>U okrytonasiennych obce mtDNA zwykle pochodzi od mitochondriów innych okrytonasiennych ale znajduje się także geny mchów czy glonów.</p>
<a class="header" href="#hgt-w-jądrach-komórkowych-i-plastydach" id="hgt-w-jądrach-komórkowych-i-plastydach"><h2>HGT w jądrach komórkowych i plastydach</h2></a>
<p>W jądrach komórek roślin okrytonasiennych znaleziono także wiele śladów HGT
Dotyczą one genów jądrowych a także transpozonów
Ciekawym przypadkiem jest pasożytnicza roślina <em>Rafflesia cattlei</em>, u której znaleziono ponad 30 genów przeniesionych od żywiciela. Przynajmniej niektóre są funkcjonalne.
Plastydy uważane są za bardzo odporne na takie procesy jak HGT czy IGT (zob. dalej).
Obce sekwencje plastydowe, znajduje się raczej w innych genomach komórki - mitochondrialnym lub jądrowym</p>
<a class="header" href="#transfer-pomiędzy-genomami-wewnątrz-komórki" id="transfer-pomiędzy-genomami-wewnątrz-komórki"><h2>Transfer pomiędzy genomami wewnątrz komórki</h2></a>
<p>Fragmenty DNA mogą przenosić się z jądra komórkowego jednego organizmu do jądra komórkowego innego organizmu.
Proces ten może także przebiegać pomiędzy wszystkimi elementami komórki zawierającymi materiał genetyczny: jądrem, mitochondriami i plastydami.
Przenoszenie fragmentów DNA pomiędzy genomami wewnątrz komórki nazywamy międzygenomowym transferem genów (ang. <em>Intergenomic Gene Transfer</em> - <em>IGT</em>)
Trzeba pamiętać, że genomy mitochondriów i plastydów maja charakter prokariotyczny a jądra (niejako z definicji) eukariotyczny.
Mitochondria większości zbadanych roślin nasiennych zawierają sekwencje jądrowe i plastydowe.
Geny mitochondrialne znajduje się także w plastydach, ale rzadko. Różnica wynika prawdopodobnie z tego, że mitochondria, w przeciwieństwie do plastydów, mają efektywne mechanizmy pobierania obcego DNA.
W jądrach znaleziono wiele genów pochodzenia mitochondrialnego. W takich przypadkach następuje konwersja genów prokariotycznych w eukariotyczne co wiąże się m. in. z tym, że podlegają rekombinacji przy rozmnażaniu płciowym. Przypuszczalnie w tego typu IGT bierze udział RNA jako pośrednik.</p>
<a class="header" href="#znaczenie-hgt-w-ewolucji-roślin" id="znaczenie-hgt-w-ewolucji-roślin"><h2>Znaczenie HGT w ewolucji roślin</h2></a>
<p>Dotychczasowe badania wskazują na dużą rolę HGT w ewolucji eukariontów
Ślady tego procesu znajduje się we wszystkich dużych grupach organizmów
Odegrał także ważną rolę w ewolucji roślin
Przykładowo, procesowi przekształcania się wewnątrzkomórkowego prokariotycznego endosymbiontu w chloroplast towarzyszył transfer kilkudziesięciu genów z chlamydii - które w tym czasie także prawdopodobnie były endosymbiontami komórek eukariotycznych.
Uważa się, że geny pobrane od różnych organizmów miały istotną rolę w nabywaniu wielu ważnych cech umożliwiających m. in. adaptacje roślin do nowych i ekstremalnych warunków, efektywne reakcje na stress, wydajniejszą naprawę DNA, degradację celulozy czy rozwój tkanek przewodzących.</p>
<a class="header" href="#rośliny-pasożytnicze" id="rośliny-pasożytnicze"><h2>Rośliny pasożytnicze</h2></a>
<p>Rośliny pasożytnicze są dobrym kandydatem na organizmy pobierające obce DNA, ponieważ bezpośrednio są połączone z żywicielem i pobierają od niego składniki odżywcze.
Połączenie odbywa się przez haustorium - strukturę która wnika w tkanki korzenia lub pędu gospodarza i pobiera wodę, sole mineralne i inne składniki odżywcze.
Wyróżnia się dwie podstawowe kategorie pasożytów:</p>
<ul>
<li>hemipasożyty (półpasożyty) - zdolne do prowadzenia własnej fotosyntezy, pobierające od żywiciela głównie wodę i sole mineralne (np. jemioła (<em>Viscum</em>), szelężnik (<em>Rhinanthus</em>))</li>
<li>holopasożyty - niezdolne do fotosyntezy, pobierają od żywiciela także cukry i inne składniki odżywcze (np. zaraza (<em>Orobanche</em>), kanianka (<em>Cuscuta</em>))</li>
</ul>
<p>Bardziej oczywistymi kandydatami na HGT wydają się być oczywiście holopasożyty</p>
<a class="header" href="#hgt-u-roślin-pasożytniczych" id="hgt-u-roślin-pasożytniczych"><h2>HGT u roślin pasożytniczych</h2></a>
<p>Rzeczywiście, badania wskazują, na stosunkowo liczne przypadki HGT w relacjach pasożyt-żywiciel
Są więc dobrym modelem do badania tego procesu.
Przy czym znajduje się nie tylko sekwencje przeniesione od żywiciela do pasożyta ale także od pasożyta do żywiciela.
Nie jest zaskoczeniem, że głównie dotyczą one sekwencji mitochondrialnych, ale także znajduje się geny jądrowe i plastydowe
Szacuje się, że u <em>Raflesiaceae</em> nawet ok 40% genów mitochondrialnych wykazuje ślady HGT</p>
<a class="header" href="#wykrywanie-hgt" id="wykrywanie-hgt"><h2>Wykrywanie HGT</h2></a>
<p>HGT wykrywa się głównie drogą znajdywania niezgodności na drzewach filogenetycznych.
Porównuje się drzewo, które przedstawia ,,prawidłowe'' relacje filogenetyczne z drzewem sporządzonym dla badanej sekwencji.
Jeśli występują niezgodności, mogą one świadczyć o transferze genów.
Położenie badanej sekwencji na drzewie filogenetycznym może wskazywać na źródło obcej sekwencji,
Na przykład sekwencja pobrana od pasożyta może wykazywać bliskie podobieństwo do sekwencji żywiciela
Wtedy można przypuszczać, że została pobrana od żywiciela i została wbudowana w genom pasożyta.</p>
<a class="header" href="#podstawy-pracy-w-systemie-linux" id="podstawy-pracy-w-systemie-linux"><h1>Podstawy pracy w systemie Linux</h1></a>
<a class="header" href="#czym-jest-i-dlaczego-właśnie-linux" id="czym-jest-i-dlaczego-właśnie-linux"><h2>Czym jest i dlaczego właśnie Linux?</h2></a>
<p>Popularnie Linuksem nazywamy system operacyjny oparty na jądrze Linux. Występuje on w niezliczonej liczbie odmian, zwanych dystrybucjami. W większości są one darmowe i dostępne w internecie. Zawierają jądro systemu oraz zestawy oprogramowania, różnią się miedzy innymi systemami obsługi oprogramowania, dostępnym oprogramowaniem w repozytoriach (miejscach w sieci skąd można pobrać programy), ustawieniami domyślnymi, modyfikacjami jądra itp. Pewne pojęcie na temat liczby dystrybucji może dać strona <a href="http://distrowatch.com">distrowatch.com</a> lub <a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg">ilustracja z Wikipedii</a> pokazująca związki między różnymi dystrybucjami. Ta różnorodność, która na początku może zaskakiwać użytkowników innych systemów operacyjnych (a czasem nawet irytować), jest kolejną zaletą Linuksa. Mamy do wyboru nie tylko wiele dystrybucji ale także <a href="https://pl.wikipedia.org/wiki/Graficzny_interfejs_u%C5%BCytkownika">środowisk graficznych</a> (np. KDE, Gnome, Xfce, LXDE), które można w znacznym stopniu konfigurować według własnych upodobań a nawet <a href="https://pl.wikipedia.org/wiki/Pow%C5%82oka_systemowa">powłok systemowych</a>. Dzięki temu można system dostosować do swoich potrzeb i upodobań, także estetycznych ale także możliwości komputera.</p>
<p>Linuksa można zainstalować zamiast ale także obok innego systemu operacyjnego (np. Windows). W tym drugim przypadku przy włączeniu komputera pojawia się menu, w którym wybieramy który system załadować. Instrukcja instalacji Linuksa wychodzi poza zakres tego kursu ale bez problemu można znaleźć odpowiednie informacje w internecie. Można także zainstalować Linux jako wirtualny system operacyjny, wtedy otwiera się w naszym głównym systemie jako osobne okienko, w którym pracujemy. Można w taki sposób zainstalować Linuksa pod Windows, Mac OSX czy innym Linuksem. Instrukcja takiej instalacji z użyciem programu VirtualBox znajduje się np. na mojej stronie pod adresem <a href="http://ggoralski.pl/?p=1408">http://ggoralski.pl/?p=1408</a>.</p>
<p><img src="praca_w_linuksie/wirtualny_Linux.png" alt="Wirtualny Linux pod Linuksem" /></p>
<p>W części praktycznej kursu będę się posługiwał dystrybucją wywodzącą się z Debiana, jednak większość, o ile nie wszystkie przykłady (poza instalacją i aktualizacją oprogramowania) powinny działać na dowolnym Linuksie, pod warunkiem zainstalowania używanego oprogramowania. Jedną z wielu zalet Debiana i dystrybucji pochodnych, które korzystają z jego repozytoriów, jest domyślna dostępność wielu programów bioinformatycznych zgromadzonych w repozytorium Debian Med.</p>
<p>Linux jest podobny do systemu UNIX. Z niego wywodzi się struktura systemu, wiele narzędzi a także ,,filozofia'' pisania programów. To ostatnie jest jednym z powodów, że to środowisko powszechnie stosowane w bioinformatyce. O filozofii Uniksa można poczytać np. w dostępnej online książce <a href="http://www.catb.org/%7Eesr/writings/taoup/html/">The Art of Unix Programming</a>, ale z naszego punktu widzenia zwłaszcza istotne są tu trzy elementy:</p>
<ol>
<li>Programy nie powinny być ,,kombajnami do wszystkiego'', raczej jeden program wykonywać porządnie jedno zadanie</li>
<li>Programy powinny być pisane tak, aby mogły ze sobą współpracować - wyniki jednego programu można przekierować do drugiego jako dane wejściowe</li>
<li>Programy powinny przyjmować dane i produkować wyniki w formie tekstowej.</li>
</ol>
<p>Dlaczego to takie ważne? Dzięki takiemu podejściu do tworzenia programów możemy je traktować jak klocki, które układamy w taki sposób, że każdy z nich wykonuje określone zadanie, przekazuje wynik swojej pracy następnemu, który przerabia go dalej itd. Przykładowo: <code>program A</code> gromadzi sekwencje, <code>program B</code> je wyrównuje, <code>program C</code> tworzy drzewo filogenetyczne a <code>program D</code> generuje dendrogram. Programy te można uruchamiać po kolei ręcznie albo automatycznie pisząc odpowiedni skrypt albo łączyć za pomocą potoków (ang. <em>pipe</em>). Jeśli w pewnym momencie stwierdzimy, że np. zamiast <code>programu B</code> lepiej sprawdzi się <code>program Z</code> to po prostu podmieniamy je. Użycie tekstu jako ,,uniwersalnego'' formatu pozwala na łatwą komunikację miedzy tymi programami. Niebawem zobaczymy jak to wszystko działa w praktyce.</p>
<p>Taki sposób pracy wiąże się zwykle z pracą w terminalu. Co prawda większość dystrybucji zaopatrzona jest w interfejs graficzny (i to w różnych odmianach) oraz oferuje szeroką gamę ,,okienkowych'' aplikacji, także bioinformatycznych ale wiele zadań, co może się wydawać na początku dziwne, zwyczajnie łatwiej i szybciej wykonuje się używając linii komend. Oczywiście nie zawsze tak jest, w niektórych przypadkach, np. przy obróbce dendrogramów, czy ręcznym poprawianiu dopasowania sekwencji, wygodniej i efektywniej pracuje się w aplikacjach z interfejsem graficznym. Na naszych zajęciach, będziemy używać obu sposobów pracy, jednak z naciskiem na pracę w terminalu. Otwórz zatem terminal. W zależności od dystrybucji, środowiska i środowiska graficznego odpowiedni program można znaleźć w różnych miejscach menu (np. Programy-&gt;Narzędzia systemowe-&gt;Terminal MATE). Mamy też do dyspozycji różne programy, które udostępniają użytkownikowi terminal pod interfejsem graficznym, ich nazwy zazwyczaj zawierają w sobie <code>Terminal</code> lub <code>Term</code>, np. <code>Terminal MATE</code>, <code>XTerm</code>. Niektóre z nich mają dodatakowe ułatwienia, np. obsługują wiele zakładek. W każdym razie sugeruję aby od razu po odnalezieniu programu, z którego będziesz korzystać od razu umieścić do niego skrót na pulpicie lub panelu.</p>
<p><img src="praca_w_linuksie/terminal_w_menu.png" alt="Otwieranie terminala" /></p>
<a class="header" href="#powłoki-systemowe" id="powłoki-systemowe"><h2>Powłoki systemowe</h2></a>
<p>Otwarte okno z terminalem (ściśle rzecz biorąc jest to emulator terminala) wygląda mniej więcej tak:</p>
<p><img src="praca_w_linuksie/terminal.png" alt="Okno terminala" /></p>
<p>Po otwarciu okna z terminalem zauważysz znak zachęty, który w zależności od konfiguracji może wyglądać np tak (w katalogu domowym):</p>
<pre><code>user@nazwakomputera:~$
</code></pre>
<p>Albo prościej:</p>
<pre><code>$:
</code></pre>
<p>czy np:</p>
<pre><code>~
</code></pre>
<p>To jak wygląda można dość dowolnie modyfikować. Często znajduje się tam nazwa bieżącego katalogu, albo cała ścieżka do niego. Dla uproszczenia przyjmiemy, że wygląda tak:</p>
<pre><code>$:
</code></pre>
<p>Więcej na temat znaków zachęty i możliwości ich ustawiania można przeczytać np. <a href="https://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html">tu</a></p>
<p>Po znaku zachęty widzimy zwykle migający kursor.</p>
<p>Poniżej będę pokazywał komendy i ich wynik w terminalu. To co nie jest poprzedzone znakiem zachęty będzie wydrukiem generowanym przez polecenia.</p>
<p>W terminalu uruchomiona jest <strong>powłoka systemowa</strong> (ang. <em>shell</em>). Jest to program pełniący rolę pośrednika pomiędzy użytkownikiem i systemem operacyjnym oraz innymi programami. Ogólnie powłoki można podzielić na graficzne (ang. GUI - <em>Graphical User Interface</em>) oraz tekstowe (ang. CLI - <em>Command Line Interface</em>). Teraz zajmiemy się tymi drugimi.</p>
<p>Powłoki tekstowe, jak nazwa wskazuje, przyjmują polecenia od użytkownika i zwracają wyniki działania programów (zazwyczaj) w trybie tekstowym. W Linuksie dostępnych jest (domyślnie bądź po doistalowaniu) wiele powłok (znów ta różnorodność!), np. bash, zsh, ksh, sh, fish. Bash jest zwykle domyślnie zainstalowany i uruchamiany w terminalu, zatem będę się na nim opierał. Jednak warto zaznaczyć, że często zalecany jest zsh, zwłaszcza po doinstalowaniu <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a>. Udostępnia on wiele ułatwień. Podane przeze mnie przykłady powinny także działać pod zsh.</p>
<a class="header" href="#konsola-katalogi-pliki-uprawnienia---pierwsze-starcie" id="konsola-katalogi-pliki-uprawnienia---pierwsze-starcie"><h2>Konsola, katalogi, pliki, uprawnienia - pierwsze starcie</h2></a>
<p>W Linuksie system plików tworzy jedno wielkie drzewo, które zaczyna się w katalogu głównym (ang. <em>root directory</em>), oznaczanym jako <code>/</code>. Pod tym względem przypomina nieco drzewo filogenetyczne ;-). Jest to jedna z wielu różnic między systemami uniksopodobnymi a Windows, gdzie każdy dysk (i partycja) stanowi osobną jednostkę i jest częścią pełnej ścieżki, którą podajemy, np:</p>
<ul>
<li>ścieżka w systemie Windows: <code>C:\Documents and Settings\student\Moje dokumenty</code></li>
<li>ścieżka w systemie Linux: <code>/home/student/Dokumenty</code></li>
</ul>
<p>W powyższych przykładach widać też różnicę w znaku oddzielającym katalogi: w Windows jest to <code>\</code>, w Linuksie <code>/</code>.</p>
<p>Gdzie zatem znajdują się w drzewie katalogu dodatkowe dyski i partycje? Są one widoczne jako katalogi. Można je zamontować w zasadzie w dowolnym miejscu, na przykład jako podkatalogi w folderze domowych użytkownika.</p>
<p>Nazywając katalogi i pliki warto trzymać się kilku zasad:</p>
<ul>
<li>Nie używać spacji. Technicznie można używać spacji w nazwach katalogów i plików, ale zwłaszcza jeśli mamy zamiar pracować w terminalu lepiej tego unikać, ponieważ może to powodować komplikacje. Można je co prawda zwykle obejść ale... po co komplikować sobie pracę? Zatem, lepiej trzymać się zasady: <strong>w nazwach katalogów i plików nie używamy spacji</strong>.</li>
<li>Jeśli nazwa zawiera wiele słów, można je oddzielić bp. znakami <code>_</code> czy <code>-</code>. Na przykład: <code>Wyniki_badan</code>, <code>atp1-Rumex.fasta</code>. W nazwach dobrze jest też unikać polskich znaków.</li>
<li>Wielkość liter ma znaczenie: <code>atp1.fasta</code>, <code>ATP1.fasta</code> i <code>atp1.FASTA</code> to różne nazwy plików.</li>
</ul>
<p>Teraz czas na trochę praktyki.</p>
<p>W terminalu wpisz komendy:</p>
<pre><code>$: cd /
$: ls
</code></pre>
<p><code>cd</code> oznacza ,,idź do katalogu'' a <code>/</code> oznacza katalog główny.
<code>ls</code> drukuje katalogi i pliki znajdujące się w danym folderze. Jeśli po tym poleceniu podamy ścieżkę, np. <code>ls /var/log</code> otrzymamy listę elementów znajdujących się we wskazanym katalogu.</p>
<p>Powinniśmy zobaczyć taki (lub podobny) wynik:</p>
<pre><code>bin   dev  home        initrd.img.old  lib64       media  opt   root  sbin  sys  usr  vmlinuz
boot  etc  initrd.img  lib             lost+found  mnt    proc  run   srv   tmp  var  vmlinuz.old
</code></pre>
<p>To są katalogi i pliki systemowe. Mają one swoje <a href="https://pl.wikibooks.org/wiki/Linux/System_plik%C3%B3w/Drzewo_katalog%C3%B3w">konkretne przeznaczenie</a>. Na razie będzie nas interesować katalog <code>home</code>, przejdź zatem tam i sprawdź co tam się znajduje:</p>
<pre><code>$: cd home
$: ls
</code></pre>
<p>Wynik może wyglądać różne w zależności jakie konta użytkownika znajdują się na komputerze, na przykład tak:</p>
<pre><code>alicja grzeg krzysztof student
</code></pre>
<p>To są katalogi domowe użytkowników, którzy mają konta na tym systemie. Jest jeszcze jeden użytkownik: <code>root</code>. Jest on panem i władcą całego systemu i może WSZYSTKO (no, prawie wszystko). Jego katalog domowy znajduje się w katalogu głównym. Początkujący użytkownicy Linuksa mają często pokusę aby po prostu logować się jako <code>root</code> i pracować na tym koncie. To jednak nie jest, delikatnie mówiąc, najlepszy pomysł. Głównie z powodów bezpieczeństwa. Lepiej przyjąć zasadę, że nawet jeśli jesteś jedynym użytkownikiem systemu, tworzysz dla siebie konto ,,normalnego'' użytkownika a z konta <code>roota</code> korzystasz tylko wtedy, gdy jest konieczne, np. przy instalacji pakietów, aktualizacji systemu, czy zakładaniu kont nowym użytkownikom. Prawdę mówiąc, zwykle nawet w takich przypadkach nie jest konieczne bezpośrednie logowanie się na konta, lecz korzysta się z narzędzi takich jak <code>sudo</code>, które pozwalają uruchomić program z prawami <code>roota</code>.</p>
<p>Dalej zakładamy, że Twoje konto to <code>student</code> i na nim będziemy pracować.</p>
<p>Najpierw spróbujmy wejść do katalogu innego użytkownika:</p>
<pre><code>$: cd grzeg
</code></pre>
<p>Okazuje się, że się nie da:</p>
<pre><code>bash: cd: grzeg: Brak dostępu
</code></pre>
<p>I bardzo słusznie :-)</p>
<p>Zobaczmy z czego to wynika, używając komendy <code>ls</code> z dodatkową opcją (inaczej <strong>flagą</strong>) <code>-l</code>. Oznacza ona wyświetlanie dodatkowych informacji:</p>
<pre><code>$: ls -l

razem 12
drwx------ 56 grzeg     grzeg     4096 gru  6 19:46 grzeg
drwx------ 16 krzysztof krzysztof 4096 lis 21 19:35 krzysztof
drwx------ 15 student   student   4096 gru  6 18:29 student
</code></pre>
<p>Nie będę omawiał szczegółowo wszystkich wyświetlanych informacji, skupię się na tych najistotniejszych z punktu widzenia kursu.</p>
<p>Na początku każdej z linii przyporządkowanej do katalogu znajduje się taki zestaw znaków:</p>
<p><code>drwx------</code></p>
<p>Litera <code>d</code> oznacza, że mamy do czynienia z katalogiem, ,,zwykły'' plik będzie tam miał znak <code>-</code>.</p>
<p>Kolejne litery należy odczytywać trójkami, oznaczają one bowiem uprawnienia kolejno dla:</p>
<ul>
<li>użytkownika, który jest właścicielem pliku/katalogu,</li>
<li>innych członków grupy do której należy właściciel (użytkowników można łączyć w grupy)</li>
<li>wszystkich pozostałych</li>
</ul>
<p>A teraz zobaczmy co oznaczają kolejne litery w każdej trójce:</p>
<ul>
<li><code>r</code> - prawo odczytu</li>
<li><code>w</code> - prawo zapisu/modyfikacji/usuwania</li>
<li><code>x</code> - dla pliku: prawo do uruchamiania, dla katalogu: prawo do wejścia do katalogu</li>
</ul>
<p>Jeśli w danym miejscu zamiast litery znajduje się znak <code>-</code>, oznacza to brak danego uprawnienia.</p>
<p>Zatem ciąg znaków: <code>drwx------</code> możemy odczytać tak:</p>
<ul>
<li><code>d</code>: jest to katalog</li>
<li><code>rwx</code>: właściciel może go odczytać, modyfikować i wejść do niego,</li>
<li><code>---</code>: członkowie grupy nie mogą go ani odczytać ani modyfikować ani wejść do niego</li>
<li><code>---</code>: inni też nie mogą go ani odczytać ani modyfikować ani wchodzić do niego</li>
</ul>
<p>Teraz staje się jasne, dlaczego będąc użytkownikiem <code>student</code> nie można wejść do katalogu użytkownika <code>grzeg</code> - może to zrobić tylko sam właściciel. Do uprawnień i ich modyfikacji jeszcze wrócimy.</p>
<p>Co oznaczają dalsze pola? Liczby pomijamy, następnie znajduje się nazwa użytkownika - właściciela i nazwa grupy (tu jest to grupa o nazwie takiej jak właściciel). Kolejna liczba określa wielkość elementu, w przypadku katalogu nie jest to wielkość wszystkich elementów, które zawiera. Następnie mamy datę ostatniej modyfikacji (utworzenia, modyfikacji, zapisu). W końcu widać nazwę elementu.</p>
<p>Przejdźmy teraz do katalogu domowego użytkownika <code>student</code> i sprawdźmy co tam się znajduje:</p>
<pre><code>$: cd student
$: ls
Desktop  Dokumenty  Muzyka  Obrazy  Pobrane  Publiczny  Szablony  Wideo
</code></pre>
<p>Są to standardowe katalogi użytkownika tworzone przy pierwszym logowaniu. W zależności od dystrybucji i ustawień mogą być inne od powyższych.</p>
<p>Teraz użyjmy opcji <code>-a</code> (jak <em>all</em> - wszystkie)</p>
<pre><code>$: ls -a
.              .bash_logout  .config  Dokumenty   .gitignore     .inputrc  Obrazy    Publiczny  .Xauthority
..             .bashrc       Desktop  .gconf      .gnupg         .local    Pobrane   Szablony   .xsession-errors
.bash_history  .cache        .dmrc    .gitconfig  .ICEauthority  Muzyka    .profile  Wideo
</code></pre>
<p>Jak widać lista plików znacznie się powiększyła. Pojawiły się katalogi i pliki (sprawdź komendą <code>ls -la</code> co jest czym), których nazwy zawierają na początku kropkę. Są to elementy ukryte, które domyślnie się nie wyświetlają. Zazwyczaj są to pliki konfiguracyjne, albo katalogi zawierające pliki konfiguracyjne. Najbardziej zagadkowe mogą się wydawać katalogi <code>.</code> oraz <code>..</code>. Pierwszy z nich oznacza tyle co ,,bieżący katalog'' a drugi ,,nadrzędny katalog'' (w tym wypadku <code>/home</code>). Używanie tych ,,kropkowych'' oznaczeń katalogów jest bardzo wygodnie. Jeśli chcesz przejść do katalogu powyżej, wcale nie musisz pamiętać jak się nazywa, po prostu piszesz: <code>cd ..</code>. Można też wykorzystać je przy innych operacjach np. kopiowaniu czy przenoszeniu plików i katalogów.</p>
<p>Przy okazji ważna uwaga. Większość komend, których będziemy używać posiada (choć np. <code>cd</code> nie) swoje manuale, które można wywołać poleceniem <code>man komenda</code>. Tam można znaleźć np. dostępne opcje. Często dostępna też jest krótsza pomoc przy użyciu opcji <code>-h</code> lub <code>--help</code>, choć trzeba pamiętać, że <code>-h</code> może też mieć inne znaczenie w niektórych programach.</p>
<p>Sprawdź <code>man ls</code>. Dowiedz się do czego służy opcja <code>-h</code> i jak posortować listę plików/folderów według czasu ich modyfikacji.</p>
<p>Z manuala można wyjść używając klawisza <code>q</code>.</p>
<p>Kolejna przydatna komenda to <code>pwd</code> - wyświetla ona ścieżkę do miejsca, w którym się znajdujemy:</p>
<pre><code>$: pwd
/home/student
</code></pre>
<p>Jeśli chcemy szybko przenieść się do swojego katalogu domowego z dowolnego miejsca, nie musimy wpisywać pełnej ścieżki. Możemy użyć znaku <code>~</code>. Wykonaj kolejno polecenia:</p>
<pre><code>$: cd ..
$: pwd
$: cd ..
$: pwd
$: cd ~
$: pwd
</code></pre>
<p>Ścieżki typu <code>/home/student/Dokumenty</code> są ścieżkami <strong>absolutnymi</strong> (bezwzględnymi), używając ich wskazujemy zawsze to samo miejsce w drzewie katalogów. Innym rodzajem ścieżek, są ścieżki <strong>względne</strong>, które mogą wskazywać różne miejsca w zależności od tego gdzie aktualnie się znajdujemy w linii poleceń. Prostym przykładem jest <code>..</code>, czyli ,,katalog wyżej'', ale mogą to być bardziej złożone ścieżki, np. polecenie: <code>cd ../../RESULTS/</code> oznacza ,,idź do katalogu wyżej, idź do katalogu wyżej, idź do katalogu RESULTS''. Takie ścieżki są przydatne na przykład wtedy, kiedy łatwiej jest nam określić docelowy katalog z bieżącego miejsca położenia, niż z uwzględnieniem całej ścieżki, albo gdy posługujemy się pewnym zestandaryzowanym układem podkatalogów (także w projektach bioinformatycznych).</p>
<p>Kolejnym przydatnym ,,skrótowcem'' jest znak <code>-</code> używany razem z komendą <code>cd</code>. Oznacza on ,,katalog w którym byłem poprzednio''. Spróbuj:</p>
<pre><code>$: cd /
$: pwd
$: cd -
$: pwd
</code></pre>
<a class="header" href="#tworzenie-plików-i-katalogów" id="tworzenie-plików-i-katalogów"><h2>Tworzenie plików i katalogów</h2></a>
<p>Teraz w katalogu domowym stwórz nowy katalog:</p>
<pre><code>$: mkdir Proba
</code></pre>
<p><code>mkdir</code> to polecenie utworzenia nowego katalogu, po którym podaje się jego nazwę.</p>
<p>Sprawdźmy czy się udało:</p>
<pre><code>$: ls
Desktop  Dokumenty  Muzyka  Obrazy  Pobrane  Proba  Publiczny  Szablony  Wideo
</code></pre>
<p>Przejdź do nowoutworzonego katalogu:</p>
<pre><code>$: cd Proba
</code></pre>
<p>Wyświetl tekst na ekranie, służy do tego komenda <code>echo</code>:</p>
<pre><code>$: echo &quot;Witaj świecie!&quot;
Witaj świecie!
</code></pre>
<p>Utwórz plik tekstowy i sprawdź czy się pojawił:</p>
<pre><code>$: touch nowy_plik.txt
$ ls
nowy_plik.txt
</code></pre>
<p>Komenda <code>touch</code> tworzy plik, który jest na początku pusty.</p>
<a class="header" href="#umieszczanie-tekstu-w-plikach-z-linii-komend" id="umieszczanie-tekstu-w-plikach-z-linii-komend"><h2>Umieszczanie tekstu w plikach z linii komend</h2></a>
<p>Umieśćmy więc w nim jakiś tekst:</p>
<pre><code>$: echo &quot;Witaj świecie!&quot; &gt; nowy_plik.txt
</code></pre>
<p>Operator <code>&gt;</code> po komendzie przekazuje tekst generowany przez tą komendę (strumień) do pliku tekstowego. Sprawdźmy zatem, jaka jest zawartość pliku <code>nowy_tekst.txt</code>. Można do tego użyć edytora tekstu, ale na razie pozostańmy przy linii komend. Żeby zobaczyć zawartość pliku tekstowego można użyć kilku komend,  np. <code>more</code>, <code>less</code> (która o dziwo <a href="https://unix.stackexchange.com/questions/604/isnt-less-just-more">może więcej niż <code>more</code></a>) czy <code>cat</code>. Dwie pierwsze komendy przy dłuższych plikach są wygodniejsze, pozwalają łatwiej poruszać się po tekście, ostatnia po prostu drukuje zawartość pliku w terminalu. Przy jednolinijkowym pliku jednak nie zauważysz różnicy.</p>
<pre><code>$: more nowy_plik.txt 
Witaj świecie!
</code></pre>
<p>Teraz coś dopiszmy do pliku:</p>
<pre><code>$: echo &quot;Żegnaj okrutny świecie...&quot; &gt;&gt; nowy_plik.txt 
$: more nowy_plik.txt 
Witaj świecie!
Żegnaj okrutny świecie...
</code></pre>
<p>Zauważ, że tym razem użyliśmy operatora <code>&gt;&gt;</code>. Co się stanie jeśli ponownie użyjemy znaku <code>&gt;</code>?</p>
<pre><code>$: echo &quot;...albo może jednak nie żegnaj :-)&quot; &gt; nowy_plik.txt 
$: more nowy_plik.txt 
...albo może jednak nie żegnaj :-)
</code></pre>
<p>Jak widać, użycie pojedynczego znaku <code>&gt;</code> spowodowało wymazanie poprzedniej zawartości pliku. Trzeba o tym pamiętać, ponieważ łatwo o pomyłkę - możemy chcieć dopisać coś do pliku a przez użycie <code>&gt;</code> zamiast <code>&gt;&gt;</code> skasujemy całą poprzednią zawartość. Ma to znaczenie zwłaszcza przy pisaniu skryptów.</p>
<p>Co się stanie jeśli spróbujemy przekierować tekst do nieistniejącego pliku?</p>
<pre><code>$: echo &quot;Witaj Wszechświecie!&quot; &gt; nieistniejący_plik.txt
$: more nieistniejący_plik.txt 
Witaj Wszechświecie!
</code></pre>
<p>Jak widać w powyższym przykładzie nie było konieczne użycie poprzednio komendy <code>touch</code>. Jeśli plik nie istnieje, jest on tworzony.</p>
<p>Możemy też skierować strumień (danych) z pliku do polecenia, które jest w stanie go przetworzyć, używając znaku <code>&lt;</code>:</p>
<pre><code>$: echo &quot;aaaa&quot; &gt; tekst.txt
$: more &lt; tekst.txt 
aaaa
</code></pre>
<a class="header" href="#automatyczne-uzupełnianie-w-terminalu" id="automatyczne-uzupełnianie-w-terminalu"><h2>Automatyczne uzupełnianie w terminalu</h2></a>
<p>Czas na poznanie pewnego triku. Konsola potrafi nam ułatwić wpisywanie komend podpowiadając to co możemy wpisać. Wystarczy wpisać część komendy lub nazwy pliku a reszta zostaje dopełniona po naciśnięcia klawisza <code>&lt;Tab&gt;</code>. Na przykład wpiszemy <code>more nie</code>, naciśniemy <code>&lt;Tab&gt;</code>, w linii komend pojawi się pełna nazwa pliku. Jeśli istnieje wiele możliwości dopełnienia komendy czy nazwy pliku, zostaną podane istniejące możliwości. Oczywiście plik czy komenda musi istnieć, komputer nie zgadanie co mamy na myśli ;-)
Jest to bardzo wygodne zwłaszcza, gdy podajemy jako argumenty nazwy długich plików, które co gorsza niekoniecznie pamiętamy. Aby to sprawdzić stwórz plik <code>plik_o_bardzo_długiej_i_skomplikowanej_nazwie-0001x7q.txt</code>, umieść w nim jakiś tekst i wyświetl jego zawartość. Jedynie przy pierwszej komendzie będziesz musiał wpisać pełną nazwę pliku.</p>
<a class="header" href="#kopiowanie-tekstu-z-pliku-do-pliku" id="kopiowanie-tekstu-z-pliku-do-pliku"><h2>Kopiowanie tekstu z pliku do pliku</h2></a>
<p>Teraz spróbujemy skopiować zawartość plików <code>nowy_plik.txt</code> i <code>nieistniejący_plik.txt</code> do kolejnego pliku:</p>
<pre><code>$: cat nowy_plik.txt nieistniejący_plik.txt &gt; kolejny_plik.txt
$: more kolejny_plik.txt 
...albo może jednak nie żegnaj :-)
Witaj Wszechświecie!
</code></pre>
<p>Zauważ, że komenda <code>cat</code> przyjęła jako argumenty dwie nazwy plików a ich zawartość została przez nią skierowana do trzeciego pliku. Podobnie można postępować z wieloma innymi komendami odwołującymi się do plików czy katalogów.</p>
<p>Na razie może to wyglądać na niespecjalnie użyteczne sztuczki, ale niebawem okaże się, że są one bardzo przydatne w bioinformatyce.</p>
<a class="header" href="#kopiowanie-i-zmiana-nazwy-plików-i-katalogów" id="kopiowanie-i-zmiana-nazwy-plików-i-katalogów"><h2>Kopiowanie i zmiana nazwy plików i katalogów</h2></a>
<p>Kolejne dwie komendy przydatne w pracy z katalogami i plikami to <code>cp</code> i <code>mv</code>.</p>
<p><code>cp</code> służy do kopiowania, w przypadku katalogów należy użyć opcji <code>-r</code>
<code>mv</code> pozwala na zmianę nazwy, bądź przeniesienie plików i katalogów. Flaga <code>-r</code> jest konieczna dla folderów, które nie są puste:</p>
<pre><code>$: mkdir Nowy_katalog
$: touch Nowy_katalog/plik.txt
$: cp Nowy_katalog/plik.txt Nowy_katalog/skopiowany_plik.txt
$: cp Nowy_katalog Kopia_katalogu
cp: nie podano opcji -r, katalog 'Nowy_katalog' został pominięty
$: cp -r Nowy_katalog Kopia_katalogu
$: mv Kopia_katalogu Zmieniony_katalog
$: mv Zmieniony_katalog/plik.txt Zmieniony_katalog/zmieniony_plik.txt
$: mv Zmieniony_katalog/zmieniony_plik.txt .
</code></pre>
<a class="header" href="#znaki-wieloznaczności" id="znaki-wieloznaczności"><h2>Znaki wieloznaczności</h2></a>
<p>Znaki wieloznaczności (ang. <em>wildcards</em>) są bardzo pomocne jeśli chcemy jednocześnie dokonać jakichś operacji na wielu plikach albo gdy dokładna nazwa nie musi być podana. Zobaczmy na przykładzie jak to działa:</p>
<p>Wykonaj polecenia:</p>
<pre><code>$: mkdir Wildcards
$: cd Wildcards/
$: touch plik.txt plik1.txt plik2.txt plik22.txt plik1.md plik.txt
$: ls 
$: ls *
$: ls *.txt
$: ls plik.*
$: ls plik1.*
$: ls plik?.*
$: ls plik??.*
$: ls plik*.*
$: rm *.txt
$: ls
</code></pre>
<p>Przyjrzyj się wynikom komend, zastanów się jakie znaczenie mają znaki <code>*</code> i <code>?</code>.</p>
<p>Sesja powinna wyglądać tak:</p>
<pre><code>$: mkdir Wildcards
$: cd Wildcards/
$: touch plik.txt plik1.txt plik2.txt plik22.txt plik1.md plik.txt
$: ls 
plik1.md  plik1.txt  plik22.txt  plik2.txt  plik.txt
$: ls *
plik1.md  plik1.txt  plik22.txt  plik2.txt  plik.txt
$: ls *.txt
plik1.txt  plik22.txt  plik2.txt  plik.txt
$: ls plik.*
plik.txt
$: ls plik1.*
plik1.md  plik1.txt
$: ls plik?.*
plik1.md  plik1.txt  plik2.txt
$: ls plik??.*
plik22.txt
$: ls plik*.*
plik1.md  plik1.txt  plik22.txt  plik2.txt  plik.txt
$: rm *.txt
$: ls
plik1.md
</code></pre>
<p>Jak widać znak <code>*</code> oznacza ,,jakakolwiek liczba (także 0) jakichkolwiek znaków'' a znak <code>?</code> oznacza ,,jakikolwiek jeden znak''. Można ich używać z wieloma poleceniami operującymi na plikach i katalogach, mają one także dużo szersze zastosowanie o czym będzie jeszcze mowa.</p>
<a class="header" href="#usuwanie-plików-i-katalogów" id="usuwanie-plików-i-katalogów"><h2>Usuwanie plików i katalogów</h2></a>
<p>Wiemy już jak utworzyć plik i folder, czas dowiedzieć się jak je usunąć. Do usuwania służy komenda <code>rm</code>:</p>
<pre><code>$: rm kolejny_plik.txt
$: ls
nieistniejący_plik.txt  nowy_plik.txt
</code></pre>
<p>Teraz spróbujemy usunąć katalog:</p>
<pre><code>$: cd ..
$: rm Proba
rm: nie można usunąć 'Proba': Jest katalogiem
</code></pre>
<p>Jak widać tu też trzeba użyć opcji <code>-r</code>:</p>
<pre><code>$: rm -r Proba
$: ls
Desktop  Dokumenty  Muzyka  Obrazy  Pobrane  Publiczny  Szablony  Wideo
</code></pre>
<a class="header" href="#jeszcze-o-tworzeniu-plików-i-katalogów" id="jeszcze-o-tworzeniu-plików-i-katalogów"><h2>Jeszcze o tworzeniu plików i katalogów</h2></a>
<p>Czasem chcemy otworzyć katalog od razu z podkatalogiem, wtedy przy komendzie <code>mkdir</code> używamy opcji <code>-p</code>:</p>
<pre><code>$: mkdir -p BADANIA/Rumex/DANE
$: tree BADANIA
BADANIA
└── Rumex
    └── DANE
</code></pre>
<p>Komenda <code>tree</code> pokazuje zawartość katalogu w formie drzewa (spróbuj <code>tree ~</code>). Może nie być zainstalowana w systemie, wtedy trzeba ją doinstalować (dla Debiana i pochodnych dystrybucji: <code>sudo apt-get install tree</code>).</p>
<p>A co jeśli chcemy stworzyć jeszcze kilka podkatalogów za jednym razem?</p>
<pre><code>$: rm -r BADANIA
$: mkdir -p BADANIA/Rumex/{DANE/sekwencje,INFORMACJE,ANALIZY}
$: tree BADANIA
BADANIA
└── Rumex
    ├── ANALIZY
    ├── DANE
    │   └── sekwencje
    └── INFORMACJE
</code></pre>
<a class="header" href="#pobieranie-plików-z-linii-komend" id="pobieranie-plików-z-linii-komend"><h2>Pobieranie plików z linii komend</h2></a>
<p>Wpisz w przeglądarce adres:</p>
<p><code>http://ggoralski.pl/files/filogenetyka-data/Orobanchaceae-trnL-trnF-aligned.fasta</code></p>
<p>Pokaże się plik z wyrównanymi sekwencjami w formacie <code>FASTA</code> (który omawiałem w części teoretycznej w lekcji <a href="cwiczenia/../wyklady/02-Podstawy_filogenetyki.html">Podstawy filogenetyki</a>).</p>
<p>Gdybyśmy chcieli pobrać ten plik, można by użyć odpowiedniej opcji z menu przeglądarki pozwalającej zapisać stronę. Ale jest to dobry przykład, żeby poznać sposoby pobierania plików z linii komend. Do najczęściej stosowanych w tym celu programów należą <code>curl</code> i <code>wget</code>.</p>
<p>Stwórz katalog <code>Pobieranie</code> a następnie wykonaj komendę:</p>
<pre><code>$: curl http://ggoralski.pl/files/filogenetyka-data/Orobanchaceae-trnL-trnF-aligned.fasta
</code></pre>
<p>W oknie terminala pokaże się zawartość pliku. Jeśli chcemy go zapisać trzeba ją przekierować do pliku:</p>
<pre><code>$: curl http://ggoralski.pl/files/filogenetyka-data/Orobanchaceae-trnL-trnF-aligned.fasta &gt; sekwencje.fasta
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  9254  100  9254    0     0   9254      0  0:00:01 --:--:--  0:00:01 73444
$: ls
sekwencje.fasta
</code></pre>
<p>Sprawdź komendą <code>more</code> zawartość utworzonego pliku</p>
<p>Teraz użyjemy <code>wget</code>:</p>
<pre><code>$: wget http://ggoralski.pl/files/filogenetyka-data/Orobanchaceae-trnL-trnF-aligned.fasta
--2017-12-16 15:51:06--  http://ggoralski.pl/files/filogenetyka-data/Orobanchaceae-trnL-trnF-aligned.fasta
Translacja ggoralski.pl (ggoralski.pl)... 87.98.239.3
Łączenie się z ggoralski.pl (ggoralski.pl)|87.98.239.3|:80... połączono.
Żądanie HTTP wysłano, oczekiwanie na odpowiedź... 200 OK
Długość: 9254 (9,0K)
Zapis do: `Orobanchaceae-trnL-trnF-aligned.fasta'

Orobanchaceae-trnL-trnF 100%[==============================&gt;]   9,04K  --.-KB/s     w 0,003s  

2017-12-16 15:51:06 (2,56 MB/s) - zapisano `Orobanchaceae-trnL-trnF-aligned.fasta' [9254/9254]

$: ls -l
razem 28
-rw-r--r-- 1 grzeg grzeg 9254 gru 16 15:34 Orobanchaceae-trnL-trnF-aligned.fasta
-rw-r--r-- 1 grzeg grzeg 9254 gru 16 15:50 sekwencje.fasta
</code></pre>
<p>Jak widać jedną z różnic pomiędzy oboma programami jest to, że <code>curl</code> domyślnie wyświetla zawartość pobieranego pliku w terminalu a <code>wget</code> zapisuje go pod oryginalną nazwą. O innych różnicach można poczytać np. <a href="https://daniel.haxx.se/docs/curl-vs-wget.html">tu</a> albo w manualach i pomocy (<code>man curl</code>, <code>man wget</code>, <code>curl -h</code>, <code>wget -h</code>).</p>
<p><a href="cwiczenia/../README.html">← Spis treści</a></p>
<a class="header" href="#praca-z-plikami-tekstowymi-w-linii-komend" id="praca-z-plikami-tekstowymi-w-linii-komend"><h1>Praca z plikami tekstowymi w linii komend</h1></a>
<a class="header" href="#dlaczego-to-takie-ważne" id="dlaczego-to-takie-ważne"><h2>Dlaczego to takie ważne?</h2></a>
<p>Jak już wspominałem, praca bioinformatyka to w dużej mierze, o ile nie przede wszystkim praca z plikami tekstowymi. W <a href="cwiczenia/11-praca_w_linuksie.html">poprzedniej lekcji</a> pokazałem jak umieścić tekst w pliku przy pomocy operatorów <code>&gt;</code> oraz <code>&gt;&gt;</code> a także jak wyświetlić zawartość pliku używając komend <code>more</code>, <code>less</code> i <code>cat</code>. Linux oferuje jednak znacznie więcej narzędzi pozwalających na efektywną pracę z plikami tekstowymi bez uciekania się do pomocy edytorów tekstu (na które też przyjdzie pora). Poniżej pokażę wybrane możliwości niektórych z nich. Warto jednak samodzielnie poszerzyć wiedzę na ten temat, ponieważ potrafią znacznie usprawnić i przyspieszyć pracę.</p>
<p>W terminalu utwórz katalog <code>Pliki_tekstowe</code> i wejdź do niego. Używając polecenia <code>curl</code> lub <code>wget</code> pobierz plik:</p>
<p><code>http://ggoralski.pl/files/filogenetyka-data/Orobanchaceae-trnL-trnF-aligned.fasta</code></p>
<a class="header" href="#liczenie-zawartości-i-wyświetlanie-części-pliku---polecenia-wc-head-tail" id="liczenie-zawartości-i-wyświetlanie-części-pliku---polecenia-wc-head-tail"><h2>Liczenie zawartości i wyświetlanie części pliku - polecenia <code>wc</code>, <code>head</code>, <code>tail</code>.</h2></a>
<p>Wykonaj polecenie:</p>
<pre><code>$: wc Orobanchaceae-trnL-trnF-aligned.fasta 
  18   18 9254 Orobanchaceae-trnL-trnF-aligned.fasta
</code></pre>
<p>Komenda <code>wc</code> wyświetla liczbę linii, słów oraz wielkość liczoną w bajtach podanego pliku. Podając odpowiednie flagi, można uzyskać tylko wybrane dane (sprawdź <code>wc --help</code>), co później wykorzystamy.
W przypadku pobranego pliku liczba linii i słów jest taka sama (18) ponieważ w opisach i sekwencjach nie występują spacje a sekwencje zostały umieszczone każda w jednej linii. Sprawdź zatem inny plik:</p>
<p><code>http://ggoralski.pl/files/filogenetyka-data/Orobanchaceae-trnL-trnF-aligned.aln</code></p>
<p>Zawiera on dopasowane sekwencje zapisane w formacie <code>CLUSTAL</code>. Zobacz jaka jest zawartość pliku a następnie sprawdź ile ma linii i słów.</p>
<p>Polecenie <code>wc</code> może odczytywać dane z wielu plików jednocześnie:</p>
<pre><code>$: wc *
  233   490 17672 Orobanchaceae-trnL-trnF-aligned.aln
   18    18  9254 Orobanchaceae-trnL-trnF-aligned.fasta
  251   508 26926 razem
</code></pre>
<p>Nie zawsze konieczne jest przeglądanie całego pliku. Czasem chcemy po prostu zobaczyć jak wygląda jego początek i koniec. Wtedy przychodzą nam z pomocą polecenia <code>head</code> i <code>tail</code>, które jak łatwo zgadnąć wyświetlają odpowiednio początek i koniec pliku:</p>
<pre><code>$: head Orobanchaceae-trnL-trnF-aligned.aln 
CLUSTAL 2.1 multiple sequence alignment


KY484464_O._teucrii                AGTTATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAAGAGAAA-GGGC
KY484493_O._flava                  AGTGATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAAGAAAAA-GGGC
KY484489_O._mayeri                 AGTGATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAATAAAAA-GGGC
KY484471_O._kochii                 AGTGATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAATAAAAA-GGGC
KY484474_O._elatior                AGTGATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAATAAAAA-GGGC
KU238865_O._coerulescens           AGTGATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAAGAAAAA-GGGC
KY484502_P._ramosa                 GGTGATAAC-TTTCAAATTCAGAGAAACTCCGGAATTAATAAAAACGGGC
$: tail Orobanchaceae-trnL-trnF-aligned.aln 
KY484464_O._teucrii                AAATG
KY484493_O._flava                  AAATG
KY484489_O._mayeri                 AAATG
KY484471_O._kochii                 AAATG
KY484474_O._elatior                AAATG
KU238865_O._coerulescens           GAATG
KY484502_P._ramosa                 GAATG
KY484503_P._purpurea               GAATG
KX524675_Lindenbergia_siniaca      GAATG
                                    ****
</code></pre>
<p>Liczbę wyświetlanych linii można dostosować używając flagi <code>-n</code>:</p>
<pre><code>$: head -n 5 Orobanchaceae-trnL-trnF-aligned.aln 
CLUSTAL 2.1 multiple sequence alignment


KY484464_O._teucrii                AGTTATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAAGAGAAA-GGGC
KY484493_O._flava                  AGTGATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAAGAAAAA-GGGC
$: tail -n 5 Orobanchaceae-trnL-trnF-aligned.aln 
KU238865_O._coerulescens           GAATG
KY484502_P._ramosa                 GAATG
KY484503_P._purpurea               GAATG
KX524675_Lindenbergia_siniaca      GAATG
                                    ****
</code></pre>
<a class="header" href="#grep---wyszukiwanie-w-pliku-tekstowym" id="grep---wyszukiwanie-w-pliku-tekstowym"><h2><code>grep</code> - wyszukiwanie w pliku tekstowym</h2></a>
<p>Narzędzie <code>grep</code> z pewnością należy do najbardziej użytecznych programów do pracy z plikami tekstowymi. Służy do wynajdywania w plikach danego ciągu znaków.</p>
<p>W katalogu z pobranymi (patrz wyżej) plikami wykonaj polecenie:</p>
<pre><code>$: grep Lindenbergia Orobanchaceae-trnL-trnF-aligned.fasta 
&gt;KX524675_Lindenbergia_siniaca
</code></pre>
<p>W podanym pliku został znaleziony ciąg znaków <code>Lindenbergia</code> a następnie linia w którym się znajdował została wyświetlona. Jeśli znaleziony fragment nie wyświetla się w innym kolorze niż pozostała część linii to można to uzyskać podając opcję <code>--color=AUTO</code>, np. <code>grep --color=AUTO Lindenbergia Orobanchaceae-trnL-trnF-aligned.fasta</code>.</p>
<p>Można przeszukać od razu wiele plików np. używając znaków wieloznacznych, uzyskamy także informację w jakim pliku znaleziono dopasowanie:</p>
<pre><code>$: grep Lindenbergia *          

Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      AGTGATAAC-TTTCAAATTCAGAGAAACCCCGGAATTAAAAAAGG-GGGC
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      AATCCTGAGCCAAATCCTGT-----TTTCTCAAAACAAA-G--------A
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      C-AAAAATAAAGGATAGGTGCAGAGACTCAACGGAAGCTGTTCTAAC---
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      -AAATGGAGTTGATTGCGCCGGTAGAGGAATCTTTCCATCGAAACTTCGG
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      AAAGGATGAAGGATAAACGTATCTATTGAATACTATATCAAATTATTAAT
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      GATATCAAATTATTAATGATGGCCCGAATCTGTATCTGTATTTTT---TA
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      ATTTTAATATGAAAAATGGAAAAGTTAGTGTGAATTGATTCCATATTGAA
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      GAAAGAATCGAATATTCATT-------CATCAAATCATTCACTCCACAGT
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      CCGATAGATC-----TTTTAAAGAATTGATTAATCGGATGAGAATAAAGA
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      TAGAGTCCCATTC----------TACATGTCAATACCGGCAACAATGAAA
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      TTTATAGTAAGAGGAAAATCCGTCGACTTTAAAAATCGTGAGGGTTCAAG
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      TCCCTCTATCCCCAA---AAAAAGTCTATTTTACTTCCA-----------
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      -----------AAATATTTAGCCTATTTCA-----------------TTT
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      TCG-TTAGCGGTTCCAAATTCCTT--TTCTGATTC--TTTGACA--AACG
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      TATTGGGGCGT------------------AAATGACTTT-CTCTTATCAC
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      ATGTG------ATATAGAATACACATCCAAATTCAGCAAGGAATTCCTAT
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      TTGAATG------ATTCAGAATCAATAACATTACTC-AT-ACTGAAACTT
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      AGA---AAGTTCGTCTTTTTGAAGATCCAATAAATTACAGGATTTGGAGA
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      AAACTTTGTAATCTTCCCCA--TCCCTTTAATTGACATAGAGCCCAGTC-
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      ---ATCTAAT--AAAATCA------GGATGGGAATGGGATTATACATTGG
Orobanchaceae-trnL-trnF-aligned.aln:KX524675_Lindenbergia_siniaca      GAATG
Orobanchaceae-trnL-trnF-aligned.fasta:&gt;KX524675_Lindenbergia_siniaca
</code></pre>
<p>Jeśli chcemy przeszukać pliki w danym katalogu, należy użyć opcji <code>-r</code>, np.: <code>grep -r Lindenbergia SEKWENCJE</code>.</p>
<p>Narzędzia grep można użyć na przykład do sprawdzenia ile sekwencji znajduje się w pliku <code>fasta</code>. W tym celu należy znaleźć i policzyć linie zawierające znak <code>&gt;</code>. Tu jednak czyha pewna pułapka. Najbardziej oczywistą komendą wydaje się: <code>grep &gt; Orobanchaceae-trnL-trnF-aligned.fasta</code> ale jej wynik będzie taki:</p>
<pre><code>$: grep &gt; Orobanchaceae-trnL-trnF-aligned.fasta 
Składnia: grep [OPCJA]... WZORZEC [PLIK] ...
Napisz „grep --help” żeby dowiedzieć się więcej.
</code></pre>
<p>Po pierwsze polecenie ewidentnie nie zrobiło tego czego po nim oczekiwaliśmy a po drugie jeśli teraz spróbujemy wyświetlić zawartość pliku <code>Orobanchaceae-trnL-trnF-aligned.fasta</code> to okaże się, że jest pusty. Dlaczego?</p>
<p>Przypomnijmy sobie, że operator <code>&gt;</code> służy do przekazania tekstu do pliku. Zatem polecenie <code>grep &gt; Orobanchaceae-trnL-trnF-aligned.fasta</code> uruchomiło polecenie <code>grep</code> (z nieprawidłową składnią) a wynik jego działania zapisało w pliku, w którym chcieliśmy szukać znaków <code>&gt;</code>, wymazując jego poprzednią zawartość. Jest to bardzo łatwy do popełnienia błąd, który może się skończyć utratą wyników pracy! Jak więc należy prawidłowo wyszukać znaku <code>&gt;</code>? Umieszczając go w cudzysłowach:</p>
<pre><code>$: grep &quot;&gt;&quot; Orobanchaceae-trnL-trnF-aligned.fasta
&gt;KY484464_O._teucrii
&gt;KY484493_O._flava
&gt;KY484489_O._mayeri
&gt;KY484471_O._kochii
&gt;KY484474_O._elatior
&gt;KU238865_O._coerulescens
&gt;KY484502_P._ramosa
&gt;KY484503_P._purpurea
&gt;KX524675_Lindenbergia_siniaca
</code></pre>
<blockquote>
<p>Zadanie: Zastanów się, co trzeba zrobić, żeby uzyskać nazwy sekwencji w osobnym pliku?</p>
</blockquote>
<p>No dobrze, teraz możemy policzyć wyświetlone linie ale wolelibyśmy, żeby komputer sam je policzył. Co prawda istnieje odpowiednia opcja programu <code>grep</code>, która to robi (znajdź ją), ale jest to dobra okazja, żeby pokazać w jaki sposób można połączyć różne polecenia tak aby wykonały razem zadanie.</p>
<a class="header" href="#potoki-czyli-łączymy-polecenia" id="potoki-czyli-łączymy-polecenia"><h2>Potoki, czyli łączymy polecenia.</h2></a>
<p>Chcemy policzyć linie, w których znajduje się znak <code>&gt;</code>. Mamy do dyspozycji jedno narzędzie, które wyszukuje odpowiednie linie (<code>grep</code>) i drugie, które liczy linie (<code>wc</code>). Trzeba je zatem odpowiednio połączyć w jeden ,,taśmociąg''. Wykorzystamy do tego potoki (ang. <em>pipe</em>) - wynik działania <code>grep</code> (strumień) zostanie skierowany do <code>wc</code>. Do łączenia w ten sposób poleceń służy operator <code>|</code>. Polecenia <code>wc</code> użyjemy z flagą <code>-l</code>, która zwraca liczbę linii.</p>
<pre><code>$: grep &quot;&gt;&quot; Orobanchaceae-trnL-trnF-aligned.fasta | wc -l
9
</code></pre>
<p>Wiemy, że w pliku mamy 9 sekwencji.</p>
<p>Teraz poznamy kolejną opcję <code>-v</code>, która pozwala ,,odwrócić'' dopasowanie, czyli zwrócić linie, w których <strong>nie występuje</strong> dopasowanie i połączymy dwa polecenia <code>grep</code> tak, aby uzyskać listę próbek, które <strong>nie zawierają</strong> ciągu ,,Lindenbergia'':</p>
<pre><code>$: grep -v Lindenbergia Orobanchaceae-trnL-trnF-aligned.fasta | grep &quot;&gt;&quot;
&gt;KY484464_O._teucrii
&gt;KY484493_O._flava
&gt;KY484489_O._mayeri
&gt;KY484471_O._kochii
&gt;KY484474_O._elatior
&gt;KU238865_O._coerulescens
&gt;KY484502_P._ramosa
&gt;KY484503_P._purpurea
</code></pre>
<p>Jak widać, w drugim wywołaniu plecenia <code>grep</code> nie podaliśmy nazwy pliku, tekst do przeanalizowania został przekazany za pomocą potoku.</p>
<p>Wynik możemy przekazać dalej, na przykład do polecenia <code>sort</code>, które jak nazwa wskazuje sortuje linie tekstu:</p>
<pre><code>$: grep -v Lindenbergia Orobanchaceae-trnL-trnF-aligned.fasta | grep &quot;&gt;&quot; | sort
&gt;KU238865_O._coerulescens
&gt;KY484464_O._teucrii
&gt;KY484471_O._kochii
&gt;KY484474_O._elatior
&gt;KY484489_O._mayeri
&gt;KY484493_O._flava
&gt;KY484502_P._ramosa
&gt;KY484503_P._purpurea
</code></pre>
<p>Można oczywiście uzyskaną posortowaną listę nazw sekwencji do pliku:</p>
<pre><code>$: grep -v Lindenbergia Orobanchaceae-trnL-trnF-aligned.fasta | grep &quot;&gt;&quot; | sort &gt; posortowane.txt
</code></pre>
<p>Wykonaj powyższe polecenie i sprawdź zawartość pliku <code>posortowane.txt</code>.</p>
<a class="header" href="#xargs---przekazanie-argumentów-do-kolejnego-polecenia" id="xargs---przekazanie-argumentów-do-kolejnego-polecenia"><h2><code>xargs</code> - przekazanie argumentów do kolejnego polecenia</h2></a>
<p>Narzędzie <code>xargs</code> pozwala przekazać kolejnemu poleceniu argumenty otrzymane ze standardowego wejścia, czyli np. przez potok. Najłatwiej pokazać to na przykładzie:</p>
<pre><code>ls *.fasta | xargs cat &gt; wszystkie.fasta
</code></pre>
<p>Najpierw mamy polecenie <code>ls *fasta</code>, które zwraca listę plików o przedłużeniu <code>fasta</code> znajdujących się w bieżącym katalogu. Jest ona przekazywana przez potok do polecenia <code>xargs</code>, które przekazuje je poleceniu <code>cat</code> jako kolejne argumenty. Jak wiemy polecenie <code>cat</code> zwraca zawartość pliku, którego nazwa jest argumentem do standardowego wyjścia, którym może być ekran, ale w tym przypadku, przekierowujemy ją do pliku <code>wszystkie.fasta</code>. Tak więc całe polecenie umieszcza zawartość wszystkich plików <code>fasta</code> w pliku wynikowym. W tym przypadku można by było po prostu wykonać komendę:</p>
<pre><code>cat *.fasta &gt; wszystkie.fasta
</code></pre>
<p>ale jak się później przekonamy, nie zawsze tak łatwo jest pominąć <code>xargs</code> i program ten bywa bardzo pożyteczny.</p>
<a class="header" href="#sed---przetwarzanie-tekstu" id="sed---przetwarzanie-tekstu"><h2><code>sed</code> - przetwarzanie tekstu</h2></a>
<p>Kolejne bardzo użyteczne narzędzie to <code>sed</code>. Pozwala na edycję strumienia danych. Jedną z zalet używania tego typu programów jest możliwość uzyskiwania i modyfikacji danych z plików bez konieczności ich otwierania od razu w całości, jak to ma miejsce w edytorach tekstu. Nie mam to wielkiego znaczenia w przypadku niewielkich plików ale na przykład pliki uzyskiwane przy sekwencjonowaniu genomów mogą mieć wielkość wielu gigabajtów co w znacznym stopniu utrudnia pracę nad nimi w edytorach tekstu. Nawet jednak dla małych plików praca z linii komend może być po prostu znacznie szybsza.</p>
<p>Prosty schemat użycia <code>sed</code> wygląda tak:</p>
<pre><code>sed 's/szukany/zmieniony/g' plik
</code></pre>
<p>W pliku <code>plik</code> zmieniane są wszystkie ciągi znaków <code>szukany</code> na <code>zmieniony</code>. Bez opcji <code>g</code> (po trzecim ukośniku) zmienione zostanie tylko pierwsze wystąpienie szukanego ciągu w linii. Zamiast pliku można użyć strumienia danych z innych poleceń.</p>
<pre><code>$: echo &quot;ATCTTGGATCG&quot; | sed 's/T/U/g'
AUCUUGGAUCG
</code></pre>
<p>Kilka przykładów, wykorzystamy utworzony powyżej plik <code>posortowane.txt</code>, najpierw sprawdźmy co zawiera:</p>
<pre><code>$: more posortowane.txt 
&gt;KU238865_O._coerulescens
&gt;KY484464_O._teucrii
&gt;KY484471_O._kochii
&gt;KY484474_O._elatior
&gt;KY484489_O._mayeri
&gt;KY484493_O._flava
&gt;KY484502_P._ramosa
&gt;KY484503_P._purpurea
</code></pre>
<p>Zamiana znaków '_' na spacje:</p>
<pre><code>sed 's/_/ /g' posortowane.txt
&gt;KU238865 O. coerulescens
&gt;KY484464 O. teucrii
&gt;KY484471 O. kochii
&gt;KY484474 O. elatior
&gt;KY484489 O. mayeri
&gt;KY484493 O. flava
&gt;KY484502 P. ramosa
&gt;KY484503 P. purpurea
</code></pre>
<p>Usuwane znaku <code>&gt;</code>, ponieważ występuje on tylko raz w linii, opcja <code>g</code> jest zbędna:</p>
<pre><code>sed 's/&gt;//' posortowane.txt 
KU238865_O._coerulescens
KY484464_O._teucrii
KY484471_O._kochii
KY484474_O._elatior
KY484489_O._mayeri
KY484493_O._flava
KY484502_P._ramosa
KY484503_P._purpurea
</code></pre>
<p>Połączmy teraz dwa powyższe i zmieńmy skróty <code>P.</code> oraz <code>O.</code> na pełne nazwy rodzajowe:</p>
<pre><code>$: sed 's/&gt;//' posortowane.txt | sed 's/_/ /g' | sed 's/O\./Orobanche/' | sed 's/P\./Phelipanche/'

KU238865 Orobanche coerulescens
KY484464 Orobanche teucrii
KY484471 Orobanche kochii
KY484474 Orobanche elatior
KY484489 Orobanche mayeri
KY484493 Orobanche flava
KY484502 Phelipanche ramosa
KY484503 Phelipanche purpurea
</code></pre>
<p>Zauważ, że zamiast napisać <code>s/O./Orobanche/</code> napisałem <code>s/O\./Orobanche/</code>. Co prawda w tym przypadku oba warianty zwrócą taki sam wynik, ale sposób ich działania jest nieco odmienny, o czym za chwilę.</p>
<p>Wynik działania <code>sed</code> często chcemy zapisać w pliku. Można w tym celu użyć znaku <code>&gt;</code>:</p>
<pre><code>$: sed 's/&gt;//' posortowane.txt | sed 's/_/ /g' | sed 's/O\./Orobanche/' | sed 's/P\./Phelipanche/' &gt; zmieniony.txt
</code></pre>
<p>Teraz można wykonać polecenie:</p>
<pre><code>$: mv zmieniony.txt posortowane.txt
</code></pre>
<p>Jeśli chcemy bezpośrednio zmienić plik oryginalny, należy użyć opcji -i ale wtedy nie użyjemy potoków, możemy natomiast zgrupować formuły zmian razem oddzielając je średnikami (jeśli to nie działa spróbuj dodać opcję <code>-e</code>):</p>
<pre><code>sed -i 's/&gt;//;s/_/ /g;s/O\./Orobanche/;s/P\./Phelipanche/' posortowane.txt
</code></pre>
<p>Można też wykonać kolejno operacje:</p>
<pre><code>$: sed -i 's/&gt;//' posortowane.txt
$: sed -i 's/_/ /g' posortowane.txt
$: sed -i 's/O\./Orobanche/' posortowane.txt
$: sed -i 's/P\./Phelipanche/' posortowane.txt
</code></pre>
<p>Należy uważać ze zmianą oryginalnego pliku, lepiej najpierw sprawdzić czy wpisywana formuła edycji działa prawidłowo a dopiero później użyć opcji <code>-i</code>.</p>
<a class="header" href="#wyrażenia-regularne" id="wyrażenia-regularne"><h2>Wyrażenia regularne</h2></a>
<p>Wyrażenia regularne są bardzo użyteczne w bioinformatyce, ponieważ są potężnym narzędziem ułatwiającym pracę z plikami tekstowymi i strumieniami tekstu czy ogólniej z ciągami znaków. Dzięki nim można opisać z różnym stopniem ogólności ciągi znaków, czy ich kategorie aby później je wyświetlić, usunąć czy zmodyfikować. Wykorzystuje się je w takich narzędziach jak <code>grep</code>, <code>sed</code> i wielu innych z dobrymi edytorami tekstu włącznie (np. <code>vim</code>).</p>
<p>Przyjrzyjmy się ponownie zmodyfikowanemu plikowi <code>posortowane.txt</code>.</p>
<pre><code>$: more posortowane.txt 
KU238865 Orobanche coerulescens
KY484464 Orobanche teucrii
KY484471 Orobanche kochii
KY484474 Orobanche elatior
KY484489 Orobanche mayeri
KY484493 Orobanche flava
KY484502 Phelipanche ramosa
KY484503 Phelipanche purpurea
</code></pre>
<p>Przypuśćmy, że chcemy uzyskać jedynie listę organizmów, bez numerów GenBank-u. Można by je po kolei usuwać, ale znaczne wygodniej będzie użyć wyrażeń regularnych:</p>
<pre><code>$: sed 's/^[[:alnum:]]\+[[:space:]]//' posortowane.txt
Orobanche coerulescens
Orobanche teucrii
Orobanche kochii
Orobanche elatior
Orobanche mayeri
Orobanche flava
Phelipanche ramosa
Phelipanche purpurea
</code></pre>
<p>Zanim wyjaśnię jak i dlaczego to działa, trochę teorii.</p>
<p>W wyrażeniach regularnych możemy stosować znaki rozumiane dosłownie (litery, cyfry, spacje, niektóre inne znaki) oraz znaki specjalne (<code>$</code>, <code>*</code>, <code>.</code>, <code>[</code>, <code>\</code>, oraz <code>^</code>)i wyrażenia, które pozwalają na przykład opisać kategorie znaków, ich liczbę, położenie itp. Na przykład <code>ATG</code> oznacza ciąg <code>ATG</code> ale <code>[ATG]</code> oznacza <code>A</code> lub <code>T</code> lub <code>G</code>. Specjalne znaczenie ma znak <code>\</code>, który zmienia znaczenie następnego znaku - na przykład oznacza, że następujący po nim znak specjalny powinien być rozumiany dosłownie albo, że zwykły znak ma znaczenie specjalne.</p>
<p>W poniższej tabeli znajdują się <strong>niektóre</strong> przykłady:</p>
<table><thead><tr><th align="center"> <strong>Wyrażenie</strong>  </th><th align="left"> <strong>Znaczenie</strong> </th><th align="center"> <strong>Przykład</strong> </th><th align="left"> <strong>Znaczenie przykładu</strong> </th></tr></thead><tbody>
<tr><td align="center"> <code>*</code>        </td><td align="left"> zero lub więcej wystąpień wyrażenia </td><td align="center"> <code>T*</code> </td><td align="left"> zero lub więcej liter <code>T</code> </td></tr>
<tr><td align="center"> <code>\+</code>       </td><td align="left"> jedno lub więcej wystąpień wyrażenia </td><td align="center"> <code>T\+</code> </td><td align="left"> jedna lub więcej litera <code>T</code> </td></tr>
<tr><td align="center"> <code>\?</code>       </td><td align="left"> zero lub jedno wystąpień wyrażenia </td><td align="center"> <code>T\?</code> </td><td align="left"> zero lub jedna litera <code>T</code> </td></tr>
<tr><td align="center"> <code>\{i\}</code>    </td><td align="left"> dokładnie <code>i</code> wystąpień wyrażenia </td><td align="center"> <code>T\{3\}</code> </td><td align="left"> trzy znaki <code>T</code></td></tr>
<tr><td align="center"> <code>\{i,j\}</code>  </td><td align="left"> pomiędzy <code>i</code> a <code>j</code> wystąpień wyrażenia </td><td align="center"> <code>T\{3,5\}</code> </td><td align="left"> pomiędzy 3 a 5 znaków <code>T</code></td></tr>
<tr><td align="center"> <code>\{i,\}</code>   </td><td align="left"> <code>i</code> lub więcej wystąpień wyrażenia </td><td align="center"> <code>T\{3,\}</code> </td><td align="left"> przynajmniej 3 znaki <code>T</code></td></tr>
<tr><td align="center"> <code>.</code>        </td><td align="left"> jakikolwiek znak </td><td align="center"> <code>.\{3\}</code> </td><td align="left"> trzy dowolne znaki </td></tr>
<tr><td align="center"> <code>^</code>        </td><td align="left"> początek linii </td><td align="center"> <code>^T</code> </td><td align="left"> znak <code>T</code> występujący na początku linii </td></tr>
<tr><td align="center"> <code>$</code>        </td><td align="left"> koniec linii </td><td align="center"> <code>T$</code> </td><td align="left"> znak <code>T</code> na końcu linii </td></tr>
<tr><td align="center"> <code>[znaki]</code>  </td><td align="left"> jakikolwiek znak z zestawu znaków </td><td align="center"> <code>[TGA]</code> </td><td align="left"> <code>T</code> lub <code>G</code> lub <code>A</code> </td></tr>
<tr><td align="center"> <code>[x-y]</code>    </td><td align="left"> jakikolwiek znak z zakresu x do y (litery, cyfry)</td><td align="center"> <code>[A-Z]</code> </td><td align="left"> duża litera </td></tr>
<tr><td align="center">            </td><td align="left">          </td><td align="center"> <code>[a-z 0-9]</code> </td><td align="left"> mała litera lub cyfra </td><td> </td></tr>
<tr><td align="center"> <code>[^znaki]</code> </td><td align="left"> jakikolwiek znak z poza zestawu znaków </td><td align="center"> <code>[^TGA]</code> </td><td align="left"> jakikolwiek znak oprócz <code>T</code>, <code>G</code> i <code>A</code> </td></tr>
<tr><td align="center"> <code>\znak_specjalny</code> </td><td align="left"> znak specjalny (<code>$</code>, <code>*</code>, <code>.</code>, <code>[</code>, <code>\</code>, <code>^</code>) rozumiany dosłownie </td><td align="center"> <code>\^</code> </td><td align="left"> znak <code>^</code> (a nie początek linii) </td></tr>
<tr><td align="center"> <code>\(wyrażenie\)</code> </td><td align="left"> wyrażenie grupujące,  dopasowany łańcuch można później wykorzystać, np. wstawiając go w inne miejsce </td><td align="center"> </td><td align="left"> </td></tr>
<tr><td align="center"> <code>\n</code>       </td><td align="left"> znak nowej linii </td><td align="center">  </td><td align="left"> </td></tr>
<tr><td align="center"> <code>\t</code>       </td><td align="left"> znak tabulatora </td><td align="center">  </td><td align="left"> </td></tr>
<tr><td align="center"> <code>[[:alnum:]]</code> </td><td align="left"> znak alfanumeryczny (litery lub cyfry)  </td><td align="center">  </td><td align="left"> </td></tr>
<tr><td align="center"> <code>[[:alpha:]]</code> </td><td align="left"> litera </td><td align="center"> </td><td align="left"> </td></tr>
<tr><td align="center"> <code>[[:digit:]]</code> </td><td align="left"> cyfra </td><td align="center"> </td><td align="left"> </td></tr>
<tr><td align="center"> <code>[[:blank:]]</code> </td><td align="left"> spacja lub tabulator </td><td align="center"> </td><td align="left"> </td></tr>
<tr><td align="center"> <code>[[:space:]]</code> </td><td align="left"> znak odstępu (w tym nowej linii) </td><td align="center"> </td><td align="left"> </td></tr>
</tbody></table>
<p>Zauważ, że znaczenie znaku <code>^</code> zmienia się w zależności od kontekstu - oznacza on początek linii lub negację zakresu znaków.</p>
<p>Wróćmy teraz do pliku <code>posortowane.txt</code> i zastanówmy się jak można opisać numery GenBank-u?</p>
<pre><code>$: more posortowane.txt 
KU238865 Orobanche coerulescens
KY484464 Orobanche teucrii
KY484471 Orobanche kochii
KY484474 Orobanche elatior
KY484489 Orobanche mayeri
KY484493 Orobanche flava
KY484502 Phelipanche ramosa
KY484503 Phelipanche purpurea
</code></pre>
<p>Jest to ciąg znaków zaczynający się na początku linii, zawierający litery i cyfry (znali alfanumeryczne) po którym występuje spacja (jeden ze znaków odstępu).</p>
<p>Teraz poprzednio użyte wyrażenie powinno być bardziej zrozumiałe:</p>
<pre><code>$: sed 's/^[[:alnum:]]\+[[:space:]]//' posortowane.txt
</code></pre>
<p><code>^</code> początek linii <code>[[:alnum:]]\+</code> jeden lub więcej znaków alfanumerycznych <code>[[:space:]]</code> znak odstępu.</p>
<blockquote>
<p>Zadanie: Spróbuj usunąć numery GenBank-u używając innego wyrażenia.</p>
</blockquote>
<p>Po przejrzeniu powyższej tabeli powinno być jasne, dlaczego powyżej zamiast napisać <code>s/O./Orobanche/</code> napisałem <code>s/O\./Orobanche/</code>. Kropka oznacza jakikolwiek znak, ponieważ także oznacza kropkę oba wyrażenia zadziałają w tym przypadku (!) tak samo, ale jeśli chcemy być pewni, że dopasujemy znak <code>.</code>, to powinniśmy użyć przed niem znaku <code>\</code>, co spowoduje, że znak zostanie odczytany dosłownie.</p>
<p>Zamieszczone w tabeli wyrażenie <code>\(wyrażenie\)</code> zapewne wydaje się niejasne. Pokażę zatem na przykładzie jak może być wykorzystane. Tym razem zadaniem będzie przeniesienie numeru GenBank-u na koniec linii. Można to zrobić tak:</p>
<pre><code>$: sed 's/^\([[:alnum:]]\+[[:space:]]\)\(.*\)/\2 \1/' posortowane.txt
Orobanche coerulescens KU238865 
Orobanche teucrii KY484464 
Orobanche kochii KY484471 
Orobanche elatior KY484474 
Orobanche mayeri KY484489 
Orobanche flava KY484493 
Phelipanche ramosa KY484502 
Phelipanche purpurea KY484503
</code></pre>
<p>Powyżej wykorzystałem dwa wyrażenia grupujące. Pierwszy z nich obejmuje dopasowanie numeru GenBank-u (oraz spację), drugie pozostałą część tekstu (<code>.*</code> oznacza zero lub więcej dowolnych znaków. Po drugim ukośniku odwołuję się do wcześniej znalezionych dopasowań: <code>\1</code> oznacza pierwsze dopasowanie, <code>\2</code> drugie dopasowanie. Umieszczając je w kolejności <code>\2 \1</code> umieściłem pierwsze dopasowanie po drugim.</p>
<p>Zamianę można ograniczyć do linii, w których znajduje się inne dopasowanie. Na przykład:</p>
<pre><code>$: sed &quot;/^&gt;/ s/A/0/g&quot; plik.fasta
</code></pre>
<p>Zamieni znaki <code>A</code> na <code>0</code> w liniach, które zaczynają się od <code>&gt;</code>.</p>
<p>Z kolei polecenie:</p>
<pre><code>$: sed &quot;/^&gt;/! s/A/0/g&quot; plik.fasta
</code></pre>
<p>Dokona zamiany w liniach, które <strong>nie</strong> rozpoczynają się od <code>&gt;</code>.</p>
<p>Jeśli przed <code>s</code> w poleceniu umieścimy liczbę, będzie się ono odnosiło do linii w pliku o podanym numerze. Możemy np. w ten sposób dodać tekst w pierwszej linii w pliku <code>plik.txt</code>:</p>
<pre><code>sed -i &quot;1s/^/Tytuł dzieła\n/&quot; plik.txt
</code></pre>
<p>Aby usunąć linie, w których znajduje się dany wzorzec stosujemy następującą komendę:</p>
<pre><code>sed '/wzorzec/d' plik
</code></pre>
<p>Na przykład poniższa komenda usunie wszystkie linie z opisami sekwencji z pliku <code>sekwencje.fasta</code></p>
<pre><code>sed -i '/^&gt;/d' sekwencje.fasta
</code></pre>
<a class="header" href="#tr---zmiana-i-usuwanie-znaków" id="tr---zmiana-i-usuwanie-znaków"><h2><code>tr</code> - zmiana i usuwanie znaków</h2></a>
<p>Program <code>tr</code> ma podobne zastosowanie do <code>sed</code>-a, specjalizuje się jednak w zamianie pojedynczych znaków.</p>
<p>Używamy go w ten sposób:</p>
<pre><code>tr opcje znaki1 znaki2
</code></pre>
<p><code>znaki1</code> - to zestaw znaków które zmieniamy
<code>znaki2</code> - to zestaw znaków na które zmieniamy</p>
<p>Pokażę to na kilku przykładach.</p>
<p>Zamiana <code>*</code> na <code>-</code></p>
<pre><code>$: echo &quot;AGGC*TT&quot; | tr &quot;*&quot; &quot;-&quot;

AGGC-TT
</code></pre>
<p>Usunięcie znaków <code>-</code>. Tak można łatwo usunąć z sekwencji znaki oznaczające indele.</p>
<pre><code>$: echo &quot;AG--GC-TT&quot; | tr -d &quot;-&quot;

AGGCTT
</code></pre>
<p>Zamiana <code>A</code> na <code>T</code>, <code>C</code> na <code>G</code>, <code>G</code> na <code>C</code> oraz <code>T</code> na <code>A</code>.</p>
<pre><code>$: echo &quot;AGGCTT&quot; | tr &quot;ACGT&quot; &quot;TGCA&quot; 

TCCGAA
</code></pre>
<p>W ten sposób można otrzymać łatwo sekwencję komplementarną.
Zauważ, że powyższa komenda nie zmienia sekwencji <code>ACGT</code> na <code>TGCA</code>, ale podmienia poszczególne znaki.</p>
<p><code>tr</code> nie ma możliwości bezpośredniej modyfikacji pliku, dlatego jeśli chcemy zmienić plik, użyjemy znaków przekierowania <code>&lt;</code> do pliku wejściowego i <code>&gt;</code> dla pliku wyjściowego.</p>
<p>Utwórz plik <code>sekwencje.txt</code> o zawartości:</p>
<pre><code>CGACCAGATTACGGGGCCCATTA
CGAGACATTTATATACGATATAG
AAATTTCGCGCGCAGATAGCATA
</code></pre>
<p>Teraz utworzymy dla tych krótkich sekwencji sekwencje komplementarne:</p>
<pre><code>tr &quot;ACGT&quot; &quot;TGCA&quot; &lt; sekwencje.txt &gt; sekwencje_komplementarne.txt
</code></pre>
<p>albo</p>
<pre><code>cat sekwencje.txt | tr &quot;ACGT&quot; &quot;TGCA&quot; &gt; sekwencje_komplementarne.txt
</code></pre>
<p>Otrzymujemy plik <code>sekwencje_komplementarne.txt</code>:</p>
<pre><code>GCTGGTCTAATGCCCCGGGTAAT
GCTCTGTAAATATATGCTATATC
TTTAAAGCGCGCGTCTATCGTAT
</code></pre>
<p>Teraz połączmy te sekwencje w jedną, długą. W tym celu usuniemy <code>\n</code> oznaczający znak nowej linii.</p>
<pre><code>tr -d &quot;\n&quot; &lt; sekwencje_komplementarne.txt &gt; polaczona_sekwencja_komplementarna.txt
</code></pre>
<p>Tu też oczywiście można też użyć komendy <code>cat</code> i znaku <code>|</code>:</p>
<pre><code>cat sekwencje_komplementarne.txt| tr -d &quot;\n&quot; &gt; polaczona_sekwencja_komplementarna.txt
</code></pre>
<p>Plik wynikowy, zgodnie z założeniem, posiada jedną długą sekwencję:</p>
<pre><code>GCTGGTCTAATGCCCCGGGTAATGCTCTGTAAATATATGCTATATCTTTAAAGCGCGCGTCTATCGTAT
</code></pre>
<a class="header" href="#rev---odwracanie-łańcucha-znaków" id="rev---odwracanie-łańcucha-znaków"><h2><code>rev</code> - odwracanie łańcucha znaków</h2></a>
<p>Bardzo prostym, ale użytecznym narzędziem jest <code>rev</code> (od <em>reverse</em>), który odwraca łańcuch znaków.</p>
<pre><code>$: echo &quot;ACGTTT&quot; | rev

TTTGCA
</code></pre>
<p>Teraz można sekwencję w pliku <code>polaczona_sekwencja_komplementarna.txt</code> także odwrócić. W efekcie otrzymamy sekwencję komplementarną, odwróconą.</p>
<pre><code>cat polaczona_sekwencja_komplementarna.txt | rev &gt; polaczona_sekwencja_komplementarna_odwrocona.txt
</code></pre>
<p>Cały proces łączenia przekształcania sekwencji w odwróconą i komplementarną można zmieścić w ,,jednolinijkowcu'' używając potoków i przekierowania:</p>
<pre><code>cat sekwencja.txt | tr &quot;ACGT&quot; &quot;TGCA&quot; | tr -d &quot;\n&quot; | rev &gt; sekwencja_RC.txt
</code></pre>
<a class="header" href="#uniq---usuwanie-powtórzeń" id="uniq---usuwanie-powtórzeń"><h2><code>uniq</code> - usuwanie powtórzeń</h2></a>
<p>Polecenie <code>uniq</code> pozwala na usuwanie powtarzających się linii. Na przykład chcielibyśmy otrzymać listę rodzajów z taksonów znajdujących się w pliku <code>fasta</code> ale tak, aby każda nazwa występowała tylko raz.</p>
<p>Pobierz plik:</p>
<pre><code>http://ggoralski.pl/files/filogenetyka-data/atp6-samples.fasta
</code></pre>
<p>Najpierw uzyskajmy opisy sekwencji:</p>
<pre><code>$: grep &quot;&gt;&quot; atp6-samples.fasta 
&gt;KY492922.1 Dendropicos elliotii isolate DA07 ATP6 (ATP6) gene, partial cds; mitochondrial
&gt;KY492921.1 Dendropicos stierlingi isolate ZMUC74329 ATP6 (ATP6) gene, complete cds; mitochondrial
&gt;KY492920.1 Dendropicos poecilolaemus isolate ZMUC72915 ATP6 (ATP6) gene, complete cds; mitochondrial
&gt;KY492919.1 Campethera punctuligera isolate ZMUC56174 ATP6 (ATP6) gene, complete cds; mitochondrial
&gt;KY492918.1 Campethera cailliautii isolate ZMUC56172 ATP6 (ATP6) gene, complete cds; mitochondrial
&gt;KY492917.1 Dendropicos fuscescens isolate Z34 ATP6 (ATP6) gene, complete cds; mitochondrial
&gt;KY492916.1 Campethera cailliautii isolate W45 ATP6 (ATP6) gene, complete cds; mitochondrial
&gt;KY492915.1 Chloropicus xantholophus isolate MNHN2005922 ATP6 (ATP6) gene, complete cds; mitochondrial
....
</code></pre>
<p>Jak widać opisy są nieco bardziej złożone niż w poprzednio używanym pliku, ponadto jest ich więcej (powyżej widać tylko początek listy).</p>
<p>Teraz trzeba wyodrębnić nazwy rodzajowe. W naszym pliku jest to drugi ciąg znaków alfanumerycznych. Zastanów się jak go uzyskać?</p>
<pre><code>$: grep &quot;&gt;&quot; atp6-samples.fasta | sed 's/\(^&gt;[[:alnum:]]\+\.[[:digit:]][[:space:]]\)\([[:alnum:]]\+\)\([[:space:]].\+\)/\2/' 
Dendropicos
Dendropicos
Dendropicos
Campethera
Campethera
Dendropicos
Campethera
Chloropicus
Campethera
Dendropicos
...
</code></pre>
<p>Tym razem wykorzystałem trzy wyrażenia grupujące: pierwszy oznacza numer GenBank-u (znali alfanumeryczne, kropka, cyfra) ze spacją, drugi znajduje ciąg znaków alfanumerycznych odpowiadających nazwie rodzajowej a trzeci grupuje pozostałe znaki w linii. Jak widać wykorzystujemy w dalszej części polecenia tylko drugie dopasowanie co powoduje, że zwracana jest tylko nazwa rodzajowa.
Szkopuł w tym, że nazwy te wyświetlają się wielokrotnie, a chcielibyśmy mieć listę rodzajów, taką w której każda występowałaby tylko raz. Dodajmy zatem polecenie <code>uniq</code>:</p>
<pre><code>$: grep &quot;&gt;&quot; atp6-samples.fasta | sed 's/\(^&gt;[[:alnum:]]\+\.[[:digit:]][[:space:]]\)\([[:alnum:]]\+\)\([[:space:]].\+\)/\2/' | uniq
Dendropicos
Campethera
Dendropicos
Campethera
Chloropicus
Campethera
Dendropicos
Campethera
Ipophilus
...
</code></pre>
<p>Efekt jest nie do końca zgodny z oczekiwaniami. Co prawda duplikaty zostały usunięte, ale tylko wtedy gdy znajdowały się bezpośrednio po sobie. Tak właśnie działa <code>uniq</code>. Wykorzystajmy zatem polecenie, które sortuje linie, czyli <code>sort</code>  wtedy wszystkie takie same linie znajdą się bezpośrednio przy sobie.</p>
<pre><code>$: grep &quot;&gt;&quot; atp6-samples.fasta | sed 's/\(^&gt;[[:alnum:]]\+\.[[:digit:]][[:space:]]\)\([[:alnum:]]\+\)\([[:space:]].\+\)/\2/' | sort | uniq
Campethera
Chloropicus
Cooperia
Dendropicos
Ipophilus
Paracoccidioides
Pocillopora
</code></pre>
<blockquote>
<p>Zadanie: policz ile sekwencji i ile różnych nazw rodzajowych znajduje się w pliku</p>
</blockquote>
<a class="header" href="#edytory-tekstu" id="edytory-tekstu"><h1>Edytory tekstu</h1></a>
<a class="header" href="#wybór-edytora-tekstu" id="wybór-edytora-tekstu"><h2>Wybór edytora tekstu</h2></a>
<p>Edytory tekstu, jak nazwa wskazuje, służą do edycji tekstu, zwykle w formie plików tekstowych. Nie należy mylić edytorów tekstu z procesorami tekstu (np. Word). Ponieważ praca filogenetyczna, przynajmniej w jej części bioinformatycznej, polega w dużej mierze właśnie na pracy z plikami tekstowymi, edytor należy do najważniejszych narzędzi a wybór odpowiedniego narzędzia decyduje o jej późniejszym komforcie i wydajności. Dlatego warto poświęcić chwilę czasu na jego wybór a także nieco więcej czasu na jego poznanie. Dobre edytory tekstu mają wiele funkcji, które potrafią taką pracę bardzo usprawnić.</p>
<p>Edytory można podzielić na dwie kategorie w zależności od interfejsu, poniżej podaję przykłady edytorów darmowych (o ile mi wiadomo):</p>
<ul>
<li>Pracujące w trybie tekstowym, mogą mieć także interfejs graficzny, zwykle wieloplatformowe, np.: Pico, Nano, JED, Emacs, Vim.</li>
<li>Pracujące w trybie graficznym, często dla jednego systemu operacyjnego np.: Atom (Linux, Mac OS X, Windows), TextMate2 (Mac OS X), Notepad++ (Windows), Notepadqq (Linux), Gedit (Linux, Mac OS X, Windows), Kate (Linux, Mac OS X, Windows), TextWrangler (Mac OS X)</li>
</ul>
<p>Który z nich wybrać? To zależy od upodobań, oczekiwań i potrzeb. Jeśli przygoda z filogenetyką i bioinformatyką jest jedynie epizodyczna to powinien wystarczyć prosty w użyciu edytor. Natomiast jeśli mamy w planach spędzić dużo czasu na pracy z edytorem tekstowym to warto poświęcić czas i wysiłek na poznanie edytora, który niekoniecznie na początku jest łatwy i przyjazny w użyciu ale później z zapasem zwróci poświęcony na jego naukę czas.</p>
<p>Poniżej krótko scharakteryzuję kilka darmowych edytorów tekstu dostępnych (choć niekoniecznie wyłącznie) na systemie Linux o różnym stopniu trudności i możliwości.</p>
<a class="header" href="#nano" id="nano"><h2><code>nano</code></h2></a>
<p>Nano (GNU nano) to dość prosty edytor służący do pracy w terminalu. Jego główną zaletą jest prostota. Uruchamia się go poleceniem <code>nano</code>, można też otworzyć plik podając jego nazwę (ewentualnie ze ścieżką) jako argument: <code>nano plik.txt</code>. Podobnie zresztą można otwierać pliki w innych edytorach. Podstawowe funkcje, dostępne za pomocą skrótów klawiszowych, są wypisane na dole okna (<code>[^O]</code> oznacza skrót <code>Ctrl+O</code>). Powinien być zainstalowany domyślnie w systemie.</p>
<p><img src="edytory_tekstu/nano.png" alt="Nano po otwarciu" /></p>
<p>Pozostałe opcje i możliwości można poznać po otwarciu pomocy (<code>[^G]</code>)</p>
<p><img src="edytory_tekstu/nano-help.png" alt="Pomoc nano" /></p>
<p>Nano jest rozsądnym wyborem jeśli chcemy pracować w terminalu a nie mamy potrzeby nauczenia się edytora o znacznie większych możliwościach (np. vim)</p>
<a class="header" href="#jed" id="jed"><h2>JED</h2></a>
<p>Nieco bardziej przyjaznym w użyciu dzięki paskowi z rozwijanym menu, przynajmniej zdaniem twórców programu, edytorem działającym w trybie tekstowym jest JED. Jest dostępny na wiele systemów operacyjnych, z DOS-em włącznie. Uruchamia się go w terminalu komendą <code>jed</code>.</p>
<p>Uwaga praktyczna: Aby dostać się do paska menu, należy użyć klawisza <code>F10</code>. Może jednak on być przypisany do funkcji programu obsługującego emulator systemu lub samego systemu operacyjnego. Na przykład w MATE Terminal <code>F10</code> jest przypisany do własnego paska menu. Aby użyć tego klawisza w JED, należy to przypisanie usunąć wybierając w menu: <code>Edycja-&gt;Skróty klawiszowe...</code> a następnie w okienku odznaczyć opcję <code>Klawisz skrótu menu (domyślnie F10)</code>.</p>
<p><a href="https://www.jedsoft.org/jed/index.html">Strona domowa JED: https://www.jedsoft.org/jed/index.html</a></p>
<p>Instalacja (pod Debianem i dystrybucjami pochodnymi):</p>
<pre><code>sudo apt install jed
</code></pre>
<p><img src="edytory_tekstu/jed.png" alt="JED" /></p>
<p>JED sprawdzi się jako prosty edytor działający w trybie tekstowym.</p>
<a class="header" href="#pluma-gedit" id="pluma-gedit"><h2>Pluma, gedit</h2></a>
<p>Pluma jest edytorem związanym ze środowiskiem graficznym Mate, choć może być (po zainstalowaniu) używany pod innymi środowiskami. Wywodzi się z edytora gedit, który dostępny jest także dla innych niż Linux systemów operacyjnych. Oba są przeznaczone po pracy w środowisku okienkowym i posiadają interfejs graficzny. Podstawowe funkcje związane z edycją tekstu mogą być rozszerzane przy użyciu wtyczek. Otwierając plumę widzimy rozwijany pasek z menu oraz ikony, co pozwala od razu rozpocząć pracę z tym edytorem.</p>
<p><img src="edytory_tekstu/pluma.png" alt="Pluma" /></p>
<p>Nowsze wersje gedit nie posiadają paska z ikonami, ale polecenia są dostępne z rozwijanego menu lub menu kontekstowego.</p>
<p>Instalacja (pod Debianem i dystrybucjami pochodnymi):</p>
<pre><code>sudo apt install pluma
sudo apt install gedit
</code></pre>
<p><img src="edytory_tekstu/gedit.png" alt="Gedit" /></p>
<p>Oba programy sprawdzą się jako niewyszukane, ale łatwe w obsłudze edytory w środowisku graficznym.</p>
<a class="header" href="#kate" id="kate"><h2>Kate</h2></a>
<p>Po otwarciu Kate widać bardziej złożony interfejs niż w przypadku poprzednio omawianych edytorów. Posiada też więcej funkcji. Jest związany ze środowiskiem KDE, ale może być oczywiście uruchamiany pod innymi, co więcej jest dostępny nie tylko dla Linuksa ale też dla Mac OS X i Windows. Ciekawą możliwością Kate jest włączenie ,,VI mode'', które pozwala pracować w sposób wzorowany na edytorze <code>vi</code>.</p>
<p>Instalacja (pod Debianem i dystrybucjami pochodnymi):</p>
<pre><code>sudo apt install kate
</code></pre>
<p><a href="https://kate-editor.org/">Strona domowa Kate: https://kate-editor.org/</a></p>
<p><img src="edytory_tekstu/kate.png" alt="Kate" /></p>
<p>Kate sprawdzi się w podobnych sytuacjach jak pluma czy gedit, choć jest (przynajmniej pod pewnymi względami) edytorem bardziej zaawansowanym.</p>
<a class="header" href="#atom" id="atom"><h2>Atom</h2></a>
<p>Atom to edytor, który jest polecany między innymi ze względu na łatwość użycia, duże możliwości konfiguracji ustawień i poszerzania funkcjonalności przy pomocy licznych wtyczek (pakietów) w tym <a href="https://github.com/t9md/atom-vim-mode-plus">vim-mode-plus</a> przystosowującą Atom do sposobu pracy edytora <code>vim</code>. Edytor jest dostępny dla systemów Linux, Mac OS X i Windows.</p>
<p><a href="https://atom.io">Strona domowa Atom: https://atom.io</a></p>
<p>Instalacja:</p>
<p>Ze <a href="https://atom.io">strony domowej edytora Atom</a> należy pobrać plik instalacyjny i zainstalować.
Na Debianie i dystrybucjach pochodnych można to zrobić poleceniem:</p>
<pre><code>sudo dpkg -i atom-amd64.deb
</code></pre>
<p><img src="edytory_tekstu/atom.png" alt="Atom" />
<img src="edytory_tekstu/atom-file.png" alt="Atom edycja" /></p>
<p>Ciekawą opcją Atom-a jest podgląd edytowanych plików w formacie <code>markdown</code> o którym będzie mowa w dalszej części kursu.</p>
<p><img src="edytory_tekstu/atom-markdown.png" alt="Atom" /></p>
<p>Atom powinien zadowolić bardziej zaawansowanych użytkowników chcących używać edytora opartego na graficznym interfejsie.</p>
<a class="header" href="#vim" id="vim"><h2>Vim</h2></a>
<p>Vim to edytor tekstu, któremu poświęcę nieco więcej uwagi, głównie ze względu na jego ogromne możliwości. Nieprzypadkowo, wg. sondy serwisu <a href="https://insights.stackoverflow.com/survey/2016#technology-development-environments">stackoverflow</a> Vim w 2016 był najpopularnieszy wśród <a href="https://pl.wikipedia.org/wiki/Data_scientist">,,Data Scientists''</a> a wśród wszystkich uczestników zajął czwarte miejsce. Nie kryję, że jest to także mój ulubiony edytor tekstu. Wywodzi się z edytora <code>vi</code> (<code>VIM</code> = <em>VI iMproved</em>), jeśli na systemie Uniksowym nie ma zainstalowanego <code>vim</code>-a to prawie na pewno jest tam <code>vi</code>.</p>
<p>Zalety (wybrane) vim-a:</p>
<ul>
<li>Jest dostępny na wiele systemów operacyjnych z Androidem czy iOS-em włącznie</li>
<li>Ma małe wymagania, można na nim edytować duże pliki a także pracować zdalnie</li>
<li>Jest edytorem przeznaczonym do pracy w terminalu, ale posiada także wersje z interfejsem graficznym (np. gVim)</li>
<li>Pracuje się na nim z użyciem klawiszy co znacznie przyspiesza pracę, choć w wersji z GUI można także używać myszy, ikon i rozwijanych menu</li>
<li>Łatwo można modyfikować i poszerzać jego funkcjonalność m. in. przy pomocy licznych wtyczek</li>
<li>Łatwa współpraca z powłoką - można uruchomić komendę w terminalu a jej wynik wstawić do edytowanego pliku</li>
<li>Wiele czynności na tekście można wykonać za pomocą komend, na przykład analogicznych do tych dostępnych w programie <code>sed</code></li>
<li>...</li>
</ul>
<p>Skoro wymieniłem liczne zalety <code>vim</code>-a wypadałoby także wspomnieć o jego wadach a raczej wadzie. Na początku jest mało przyjazny.</p>
<p><code>Vim</code> uruchamiamy za pomocą komendy <code>vim</code> z opcjonalną nazwą pliku. Jeśli wolisz wersję z GUI to użyj polecenia <code>gvim</code> lub odpowiedniej ikony. Instalacja obu programów wygląda tak (vim prawdopodobnie jest już zainstalowany):</p>
<pre><code>sudo apt install vim
sudo apt install gvim
</code></pre>
<p>Po uruchomieniu programu pojawia się takie okno:</p>
<p><img src="edytory_tekstu/vim-start.png" alt="Vim - powitanie" /></p>
<p>W przypadku <code>gVim</code>:</p>
<p><img src="edytory_tekstu/gvim.png" alt="gVim - powitanie" /></p>
<p>Jak widać, po uruchomieniu nie widać menu czy ikon. Znajduje się tam krótka informacja o programie, jak wyjść z programu i jak uruchomić pomoc. Nawet nie bardzo wiadomo jak zacząć pisać. Podpowiem: naciśnij <code>i</code> i wprowadź jakiś tekst.</p>
<p><img src="edytory_tekstu/vim-pisanie.png" alt="Vim - pisanie" /></p>
<p>Teraz spróbuj wyjść z programu nie zamykając okna terminala. Jeśli nie zapamiętałeś odpowiedniej komendy z ekranu powitalnego - będzie to trudne, choć po naciśnięciu niektórych kombinacji klawiszy podpowiedź może się pojawić na dole ekranu.</p>
<p>Jak zatem wyjść z <code>vim</code>-a?
Naciśnij klawisz <code>&lt;Esc&gt;</code>, kursor pojawi się w linii na dole ekranu, tam wpisz <code>:q!</code></p>
<p><img src="edytory_tekstu/vim-wyjscie.png" alt="Vim - wyjście" /></p>
<p>Wciśnij <code>&lt;Enter&gt;</code>.</p>
<p>Obsługa <code>vim</code>-a to temat na osobną lekcję o ile nie kurs (których jest wiele w internecie), tu postaram się przekazać tylko kilka ogólnych informacji oraz aspektów pracy w tym edytorze, które pokażą dlaczego warto się podjąć jego nauki.</p>
<p>Pierwszą trudnością (poza wyjściem z programu) w pracy z <code>vim</code>-em, a co odróżnia go od większości innych edytorów, jest przyzwyczajenie się się do tego, że pracuje on w różnych trybach, a w każdym z nich zachowuje się nieco inaczej. Do najbardziej podstawowych należą:</p>
<ul>
<li>Tryb normalny (<em>normal</em>) - wbrew intuicji nie wpisujemy w nim bezpośrednio tekstu, ale przy pomocy klawiszy wydajemy komendy, które służą m. in. poruszaniu się, usuwaniu czy kopiowaniu tekstu. Po uruchomieniu <code>vim</code> znajduje się w tym trybie, przenosimy się do niego zhttps://www.oliversherouse.com/2017/08/21/vim_zero.html innych trybów za pomocą klawisza <code>&lt;Esc&gt;</code>, czasem trzeba go wcisnąć kilkukrotnie.</li>
<li>Tryb edycji (<em>insert</em>) - to w tym trybie wprowadzamy tekst, niektóre komendy są także dostępne za pomocą skrótów klawiszowych. Z trybu normalnego wchodzimy do niego używając odpowiednich poleceń (np. <code>i</code> - wprowadź tekst w miejscu kursora, <code>A</code> - wprowadź tekst na końcu linii)</li>
<li>Tryb linii komend/EX (<em>command line/ex</em>) - służy wprowadzaniu komend i wyszukiwaniu tekstu. Uruchamiamy go z trybu normalnego klawiszami <code>:</code> w celu wpisania komendy, <code>/</code> lub <code>?</code> aby wyszukać tekst, <code>!</code> żeby filtrować tekst. Jeśli znajdujesz się w innym, niż normany, trybie, najpierw należy wejść do trybu normalnego (<code>&lt;Esc&gt;</code>). Na dole pokazuje się linia, do której przeniesiony jest kursor, tam wpisujemy komendy. Spróbuj <code>:help vim-modes</code>. W tym trybie m. in. wykonuje się komendy wyjścia z programu, otwieranie i zapisywanie pliku, zamianę tekstu czy zmiany ustawień programu.</li>
</ul>
<p>Krótki ale treściwy samouczek można uruchomić komendą <code>vimtutor</code>. Pokaże się okno <code>vim</code>-a z otwartym plikiem tutoriala, który podczas nauki będziemy modyfikować zgodnie z instrukcjami:</p>
<p><img src="edytory_tekstu/vimtutor.png" alt="Samouczek vim-a" />.</p>
<p>Obszerną pomoc dostarcza także sam <code>vim</code> wywoływaną przez komendę <code>:help</code> ewentualnie uzupełnianą o temat (jak powyżej).</p>
<p>Teraz wykonaj parę ćwiczeń:</p>
<p>Otwórz <code>vim</code></p>
<pre><code>$: vim
</code></pre>
<p>Otwórz plik <code>/Orobanchaceae-trnL-trnF-aligned.fasta</code> w trybie <em>command line</em> (przy wpisywaniu ścieżki możesz posłużyć się klawiszem <code>&lt;Tab&gt;</code>, który ,,podpowie'' nazwy plików i katalogów:</p>
<pre><code>:e sciezka/Orobanchaceae-trnL-trnF-aligned.fasta
</code></pre>
<p>Teraz usuniemy wszystkie znaki indeli (<code>-</code>):</p>
<pre><code>:%s/-//g
</code></pre>
<p>Zmiany można cofnąć za pomocą klawisza <code>u</code> (w trybie <em>normal</em>)</p>
<p>Zauważ, że składnia jest podobna, do tej znanej z narzędzia <code>sed</code>. Znak <code>%</code> oznacza, że zmiana dotyczy wszystkich linii w pliku. Jeśli zmiana ma dotyczyć tylko konkretnej linii, w zamian podajemy jej numer. Jeśli numery linii się nie wyświetlają można to zmienić ustawiając odpowiednią opcję: <code>:set number</code>.</p>
<p>Komenda:</p>
<pre><code>:2s/-//g
</code></pre>
<p>Dokona zmiany w linii 2. Można też podać zakres linii, których ma dotyczyć polecenie:</p>
<pre><code>:1,8s/-//g
</code></pre>
<p>Jeśli zmiany mają ograniczyć się do linii pasujących do danego wzorca, podajemy go:</p>
<pre><code>:g/^&gt;/s/-//g
</code></pre>
<p>W pliku <code>Orobanchaceae-trnL-trnF-aligned.fasta</code> akurat nie ma znaku <code>-</code> w opisach sekwencji ale w innych plikach mogą być, zwłaszcza w nazwach gatunków (np. <em>Orobanche artemisiae-campestris</em>).
Jeśli zatem chcemy usunąć znaki <code>-</code> w liniach, które <strong>nie</strong> są opisem sekwencji użyjemy znaku <code>!</code> w odpowiednim miejscu:</p>
<pre><code>:g!/^&gt;/s/-//g
</code></pre>
<p>Podpowiedź: jeśli jesteś w linii komend (po wciśnięciu <code>:</code>) można przywołać poprzednie polecenia używając klawiszy ze strzałkami w górę i dół. Można je edytować przed powtórnym wywołaniem.</p>
<p>Poruszanie się po pliku może odbywać się przy pomocy klawiszy ze strzałkami, ale zalecane jest używanie klawiszy <code>h</code>, <code>j</code>, <code>k</code>, <code>l</code> (sprawdź jak działają). Kilka innych przydatnych klawiszy i komend do poruszania się w trybie <em>normal</em>:</p>
<ul>
<li><code>w</code> - następne słowo (ang. <em>word</em>)</li>
<li><code>b</code> - poprzednie słowo (ang. <em>backward</em>)</li>
<li><code>0</code> - początek linii</li>
<li><code>$</code> - koniec linii</li>
<li><code>)</code> - następne zdanie</li>
<li><code>(</code> - poprzednie zdanie</li>
<li><code>}</code> - następny paragraf</li>
<li><code>{</code> - poprzedni paragraf</li>
<li><code>gg</code> - początek pliku</li>
<li><code>G</code> - koniec pliku</li>
</ul>
<p>Podając liczbę, można zmienić miejsce docelowe, np:</p>
<ul>
<li><code>5w</code> - pięć słów naprzód</li>
<li><code>5G</code> - piąta linia</li>
</ul>
<p>Kilka poleceń edycyjnych w trybie <em>normal</em>:</p>
<ul>
<li><code>x</code> - usuń znak</li>
<li><code>yy</code> - kopiuj linię (ang. <em>yank</em>)</li>
<li><code>yw</code> - kopiuj słowo (ang. <em>yank word</em>)</li>
<li><code>dd</code> - usuń linię (ang. <em>delete</em>)</li>
<li><code>dw</code> - usuń do końca słowo (ang. <em>delete word</em>)</li>
<li><code>daw</code> - usuń całe słowo (ang. <em>delete all word</em>)</li>
<li><code>d$</code> - usuń tekst do końca linii</li>
<li><code>p</code> - wklej po kursorze (poniżej) (ang. <em>paste</em>)</li>
<li><code>P</code> - wklej przed kursorem (powyżej)</li>
<li><code>J</code> - połącz linię z następną (ang. <em>Join</em>)</li>
<li><code>u</code> - cofnij zmianę lub edycję (ang. <em>undo</em>)</li>
<li><code>&lt;Ctrl&gt;-r</code> - cofnięcie cofnięcia (ang. <em>redo</em>)</li>
</ul>
<p>Jak widać, przynajmniej niektóre, polecenia edycji można łączyć z komendami poruszania się. Polecenia takie jak <code>d</code> czy <code>y</code> trzeba uzupełnić o informację o ruchu. Można je także dodatkowo uzupełnić o liczbę:</p>
<ul>
<li><code>4J</code> - połącz cztery linie</li>
<li><code>5dw</code> - usuń pięć kolejnych słów</li>
<li><code>5yy</code> - skopiuj pięć linii</li>
</ul>
<p>Kilka podstawowych komend (w trybie <em>command line</em>):</p>
<ul>
<li><code>:e nazwa_pliku</code> - otwórz plik</li>
<li><code>:w</code> - zapisz plik</li>
<li><code>:q</code> - wyjdź (jeśli zmiany w pliku nie zostały zapisane, wyjście nie jest możliwe)</li>
<li><code>:q!</code> - wyjdź mimo niezapisania zmian</li>
<li><code>:wq</code> - zapisz zmiany w pliku i wyjdź</li>
<li><code>:w nowa_nazwa</code> - zapisz plik pod nową nazwą (zapisana jest kopia pliku)</li>
<li><code>:saveas nowa_nazwa</code> - zapisz plik pod nową nazwą i kontynuuje edycję pod nową nazwą</li>
<li><code>:r inny_plik</code> - wczytaj zawartość innego pliku i wstaw go w bieżącym (poniżej kursora)</li>
</ul>
<p>Powyżej pokazałem jedynie małą cząstkę możliwościach edytora <code>vim</code>. Nie pokazałem w ogóle jak można poszerzyć jego funkcjonalność i dopasować do własnych potrzeb i upodobań. Dalszą naukę można zacząć na przykład od wspomnianego <code>vimtutor</code>-a. Sposób pracy z <code>vim</code>-em może się wydawać (jak wspomniałem powyżej) nieintuicyjny ale przy pewnej wprawie pozwala na dużo efektywniejszą pracę niż z ,,tradycyjnymi'' edytorami. Dlatego warto poświęcić mu trochę czasu, z pewnością się odwdzięczy.</p>
<p><a href="cwiczenia/../README.html">← Spis treści</a></p>
<a class="header" href="#skrypty-w-linuksie" id="skrypty-w-linuksie"><h1>Skrypty w Linuksie</h1></a>
<a class="header" href="#po-co-pisać-skrypty" id="po-co-pisać-skrypty"><h2>Po co pisać skrypty?</h2></a>
<p>Podczas pracy w konsoli często wykonujemy wielokrotnie po kolei te same komendy, czasem nieco zmienione na przykład poprzez podanie innych plików wejściowych czy parametrów uruchamianych programów. Między innymi w takich wypadkach lepiej jest umieścić je w skrypcie, czyli pliku tekstowym, który uruchamia po kolei wpisane w nim komendy.
Umieszczanie poleceń w skryptach ma jeszcze tę zaletę, że stanowi on dobrą dokumentację wykonywanych operacji.
Pisanie skryptów jest w zasadzie programowaniem. Będziemy tu używać powłoki <code>Bash</code>. Poza możliwościami uruchamiania różnych poleceń/programów, z czym mieliśmy dotychczas do czynienia, udostępnia ona także wiele elementów charakterystycznych dla języków programowania jak zmienne, kolekcje elementów czy pętle. Tutaj pokażę tylko kilka podstawowych elementów programowania w <code>bash</code>-u.</p>
<a class="header" href="#pierwszy-skrypt" id="pierwszy-skrypt"><h2>Pierwszy skrypt</h2></a>
<p>Utwórz plik tekstowy o nazwie <code>pierwszy_skrypt.sh</code>. Umieść w nim kilka linii:</p>
<pre><code class="language-bash">#!/bin/bash

# Pierwszy skrypt

echo &quot;Witaj Świecie!&quot;
pwd
ls
# Tworzenie katalogu i pliku tekstowego
mkdir TMP
touch TMP/tekst.txt
# Umieszczenie tekstu w pliku
echo &quot;Tekst w pliku&quot; &gt; TMP/tekst.txt
# Wypisanie zawartości pliku
cat TMP/tekst.txt
</code></pre>
<p>Przed uruchomieniem pliku musimy jeszcze dokonać pewnej modyfikacji. Samo przedłużenie <code>.sh</code> (które zresztą jest opcjonalne) nie sprawia, że plik jest uruchamialny, najpierw trzeba mu nadać odpowiednie prawa:</p>
<pre><code>chmod u+x pierwszy_skrypt.sh 
</code></pre>
<p>Teraz można skrypt uruchomić:</p>
<pre><code>$: ./pierwszy_skrypt.sh 
Witaj Świecie!
/home/student/skrypty
pierwszy_skrypt.sh
Tekst w pliku
</code></pre>
<p>Zauważ, że plik uruchamiamy podając przed nazwą <code>./</code>, jeśli skrypt znajduje się w bieżącym katalogu. Jeśli nie, to podajemy do niego pełną ścieżkę (są jeszcze inne rozwiązania jak np. umieszczanie skryptu w katalogach, w których domyślnie powłoka szuka programów/skryptów).</p>
<p>Uruchomiony skrypt, jak widać, wykonał po kolei umieszczone w nim polecenia. Tajemniczo może wyglądać pierwsza linia. Znak <code>#</code> wskazuje na linię komentarza - czyli wszystko poza nim nie jest interpretowane przez powłokę. W tym przypadku, pierwszej linii skryptu, w połączeniu ze znakiem <code>!</code>, wskazuje jakiej powłoki (języka) użyć do uruchomienia poleceń w skrypcie.<br />
Skoro jednak już wspomniałem o komentarzach w skryptach to parę słów na ten temat. W komentarzach zwykle umieszczamy informacje na temat tego jaka jest ogólna funkcja skryptu, jak go używać, jak skrypt działa, czemu służą poszczególne polecenia itp. Przy pisaniu skryptów warto poświęcić trochę czasu aby go prawidłowo opisać w komentarzach. Po pierwsze sprzyja to dokumentacji pracy, po drugie jeśli po pewnym czasie wrócimy do skryptu, nie będziemy tracić czasu na przypominanie sobie ,,co autor miał na myśli''.</p>
<a class="header" href="#zmienne" id="zmienne"><h1>Zmienne</h1></a>
<p>Zmienne pozwalają przechować a następnie wykorzystać pewne wartości, np. liczby, łańcuchy znaków.</p>
<p>Na początek utwórz plik <code>zmienne.sh</code> z taką zawartością:</p>
<pre><code>#!/bin/bash

# Przykłady wykorzystania zmiennych

#Tworzymy dwie zmienne przechowujące łańcuchy znaków:
plik=tekst.txt
# Tu w łańcuchu znaków znajdują się spacje, dlatego konieczne są cudzysłowy
tekst=&quot;To jest tekst, który wpiszemy do pliku&quot;

# Odwołania do wartości zmiennych
echo &quot;Nazwa pliku: $plik&quot;
echo $tekst
echo &quot;Wpisuję do pliku:  $tekst&quot; &gt; $plik
echo &quot;Zawartość pliku:&quot;
cat $plik
</code></pre>
<p>Zauważ, że przy tworzeniu zmiennych nie używamy znaku <code>$</code> przy ich nazwie (<code>plik</code>, <code>tekst</code>), natomiast kiedy się do nich odwołujemy, umieszczamy znak <code>$</code> na początku (<code>$plik</code>, <code>$tekst</code>). Przy znaku <code>=</code> nie można wstawiać spacji. Znak <code>$</code> czasem znajduje się w innym miejscu, co można zobaczyć np. na kolejnym przykładzie w którym pokażę jak używać zmiennych przechowujących liczby do prostych obliczeń:</p>
<pre><code>#!/bin/bash

# Zmienne przechowujące liczby
liczba1=12
liczba2=6

# Wykonujemy działanie arytmetyczne - wyrażenie zamknięte w $[]
suma=$[liczba1+liczba2]
echo &quot;suma: $liczba1 + $liczba2 = $suma&quot;

# inny sposób - wyrażenie zamknięte w $(())
iloczyn=$((liczba1*liczba2))
echo &quot;iloczyn: $liczba1 * $liczba2 = $iloczyn&quot;

# Jeszcze inny sposób - polecenie let
# Uwaga - brak znaku $ przy nazwach zmiennych do których się odwołujemy
let roznica=liczba1-liczba2
echo &quot;różnica: $liczba1 - $liczba2 = $roznica&quot;

# Można oczywiście mieszać zmienne i liczby a wynik niekoniecznie
# trzeba przypisywać do zmiennej

echo &quot;kolejne obliczenia: $liczba1 + 20 = $[liczba1 + 20]&quot;
</code></pre>
<a class="header" href="#parametry-argumenty-przekazywane-do-skryptu-i-zmienne-specjalne" id="parametry-argumenty-przekazywane-do-skryptu-i-zmienne-specjalne"><h1>Parametry (argumenty) przekazywane do skryptu i zmienne specjalne</h1></a>
<p>Przy uruchamianiu skryptu, można przekazać parametry, takie jak np. nazwy plików z danymi, nazwy sekwencji, nazwy analizowanych gatunków itd. Podajemy je po nazwie skryptu, oddzielone spacjami. Jeśli przekazany parametr (np. tekst) zawiera spacje to całość obejmujemy cudzysłowami. Kolejne parametry przyjmują w skrypcie nazwy od $1 do $9. Nie oznacza to, że nie można ich przekazać więcej, ale można się do nich odwołać w inny sposób, np. używając pętli. Wszystkie parametry są przechowywane w <code>$@</code>.</p>
<p>W skrypcie można się posługiwać domyślnymi nazwami (<code>$1</code>..<code>$2</code>) ale dla przejrzystości kodu lepiej ich wartość przypisać do zmiennych o nazwach, które odpowiadają ich funkcji. Na przykład jeśli parametr jest nazwą pliku, to zienna może nazywać się <code>plik</code> albo <code>plik_wejsciowy</code>.</p>
<p>Utwórz skrypt <code>argumenty.sh</code>, nadaj mu uprawnienia wykonywalności.</p>
<pre><code>#!/bin/bash

# wszystkie argumenty przekazywane :
echo &quot;Argumenty: $@&quot;

# Wywołujemy poszczególne argumenty
echo &quot;argument 1: $1&quot;
echo &quot;argument 2: $2&quot;

# Argumenty, które mają konkretne znaczenie lepiej 
# przypisać do zmiennych których nazwy tłumaczą ich znaczenie
plik=$1
tekst=$2

# Teraz posługujemy się już utworzonymi zmeinnymi
echo $tekst &gt; $plik
echo &quot;Zawartość pliku $plik&quot;
cat $plik
</code></pre>
<p>Teraz go uruchom z dwoma parametrami:</p>
<pre><code>$: ./argumenty.sh argumenty.txt &quot;Tekst przekazany jako argument&quot;

Argumenty: argumenty.txt Tekst przekazany jako argument
argument 1: argumenty.txt
argument 2: Tekst przekazany jako argument
Zawartość pliku argumenty.txt
Tekst przekazany jako argument
</code></pre>
<p>Sprawdź zawartość pliku <code>argumenty.txt</code>.</p>
<p>Istnieje wiele innych zmiennych specjalnych i środowiskowych, które się mogą przydać, np:</p>
<ul>
<li><code>$0</code> - nazwa własna skryptu</li>
<li><code>$HOME</code> - ścieżka do katalogu domowego bieżącego użytkownika</li>
<li><code>$USER</code> - nazwa bieżącego użytkownika</li>
</ul>
<a class="header" href="#zmienne-tablicowe" id="zmienne-tablicowe"><h2>Zmienne tablicowe</h2></a>
<p>Być może zwróciłeś uwagę, że powyższa zmienna <code>$@</code> przechowuje wiele wartości na raz. Jest to przykład <strong>zmiennej tablicowej</strong>.</p>
<p>Zmienne tablicowe przydają się gdy chcemy przechować wiele elementów (które mogą odpowiadać wielu zmiennym). Za chwilę wrócimy do nich przy okazji pętli. Na razie prosty przykład jak utworzyć taką zmienną i wypełnić ją danymi (<code>zmienne_tablicowe.sh</code>):</p>
<pre><code>#!/bin/bash

# Tworzenie zmiennej tablicowej
sekwencje=(atp1 atp6 matR cox1)

# Drukowanie na raz całej zawartości zmiennej tablicowej
echo ${sekwencje[@]}

# Drukowanie kolejnych wartości
echo ${sekwencje[0]}
echo ${sekwencje[1]}
echo ${sekwencje[2]}
echo ${sekwencje[3]}
</code></pre>
<p>W nawiasach kwadratowych znajduje się indeks (numer) wartości. Zauważ, że liczby zaczynają się od <code>0</code> a nie <code>1</code>. Wartość o indeksie <code>1</code> jest więc drugą a nie pierwszą. Znak <code>@</code> lub <code>*</code> oznacza wszystkie wartości.</p>
<a class="header" href="#zmienne-i-wynik-polecenia" id="zmienne-i-wynik-polecenia"><h2>Zmienne i wynik polecenia</h2></a>
<p>Zmienna może przechowywać wynik działania polecenia. W takim wypadku polecenie należy albo umieścić w parze odwrotnych apostrofów <code>``</code> albo w parze nawiasów ze znakiem dolara <code>$()</code>.</p>
<p>Sprawdź na przykładzie jak to działa (<code>polecenia.sh</code>)</p>
<pre><code>#!/bin/bash

# Dwa sposoby przypisania do zmiennej wyniku działania polecenia
# lista plików w katalogu /usr/bin zaczynających się od z
pliki=`ls /usr/bin/z*`
# linie zawierające `plik` w bieżącym skrypcie
linie=$(grep plik $0)

# Drukowanie zawartości zmiennych
echo &quot;**** Znalezione pliki:&quot;
echo &quot;$pliki&quot;
echo &quot;**** Znalezione linie:&quot; 
echo &quot;$linie&quot;
</code></pre>
<p>Przy okazji sprawdź jak zmienia się sposób wyświetlania zawartości zmiennych jeśli ich nazwy nie znajdą się w cudzysłowach.</p>
<a class="header" href="#pętle-i-czytanie-wartości-z-pliku-tekstowego" id="pętle-i-czytanie-wartości-z-pliku-tekstowego"><h2>Pętle i czytanie wartości z pliku tekstowego</h2></a>
<p>Pętle pozwalają na wielokrotne wykonywanie tych samych czynności, często ze zmienionymi parametrami. Nie będę tu gruntownie omawiał pętli, pokażę tylko kilka przykładów pętli, które można zastosować w dalszych etapach kursu.</p>
<a class="header" href="#pętla-operująca-na-argumentach" id="pętla-operująca-na-argumentach"><h3>Pętla operująca na argumentach</h3></a>
<p>Pierwszy przykład pokazuje jak coś zrobić z kolejnymi argumentami przekazywanymi do skryptu. Mogą to być np. nazwy plików z którymi będziemy coś robić (np. generować dla nich drzewa filogenetyczne). Na razie tylko wydrukujemy ich nazwy.</p>
<p>Skrypt <code>petla_argumenty.sh</code></p>
<pre><code>#!/bin/bash

# Zmienna nr
nr=1

# Pętla 'for', która odczytuje argumenty przekazane do skryptu
# przechowywane w zmiennej tablicowej $@
# Kolejne argumenty są przypisywane zmiennej 'argument'
for argument in $@
do
    # Drukowanie wartości
    echo &quot;Argument $nr = $argument&quot;
    # Zwiększanie wartości zmiennej 'nr' o 1
    nr=$((nr+1))
done
</code></pre>
<p>Teraz wywołaj skrypt z odpowiednimi parametrami:</p>
<pre><code>$: /petla-argumenty.sh atp1.fasta atp6.fasta atp8.fasta matR.fasta
Argument 1 = atp1.fasta
Argument 2 = atp6.fasta
Argument 3 = atp8.fasta
Argument 4 = matR.fasta
</code></pre>
<p>Zamiast argumentów można użyć innej zmiennej tablicowej:</p>
<pre><code>#!/bin/bash

# Zmienna nr
nr=1

# Tworzymy zmienną tablicową:
sekwencje=(atp1 atp6 atp8 matR)

# Pętla 'for', która odczytuje argumenty ze zmiennej tablicowej 
# Kolejne wartości są przypisywane zmiennej 'argument'
for sekwencja in ${sekwencje[@]}
do
    # Drukowanie wartości
    echo &quot;Sekwencja $nr = $sekwencja&quot;
    nr=$((nr+1))
done
</code></pre>
<p>A teraz coś bardziej złożonego. Odczytywanie danych z pliku i wykorzystanie ich w pętli.</p>
<p>Najpierw utwórz plik tekstowy o nazwie <code>dane.tsv</code>. Przedłużenie <code>tsv</code> oznacza <em>tab-separated values</em>, więc dane oddziel tabulatorem a nie spacją.</p>
<pre><code>atp1	JX287332	ATAAATGACTAGAATTTGTTTTTCAATTGGAAGTGGTGCATATTGCGGTTGTTTCAGTAC
atp4	KX270773	TCAGAAGCATCTTCCATAGTCGTCTTGGTATTGGATCCGCTCTTCTGTTAGCATATTAAT
atp6	KU043163	AAACAAACGTTTTCCCCTCGCAACTCGGTTACTTTTACTTTTTTGTTATTTCGTAATCCC
atp8	KX270795	ATGCCTCAACTGGATAAATTCACTTATTTTACACAATTCTTCTGGTCATGCCTTTTCCTC
atp9	KX270765	TCAAAATACGAATGAAATCAAAAAGGCCATCATTAGGGCAAACAATGCGATCGCTTCGGT
</code></pre>
<p>W każdej linii znajduje się kolejno: nazwa sekwencji, numer GenBank z którego pochodzi fragment sekwencji i w końcu fragment sekwencji. Zwróć uwagę, żeby na dole pliku nie było pustej linii.</p>
<p>Teraz skrypt, który odczyta dane, a następnie na ich podstawie utworzy pliki z danymi (<code>czytaj_z_pliku.sh</code>)</p>
<pre><code>#!/bin/bash
# Nazwa katalogu na pliki wynikowe
katalog=&quot;sekwencje&quot;

# Tworzymy katalog dla plików wynikowych
mkdir sekwencje

# Pętla, która odczytuje dane z pliku i przypisuje je do zmiennych
while read nazwa numer sekwencja
do
    # Tworzymy nazwę pliku wynikowego: nazwa sekwencji + '.fasta`
    file=${nazwa}.fasta
    # Drukowanie nazwy pliku i odczytanych danych z linii
    echo &quot;$file: $nazwa - $numer - $sekwencja&quot;
    # Zapisanie opisu sekwencji do pliku
    echo &quot;&gt;$numer&quot; &gt; $katalog/$file
    # Dołączenie do pliku sekwencji
    echo $sekwencja &gt;&gt; $katalog/$file
# Dane pochodzą z pliku 'dane.tsv'	
done &lt; dane.tsv
</code></pre>
<p>Kolejna pętla odczytuje wszystkie pliki <code>fasta</code> z katalogu (<code>odczyt_plikow.sh</code>)</p>
<pre><code>#!/bin/bash

katalog=&quot;sekwencje&quot;

# Pętla, która odczytuje wszystkie pliki 'fasta' w katalogu
# oraz drukuje ich zawartość
for file in $katalog/*.fasta
do 
    echo &quot;Plik: $file&quot;
    cat $file
done
</code></pre>
<a class="header" href="#podsumowanie" id="podsumowanie"><h2>Podsumowanie</h2></a>
<p>Powyższe elementy pisania skryptów w <code>Bash</code>-u to jedynie czubek góry lodowej. Zachęcam do dalszego samodzielnego zgłębiania tej cennej umiejętności. W dalszej części kursu pokażę bardziej praktyczne przykłady jej wykorzystania.</p>
<p><a href="cwiczenia/../README.html">← Spis treści</a></p>
<a class="header" href="#warsztat-pracy" id="warsztat-pracy"><h1>Warsztat pracy</h1></a>
<p>Praca bioinformatyczna wymaga dobrej organizacji, a także dokumentacji prowadzonych badań. Warto przy tym trzymać się pewnych schematów i zasad.
Poniżej przedstawię kilka sugestii opartych na własnych doświadczeniach a także bardzo dobrej książce <a href="http://shop.oreilly.com/product/0636920030157.do">Bioinformatics Data Skills</a>
autorstwa Vince Bufallo, która zajmuje się między innymi warsztatowymi aspektami pracy bioinformatycznej. Oczywiście nie trzeba się ich sztywno trzymać a raczej traktować je jako wskazówki, które pozwolą wypracować własny, przystosowany do osobistych upodobań warsztat pracy.</p>
<a class="header" href="#badania-powinny-być-powtarzalne" id="badania-powinny-być-powtarzalne"><h2>Badania powinny być powtarzalne</h2></a>
<p>Sposób pracy powinien być taki aby można było ją odtworzyć od początku do końca, co zresztą jest uniwersalnym zaleceniem do (prawie) każdej pracy naukowej. Z jednej strony chodzi o to by mogli to zrobić inni badacze ale znacznie częściej to my będziemy je powtarzać (i to wielokrotnie) na przykład w przypadku uzyskania nowych danych czy wykrycia błędów w analizie.  Dwa podstawowe aspekty powtarzalności badań to zachowywanie danych i dokumentacja pracy.</p>
<a class="header" href="#pliki-i-katalogi" id="pliki-i-katalogi"><h2>Pliki i katalogi</h2></a>
<p>Kluczową sprawą dobrej organizacji pracy jest porządek w katalogach i plikach. Dobrze jest ustalić sobie pewien standardowy układ katalogów a co za tym idzie miejsc przechowywania plików o konkretnym przeznaczeniu. Całość badań nad danym tematem dobrze jest trzymać w jednym głównym dla projektu katalogu, o nazwie wskazującej na temat, a w nim utworzyć szereg katalogów i podkatalogów.  Oddzielnie należy przechowywać surowe dane, skrypty, dokumentację badań i inne informacje a jeszcze gdzie indziej wyniki badań.</p>
<p>Na przykład taki schemat może wyglądać tak:</p>
<pre><code>Katalog_glowny 
├── DANE
├── DANE-SUROWE
├── INFORMACJE
├── README.md (plik)
├── SKRYPTY
└── WYNIKI
</code></pre>
<ul>
<li><code>Katalog_glowny</code> - Główny katalog obejmujący dany projekt. Nazwa powinna wskazywać na jego temat, np. <code>Filogenetka_Rumex</code></li>
<li><code>DANE</code> - Tu możemy trzymać dane nad którymi pracujemy, na różnych etapach ich obróbki.</li>
<li><code>DANE-SUROWE</code> - Miejsce przechowywania danych surowych, od których zaczynamy pracę. Traktujemy je jako nienaruszalne, nie modyfikujemy ich w żaden sposób. Pozwala to zawsze zacząć analizy od początku.</li>
<li><code>INFORMACJE</code> - Różne dodatkowe informacje potrzebne przy pracy, np. publikacje, instrukcje, wskazówki współpracowników, tabele itp.</li>
<li><code>README.md</code> - Plik, w którym notujemy przebieg prac (dalej więcej na ten temat)</li>
<li><code>SKRYPTY</code> - Jak nazwa wskazuje, jest to miejsce przechowywania skryptów.</li>
<li><code>WYNIKI</code> - Katalog w którym będą znajdować się podkatalogi z wynikami prac. Każda analiza w oddzielnym katalogu (zob.dalej).</li>
</ul>
<p>Zauważ, że całość można przygotować za pomocą dwu komend:</p>
<pre><code>mkdir -p Katalog_glowny/{DANE-SUROWE,DANE,INFORMACJE,SKRYPTY,WYNIKI}
touch Katalog_glowny/README.md
</code></pre>
<a class="header" href="#dokumentacja-prac" id="dokumentacja-prac"><h2>Dokumentacja prac</h2></a>
<p>Jak wspomniałem powyżej, należy dokumentować poszczególne etapy pracy z danymi, w taki sposób aby móc je powtórzyć, kiedy zajdzie potrzeba. Czyli prowadzić bioinformatyczną wersję dziennika laboratoryjnego.  Wymaga to zapisywania wszelkich czynności, które wykonujemy z danymi. Część z nich wykonujemy ręcznie, inne używając programów komputerowych. Tutaj widać kolejną przewagę narzędzi obsługiwanych z linii komend. Znacznie łatwiej zapisać polecenie, które uruchomiliśmy w terminalu wraz z parametrami niż opisywać stosowane ustawienia w ,,klikanej'' aplikacji. Oczywiście łatwiej jest dokumentować pracę na komputerze używając plików, m. in. dzięki możliwości kopiowania i wklejania poleceń, niż zapisywać je w papierowym dzienniku.</p>
<p>Ze względu na uniwersalność plików tekstowych, dobrze jest używać ich także przy prowadzeniu dokumentacji. ,,Goły'' tekst niekoniecznie jednak jest przejrzysty, zwłaszcza gdy chcemy go podzielić na sekcje, odpowiadające np. poszczególnym dniom pracy albo wyróżnić polecenia w terminalu. Dlatego dobrze jest użyć usystematyzowanego zestawu znaczników, który pozwala na formatowanie tekstu, przy zachowaniu jednak tekstowego charakteru pliku. Do najpopularniejszych należy <a href="https://pl.wikipedia.org/wiki/Markdown">Markdown</a>. Stosując określone znaki lub ich zestawy, można oznaczać m. in. nagłówki, listy, linki, pogrubienia,  fragmenty kodu itp.</p>
<p>Przykładowe znaczniki to:</p>
<p>Nagłówki:</p>
<pre><code># Nagłówek 1
## Nagłówek 2
### Nagłówek 3
</code></pre>
<p>Lista:</p>
<pre><code>  * pozycja 1
  * pozycja 2
  * pozycja 3
</code></pre>
<p>Zamiast gwiazdki można używać znaków - lub +</p>
<p>Lista numerowana:</p>
<pre><code>1. Pierwszy punkt
2. Drugi punkt
3. Trzeci punkt
</code></pre>
<p>Linki:</p>
<pre><code>[Tekst linku](Adres)
</code></pre>
<p>Obrazek:</p>
<pre><code>![Podps obrazka](ścieżka do obrazka)
</code></pre>
<p>Kod:
kod w linii</p>
<pre><code>tekst `kod` tekst
</code></pre>
<p>lub:</p>
<pre><code>```
 kod 
 kod 
 kod
```
</code></pre>
<p>Pogrubienie</p>
<pre><code>**pogrubiony tekst**
</code></pre>
<p>Italik:</p>
<pre><code>_Pochylony tekst_
</code></pre>
<p>Wiecej znaczników i przykładów można znaleźć w internecie na przykład <a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">tu</a>.
Format markdown jest dość czytelny ale można go również łatwo przeformatować w <code>.html</code> i wiele innych formatów włączając w to <code>.doc</code> czy <code>.pdf</code>. Do konwersji można wykorzystać na przykład narzędzie <a href="https://pandoc.org/">Pandoc</a>, choć niektóre serwisy (np. GitLab, GitHub, GitBook) automatycznie dokonują przekształcenia plików na format <code>html</code> i wyświetlają je jak zwykłe strony internetowe z odpowiedim formatowaniem. Przykładem jest niniejszy skrypt, który został napisany właśnie w markdownie.</p>
<p>Pliki w formacie markdown zwykle mają nazwy z przedłużeniem <code>.md</code>. Stąd takie przedłużenie w nazwie pliku <code>README.md</code>. Czemu jednak <code>README</code>? Wrócę do tego przy omawianiu narzędzia <code>Git</code>.</p>
<p>Jak wspomniałem, w naszym ,,dzienniku'' zapisujemy polecenia, które wydajemy przy pracy z danymi. Aby uniknąć pomyłki i zaoszczędzić czas lepiej to robić przez kopiowanie i wklejanie między edytorem tekstu i terminalem. Przy czym w zależności od sytuacji czasem wygodnie jest wydawać polecenia w terminalu i kopiować je do edytora, w innych przypadkach, zwłaszcza gdy wydajemy serię poleceń, możemy najpierw je wyedytować w naszym ,,dzienniku'' a potem przekopiować całość do terminala i uruchomić. Oczywiście w przypadku powtarzalnych sekwencji poleceń warto rozważyć zapisanie ich do osobnego skryptu (który też należy zachować).</p>
<a class="header" href="#zapisywanie-wyników" id="zapisywanie-wyników"><h2>Zapisywanie wyników</h2></a>
<p>W katalogu <code>WYNIKI</code> należy zapisywać rezultaty badań, zwykle generowane przez polecenia i skrypty. Każdy katalog może odpowiadać np. jednemu ciągowi operacji wykonywanemu w danym dniu, lub przez pojedyncze uruchmieniu skryptu czy serii poleceń. Oprócz plików z wynikami, można tam takze umieścić pliki z danymi wejściowymi, zwłaszcza jeśli nie są zbyt duże. Nazwa takiego katalogu powinna objaśniać czego badania dotyczą, dobrze jest jeśli przy tym zawiera datę i czas.  Można to oczywiście zautomatyzować dzięki odpowiednim poleceniom.</p>
<p>Na przykład sprawdź wynik działania komend:</p>
<pre><code>sekwencja=atp6
res=&quot;$sekwencja-$(date +\%F_\%H-\%M-\%S)&quot;
mkdir $res
</code></pre>
<p>Tego typu polecenia być standardowym fragmentem skryptu generującego wyniki badań.</p>
<p>Przy okazji sprawdź manual polecenia <code>date</code>.</p>
<a class="header" href="#kontrola-wersji-git" id="kontrola-wersji-git"><h2>Kontrola wersji (Git)</h2></a>
<p>Git to jeden z systemu kontroli wersji. Nie wchodząc w szczegóły, oznacza to, że można dzięki niemu zachowywać historię zmian projektu i w razie potrzeby przywracać starsze wersje. Umożliwia także pracę wielu osób nad jednym projektem, umiejętnie łącząc zmiany dokonywane przez wiele osób. Wykorzystuje się go głównie przy tworzeniu programowania, ale doskonale także sprawdza się przy archiwizowaniu pracy bioinformatycznej czy... pisaniu skryptu do kursu filogenetyki.</p>
<p>Nauka Git-a wykracza poza zakres tego kursu, dlatego tylko przedstawię bardzo podstawowe informacje. Zachęcam jednak do samodzielnego zgłębiania tematu.</p>
<p>Jednym z możliwych scenariuszy jest stworzenie konta na jednym z serwisów, które oferują taką możliwość (np. GitHub, BitBucket, GitLab) a następnie utworzenie projektów i ich synchronizacja z lokalnymi katalogami, które im odpowiadają.</p>
<p>Jeśli chcesz spróbować, utwórz konto na stronie <a href="https://gitlab.com/">gitlab.com</a>, zaloguj się i kliknij na ,,New project''. Pokaże się strona na której nadajesz nazwę swojemu projektowi i dostosowujesz inne parametry, na przykład to czy projekt jest dostępny publicznie czy nie.</p>
<p>Po zatwierdzeniu pojawia się strona na której znajdziesz dalsze instrukcje w jaki sposób skonfigurować <code>git</code>-a u siebie (najpierw oczywiście musisz go zainstalować):</p>
<pre><code>git config --global user.name &quot;Imie&quot;
git config --global user.email &quot;Twoj@email&quot;
</code></pre>
<p>i jak utworzyć repozytorium projektu na swoim komputerze:</p>
<pre><code>git clone git@gitlab.com:twoje_konto/nazwa_projektu.git
cd probny-projekt
touch README.md
git add README.md
git commit -m &quot;add README&quot;
git push -u origin master
</code></pre>
<p>Zauważ, że najpierw ,,sklonowałeś'' projekt na swój komputer a potem utworzyłeś w nim plik o nazwie <code>README.md</code>. Brzmi znajomo? Plik o takiej nazwie domyślnie zostaje wyświetlony, jako strona internetowa na stronie Twojego projektu. Na końcu zmiany zostały wysłane w trzech krokach na serwer.</p>
<p>Teraz spróbuj coś dopisać do tego pliku, używając formatowania markdown. Następnie wykonaj w głównym katalogu projektu komendy aktualizujące go na serwerze:</p>
<pre><code>git add -A
git commit -a -m &quot;Modyfikacja pliku README.md&quot;
git push 
</code></pre>
<p>Ten zestaw komend wykonuj po zakończeniu dnia lub etapu pracy. Oczywiście komentarz w cudzysłowach dostosuj tak aby opisywały wykonane zmiany w projekcie.</p>
<p>Teraz obejrzyj na swoim koncie stronę utworzonego projektu.</p>
<p>Projekt można sklonować na innych komputerach i także na nich prowadzić badania. Nie zapominaj tylko aby po skończonej pracy dokonać ,,commitu'' projektu i przed rozpoczęciem kontynuacji pracy wykonać w katalogu głównym projektu komendę:</p>
<pre><code>git pull
</code></pre>
<p>Pobiera ona zmiany z serwera do lokalnego katalogu.</p>
<a class="header" href="#bazy-sekwencji---wyszukiwanie-genbank" id="bazy-sekwencji---wyszukiwanie-genbank"><h1>Bazy sekwencji - wyszukiwanie (GenBank)</h1></a>
<a class="header" href="#czym-jest-genbank" id="czym-jest-genbank"><h2>Czym jest GenBank?</h2></a>
<p><a href="https://www.ncbi.nlm.nih.gov/genbank/">GenBank</a> jest jedną z baz <a href="https://www.ncbi.nlm.nih.gov">The National Center for Biotechnology Information</a> (NCBI) gromadzącą i udostępniającą publicznie sekwencje DNA. W ramach <a href="http://www.insdc.org/">International Nucleotide Sequence Database Collaboration</a> współpracuje z <a href="http://www.ddbj.nig.ac.jp">DNA DataBank of Japan</a> (DDBJ) oraz <a href="https://www.ebi.ac.uk">European Nucleotide Archive</a> (ENA) z którymi regularnie wymienia dane. Zachęcam do odwiedzenia i sprawdzenia możliwości pozostałych dwu baz danych, jednak na naszych zajęciach zajmiemy się bazą GenBank.</p>
<p>Najpierw pokażę podstawy pobierania sekwencji DNA przez stronę internetową GenBank-u, później zaprezentuję kilka sposobów pobierania danych z linii komend.</p>
<a class="header" href="#proste-wyszukiwanie-danych-z-bazy-genbank-przez-stronę-www" id="proste-wyszukiwanie-danych-z-bazy-genbank-przez-stronę-www"><h2>Proste wyszukiwanie danych z bazy GenBank przez stronę WWW</h2></a>
<p>W przeglądarce internetowej wejdź na stronę <a href="https://www.ncbi.nlm.nih.gov/genbank">https://www.ncbi.nlm.nih.gov/genbank</a>.
Pokaże się strona początkowa z paskiem wyszukiwania u góry:</p>
<p><img src="genbank/GB-start.png" alt="Strona startowa GenBank" /></p>
<p>Po lewej stronie paska wyszukiwania, znajduje się rozwijane menu, gdzie można wybrać bazę danych NCBI, z której chcemy korzystać.</p>
<p><img src="genbank/GB-menu-bazy.png" alt="Bazy NCBI" /></p>
<p>Jak widać jest ich wiele, m. in. baza zawierająca sekwencje proteinowe czy baza taksonomiczna. Nas teraz interesuje ,,Nucleotide'', która odpowiada bazie GenBank.</p>
<p>Wpisz w pasku wyszukiwania atp6 i kliknij ,,Search''.</p>
<p>Po chwili pokazuje się okno z wynikami wyszukiwania:</p>
<p><img src="genbank/GB-wynik-wyszukiwania.png" alt="Wyniki wyszukiwania" /></p>
<p>Poniżej paska wyszukiwania, strona jest podzielona na trzy kolumny. Oprócz samych wyników wyszukiwania w kolumnie środkowej, na stronie widzimy wiele dodatkowych informacji a także dodatkowych narzędzi. Krótko omówię niektóre z nich.</p>
<p>Na górze środkowego panelu mamy możliwość zmiany sposobu wyświetlania wyników a także eksportu pliku np. do pliku czy schowka.</p>
<p><img src="genbank/GB-srodkowy-panel-top.png" alt="Środkowy panel - góra" /></p>
<p>Na przykład zmieniając sposób wyświetlania ,,Summary'' na ,,FASTA''...</p>
<p><img src="genbank/GB-wybierz-fasta.png" alt="Zmiana formatu wyników" /></p>
<p>... uzyskujemy w wynikach podgląd sekwencji w formacie <code>FASTA</code>.</p>
<p><img src="genbank/GB-wyszukiwanie-opcje-fasta.png" alt="Wyniki w formacie FASTA" /></p>
<p>Wyniki (wszystkie lub wybrane przez zaznaczenie odpowiednich rekordów) można skopiować do schowka na stronie (tu są pewne limity), dodać do kolekcji na swoim koncie albo zachować w pliku o wybranym formacie, np. <code>FASTA</code>:</p>
<p><img src="genbank/GB-send-to-fasta.png" alt="Eksport wyników" /></p>
<p>Poniżej znajduje się ramka z pełniejszą nazwą sekwencji i linkiem do informacji o niej.</p>
<p>Przyjrzyjmy się teraz jak wygląda pojedynczy rekord wyświetlany w formacie domyślnym - ,,Summary'':</p>
<p><img src="genbank/GB-rekord.png" alt="Rekord" /></p>
<p>Na górze znajduje się opis sekwencji, który jest linkiem do szczegółowych informacji wyświetlanych w formacie <code>GenBank</code>. Następna linia informuje o długości i rodzaju sekwencji.
Następnie widać numer dostępowy (,,Accession''), który jest unikalnym numerem danej sekwencji. Po tym numerze można ją jednoznacznie zidentyfikować, toteż zazwyczaj podaje się go w publikacjach, drzewach filogenetycznych itp. Drugi z podanych numerów (,,GI'') jest numerem identyfikacyjnym GenBank i ma mniejsze znaczenie z naszego punktu widzenia.</p>
<p>W kolejnej linii wyświetlone są odsyłacze do innych baz, można dzięki nim sprawdzić sekwencję aminokwasów dla danego genu (,,Protein''), zobaczyć powiązaną publikację (,,PubMed'') czy poznać pozycję systematyczną organizmu (,,Taxonomy'').</p>
<p>Na dole umieszczone są linki, które pozwalają wyświetlić wynik w formacie <code>GenBank</code> i <code>FASTA</code>, w sposób graficzny i w końcu (,,PopSet'') wyświetlić listę sekwencji, które były wysłane do GenBank-u razem z daną sekwencją a więc są na ogół w jakiś sposób z nią powiązane.</p>
<p>W lewym panelu znajdują się informacje na temat liczby znalezionych sekwencji w różnych kategoriach, wydzielonych na podstawie grupy organizmów (,,Species''), rodzaju cząsteczek (,,Molecule types''), źródła danych (,,Source databases'') czy rodzaju genomu (,,Genetic compartments''). Klikając na odpowiednie kategorie można zawęzić wyniki np. do roślin czy genomów mitochondrialnych. Można kategorie łączyć. Na przykład klikając w ,,Plants'' i ,,Mitochondrion'' otrzymujemy wyniki dla roślinnych sekwencji mitochondrialnych.</p>
<p><img src="genbank/GB-plants-mitochondrion.png" alt="Sekwencje roślinne, mitochondrialne" /></p>
<p>Na dole lewego panelu można także zawęzić wyszukiwanie sekwencji do konkretnego zakresu długości sekwencji, czasu publikacji czy daty aktualizacji. Najbardziej przydatna wydaje się być pierwsza możliwość, pozwala wyeliminować zbyt krótkie sekwencje.</p>
<p><img src="genbank/GB-range.png" alt="Wybór zakresu długości sekwencji" /></p>
<p>Teraz przenieśmy się na prawy panel. Przy zawężonym zakresie wyszukiwania teraz wygląda tak (porównaj z poprzednim wyglądem):</p>
<p><img src="genbank/GB-prawy-panel.png" alt="Prawy panel" /></p>
<p>Sekcja ,,Results by taxon'' pokazuje organizmy o największej liczbie wyników. Klikając na ,,Tree'' otrzymujemy widok drzewa.</p>
<p><img src="genbank/GB-by-taxon-tree.png" alt="Widok drzewa" /></p>
<p>Klikając na odpowiednie pozycje możemy zawęzić wyniki do określonej grupy organizmów, drzewo można także rozwijać do mniejszych jednostek taksonomicznych.</p>
<p>Teraz przejdźmy nieco niżej do sekcji ,,Search details''. Tam w okienku widzimy w formie tekstowej treść naszego zapytania, razem z ustawionymi filtrami ograniczającymi zakres wyszukiwania. Zauważ, że w parach nawiasów kwadratowych znajdują się nazwy pól wyszukiwania, tak więc np. <code>atp6</code> wyszukiwane jest we wszystkich polach a <code>plants</code> i <code>mitochondrion</code> w polu <code>Filter</code>, ograniczenie do grupy organizmów można uzyskać używając pola <code>porgn</code>. Jeśli zechcesz się pokusić o ręczne wpisywanie zapytań (lub ich części) to warto zapoznać się ze znaczeniem nazw pól, które można znaleźć w dokumentacji pod adresem <a href="https://www.ncbi.nlm.nih.gov/books/NBK49540/">https://www.ncbi.nlm.nih.gov/books/NBK49540/</a>. Warto też zwracać uwagę jak zmienia się tekst zapytania w zależności od zmian w ustawianych filtrach. Poszczególne części zapytania można łączyć za pomocą operatorów <code>AND</code>, <code>OR</code> oraz <code>NOT</code> a także grupować za pomocą nawiasów.</p>
<p>Zapytanie można oczywiście wpisywać także w pasek wyszukiwania u góry strony. Warto też obserwować jak zmienia się treść zapytania w polu ,,Search details'' w zależności od tego co wpisujemy w pasek wyszukiwania.</p>
<p>Na przykład wpisując w pasku wyszukiwania <code>atp6 Orobanche</code> widzimy w okienku ,,Search details'' zapytanie: <code>atp6[All Fields] AND (&quot;Orobanche&quot;[Organism] OR Orobanche[All Fields])</code>. Operator <code>AND</code> oznacza, że oba łączone nim wyrażenia powinny być spełnione. Jak widać, jest to domyślny operator wyszukiwania. Zauważ też, że słowo <code>Orobanche</code> jest wyszukiwane nie tylko w polu <code>Organism</code> (które oczywiście oznacza konkretny organizm) ale we wszystkich polach danego rekordu, co może tłumaczyć dlaczego w wynikach widzimy także sekwencje innych gatunków.</p>
<p>Teraz wpisz zapytanie: <code>atp6[All Fields] AND &quot;Orobanche&quot;[Organism]</code> i sprawdź jakie będą wyniki.</p>
<p>Jeśli chcemy wykluczyć część wyników, użyjemy operatora <code>NOT</code>. Zapytanie <code>atp6[All Fields] NOT &quot;Orobanche&quot;[Organism]</code> zwróci sekwencje <code>atp6</code> nienależące do <code>Orobanche</code>.</p>
<p>Działanie ostatniego z operatorów <code>OR</code> pokażę na przykładzie, razem z zastosowaniem nawiasów. Zapytanie <code>atp6[All Fields] AND (&quot;Orobanche&quot;[Organism] OR &quot;Phelipanche&quot;[Organism])</code> pozwoli znaleźć sekwencje <code>atp6</code> należące do <code>Orobanche</code> lub <code>Phelipanche</code>. Otrzymamy więc sekwencje roślin należących do obu rodzajów.</p>
<p>Na dole prawego panelu znajdziemy linki do poprzednich wyszukiwań.</p>
<p>Przy wyszukiwaniu danych w GenBank-u należy pamiętać o tym, że w przeciwieństwie do popularnych wyszukiwarek internetowych, które tolerują literówki tu trzeba być bardzo dokładnym, nie otrzymamy pomocy w postaci linku ,,Czy chodziło Ci o....?&quot;.</p>
<p>Poniżej pasku wyszukiwania na górze znajduje się link <code>Advanced</code>. Jak można się domyślić, znajdziemy tam narzędzie pozwalające tworzyć złożone i/lub precyzyjne zapytania:</p>
<p><img src="genbank/GB-advanced-search.png" alt="Tworzenie złożonych i precyzyjnych zapytań" /></p>
<p>Jeśli znasz numer GenBank-u szukanej sekwencji to dobrym pomysłem jest wpisanie go (zamiast gatunku i nazwy sekwencji) do paska wyszukiwań. Wtedy, jeśli numer jest prawidłowy od razu przejdziesz do strony z wynikiem, tej samej, którą otworzysz klikając w wynik wyszukiwania.</p>
<p>Wpisz numer <code>KU180474</code>.</p>
<a class="header" href="#sekwencja---informacje-i-pobieranie" id="sekwencja---informacje-i-pobieranie"><h2>Sekwencja - informacje i pobieranie</h2></a>
<p>Strona z wynikiem składa się z dwu paneli (pomijając pasek wyszukiwania). W prawym znajdują się narzędzia, które teraz pominiemy, choć do niektórych jeszcze wrócimy. Przeanalizujmy panel lewy z informacjami dotyczącymi sekwencji.</p>
<p>Na górze znajduje się nagłówek z opisem sekwencji, numerem GenBank i linkami, które już omawialiśmy przy okazji listy wyników wyszukiwania.</p>
<p><img src="genbank/GB-wynik-top.png" alt="Wynik - nagłówek" /></p>
<p>Poniżej znajduje się sekcja z polami opisującymi ogólnie sekwencje. Odpowiadają one polom używanym w trakcie wyszukiwania. W zasadzie nie wymagają one wyjaśnienia. Warto zwrócić uwagę, że często można znaleźć tam nazwę artykułu w którym opublikowano badania dotyczące sekwencji. Trzeba jednak uważać - autorzy wprowadzają do bazy sekwencje zwykle przed opublikowaniem artykułu, jest to więc zazwyczaj tytuł roboczy. Co prawda po ukazaniu się publikacji powinni dane zaktualizować, ale nie zawsze tak się dzieje.</p>
<p><img src="genbank/GB-wynik-informacje.png" alt="Wynik - opis sekwencji" /></p>
<p>Następne pole <code>FEATURES</code> zawiera kolejne pola dokładniej opisujące sekwencje, łącznie z genami i innymi specyficznymi fragmentami DNA, miejscami kodującymi i translacją sekwencji. Jest ona zwłaszcza przydatna, gdy chcemy pobrać jedynie część sekwencji. Sekwencja nie musi bowiem odpowiadać jednemu genowi - może to być np. genom mitochondrialny czy sekwencja całego chromosomu. Wtedy możemy chcieć np wyciąć z niej jeden gen. Wrócimy jeszcze do tego tematu.</p>
<p><img src="genbank/GB-wynik-features.png" alt="Wynik - szczegóły sekwencji" /></p>
<p>Dalej znajduje się sekwencja nukleotydów, czyli to czego zazwyczaj szukamy w GenBank-u.</p>
<p><img src="genbank/GB-wynik-sekwencja.png" alt="Wynik - sekwencja nukleotydów" /></p>
<p>Mogłoby się wydawać, że teraz można zaznaczyć fragment z sekwencją nukleotydów, skopiować i wkleić do edytora tekstu aby po uzupełnieniu linii z opisem sekwencji (zaczynającej się od znaku <code>&gt;</code>) otrzymać plik <code>FASTA</code>. Można, ale nie jest to najlepszy pomysł. Przede wszystkim ze względu na to, że skopiowany tekst zawiera numery i spacje, które trzeba by usunąć. Jak zatem otrzymać sekwencje w formacie <code>FASTA</code>? Na górze strony znajdują się linki <code>FASTA</code> oraz <code>Send to</code>. Po kliknięciu pierwszego z nich uzyskujemy stronę z wynikiem w tym właśnie formacie, który można skopiować i wkleić do edytora tekstu, łącznie z linią opisu sekwencji.</p>
<p><img src="genbank/GB-wynik-fasta.png" alt="Wynik w formacie FASTA" /></p>
<p>Klikając w <code>Send to</code> otwiera się okienko, które pozwala m. in. zapisać sekwencję do pliku <code>FASTA</code> (patrz wyżej).</p>
<p>Dużo dokładniejszy opis poszczególnych pól opisujących sekwencję można znaleźć w dokumentacji GenBank-u pod adresem <a href="https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html">https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html</a>.</p>
<a class="header" href="#zadanie" id="zadanie"><h3>Zadanie</h3></a>
<p>Utwórz plik <code>atp6.fasta</code> w którym umieść następujące sekwencje:</p>
<pre><code>Artemisia campestris KU180471
Centaurea scabiosa KU180476
Helianthus annuus FJ595983
Magnolia stellata KC879635
Mimulus guttatus HQ593782
Orobanche alba KU180469
Orobanche grenieri KU180474
Peucedanum cervaria KU180475
Phelipanche purpurea KU180468
Phelipanche ramosa KU180466
Solanum tuberosum AF095276
</code></pre>
<a class="header" href="#pobieranie-sekwencji-genu-z-genomu" id="pobieranie-sekwencji-genu-z-genomu"><h2>Pobieranie sekwencji genu z genomu</h2></a>
<p>Dotychczas wyszukiwaliśmy sekwencje, które zostały umieszczone w GenBank-u jako oddzielne sekwencje genów. Nie zawsze jednak sytuacja jest tak wygodna. W wielu przypadkach sekwencje genów są częścią dużo dłuższych odcinków DNA, na przykład chromosomów, genomów plastydowych czy mitochondrialnych. Pokażę teraz jak z nich wydobyć interesujące nas sekwencje.</p>
<p>Wyszukaj w GenBank-u sekwencję 'NC_001284'. Pokaże się taki wynik:</p>
<p><img src="genbank/GB-genom.png" alt="Sekwencja genomu mitochondrialnego" /></p>
<p>Jak widać z opisu oraz informacji poniżej znaleźliśmy sekwencję genomu mitochondrialnego <em>Arabidopsis thaliana</em>. Teraz wyszukajmy w niej sekwencję genu <code>cox3</code>. W tym celu w sekcji <code>FEATURES</code> należy znaleźć pole <code>gene</code> z wartością <code>\gene=&quot;cox3&quot;</code>. Ponieważ liczba opisanych sekwencji jest bardzo długa, nie ma sensu przeglądać całości w poszukiwaniu żądanego genu.</p>
<p>Jednym ze sposobów znalezienia go jest użycie wbudowanej w wyszukiwarce internetowej wyszukiwarce tekstu, wywoływanej skrótem &lt;Ctrl+F&gt;. W okienku wpisujemy <code>cox3</code> i szukamy odpowiedniej części wyniku.</p>
<p><img src="genbank/GB-gen-w-genomie.png" alt="Gen w genomie" /></p>
<p>Pole <code>gene</code> odnosi się do regionu oznaczonego jako gen, niekoniecznie zawierający wyłącznie miejsca kodujące. Te są opisane w części oznaczonej jako <code>CDS</code> (<em>coding sequence</em>).</p>
<p>Przy <code>gene</code> mamy podany zakres odcinka <code>217631..217639</code>, dla <code>CDS</code> jest to <code>218280..219077</code>. Mamy też podane inne, dotyczące genu informacje jak miejsce zajmowane przez promotor czy miejsca edycji RNA. Dla <code>CDS</code> jest także pokazana sekwencja aminokwasów.</p>
<p>Kliknij teraz na <code>gene</code>.</p>
<p><img src="genbank/GB-gen.png" alt="Fragment gene" /></p>
<p>Pokazuje się, zaznaczony na brązowo, fragment genomu mitochondrialnego odpowiadający żądanej sekwencji. Na dole pojawia się także pasek nawigacyjny pomiędzy cechami (<code>Features</code>), ,,dymek'' z różnymi informacjami a także linki umożliwiające wyświetlenie sekwencji w odpowiednim formacie, w tym <code>FASTA</code>.</p>
<p>Jeśli zamiast <code>gene</code> klikniemy <code>CDS</code> otrzymamy podobny wynik, ale z informacjami charakterystycznymi dla sekwencji kodującej:</p>
<p><img src="genbank/GB-CDS.png" alt="Fragment CDS" /></p>
<p>Po kliknięciu w link <code>FASTA</code>  na dole ekranu pojawia się sekwencja w formacie <code>FASTA</code>.</p>
<p><img src="genbank/GB-CDS-FASTA.png" alt="Fragment CDS w formacie FASTA" /></p>
<p>Podobny widok widzieliśmy wcześniej ale zwróć uwagę, ze po prawej znajduje się okienko, w którym znajdują się edytowalne pola z zakresem wyświetlanej sekwencji. Czasem chcemy pobrać nieco dłuższy (lub krótszy) fragment niż wyświetlany domyślnie, wtedy można zmienić numery i kliknąć <code>Update View</code>. Wyświetli się zmodyfikowany zakres nici DNA.</p>
<p><img src="genbank/GB-CDS-FASTA-zmieniony.png" alt="Fragment CDS w formacie FASTA - poszerzony zakres" /></p>
<p>Sekwencję można pobrać tak jak opisywałem poprzednio.</p>
<a class="header" href="#sekwencje-komplementarne" id="sekwencje-komplementarne"><h2>Sekwencje komplementarne</h2></a>
<p>Czasem przy opisie sekwencji znajdujemy informację, że jest ona komplementarna (<code>complement</code>), co oznacza, że znajduje się ona na nici komplementarnej. Znajdź gen <code>rpl16</code>.</p>
<p><img src="genbank/GB-complement.png" alt="Sekwencja na nici komplementarnej" /></p>
<p>Taka sekwencja przy dopasowaniu do innych powinna być przekształcona w sekwencję odwróconą komplementarną. Na szczęście jeśli wyświetlimy ten fragment w formacie <code>FASTA</code> otrzymamy od razu sekwencję w odpowiedniej formie. Zauważ, że zakres sekwencji jest podany w odwrotnej kolejności:</p>
<p><img src="genbank/GB-comlement-FASTA.png" alt="Sekwencja odwrócona komplementarna" /></p>
<a class="header" href="#sekwencje-we-fragmentach" id="sekwencje-we-fragmentach"><h2>Sekwencje we fragmentach</h2></a>
<p>Znajdź teraz gen <code>nad2</code>.</p>
<p><img src="genbank/GB-join.png" alt="Gen we fragmentach" /></p>
<p>Zauważ, że przy opisie genu znajduje się nie tylko informacja, że jest ona komplementarna ale, że aby uzyskać sekwencję genu (lub <code>CDS</code>) trzeba połączyć kilka fragmentów (<code>join</code>). Czasem niektóre fragmenty są komplementarne inne nie, mogą też pochodzić z różnych sekwencji w bazie (np. rożnych chromosomów). Sprawdź na przykład gen <code>nad1</code> w sekwencji <code>KF754803</code>.  Kompletna, złożona sekwencja powinna pokazać się po kliknięciu linku <code>FASTA</code> w lewym dolnym rogu, ale nie zawsze to działa. W takim wypadku można po kolei wyświetlać kolejne fragmenty genomu w formacie <code>FASTA</code> (jak pokazałem powyżej) a następnie je łączyć w edytorze tekstu lub programie do obróbki sekwencji. Jeśli sekwencja jest komplementarna, jak w przypadku <code>nad2</code>, trzeba będzie ją zmienić na odwróconą, komplementarną. Łączenie fragmentów może być nużące, jest to jeden z przypadków, w których wygodniejsze może być użycie narzędzi działających w linii komend.</p>
<a class="header" href="#pobieranie-sekwencji-z-bazy-genbank-i-praca-w-plikami-fasta-przy-pomocy-linii-komend" id="pobieranie-sekwencji-z-bazy-genbank-i-praca-w-plikami-fasta-przy-pomocy-linii-komend"><h1>Pobieranie sekwencji z bazy GenBank i praca w plikami <code>FASTA</code> przy pomocy linii komend</h1></a>
<a class="header" href="#dlaczego-linia-komend" id="dlaczego-linia-komend"><h2>Dlaczego linia komend?</h2></a>
<p>Pobieranie sekwencji przy użyciu narzędzi uruchamianych z linii komend jest w niektórych sytuacjach łatwiejsze, zwłaszcza gdy wiemy, które sekwencje (albo ich fragmenty) i/lub chcemy pobrać ich wiele.</p>
<a class="header" href="#dostęp-do-genbank-u-przy-pomocy-narzędzi-entrez-direct" id="dostęp-do-genbank-u-przy-pomocy-narzędzi-entrez-direct"><h2>Dostęp do GenBank-u przy pomocy narzędzi Entrez Direct</h2></a>
<p>,,Entrez Direct'' to grupa programów opublikowanych przez NCBI umożliwiających dostęp do baz danych tej organizacji. Podręcznik do pakietu (wraz z instrukcją instalacji) pt. <a href="https://www.ncbi.nlm.nih.gov/books/NBK179288/">Entrez Direct: E-utilities on the UNIX Command Line</a> można znaleźć pod adresem <a href="https://www.ncbi.nlm.nih.gov/books/NBK179288/">https://www.ncbi.nlm.nih.gov/books/NBK179288/</a>. Nie będziemy oczywiście poznawać dogłębnie wszystkich narzędzi ale pokażę kilka przydatnych komend i sposobów ich wykorzystania.</p>
<a class="header" href="#wyszukiwanie-sekwencji---esearch" id="wyszukiwanie-sekwencji---esearch"><h3>Wyszukiwanie sekwencji - <code>esearch</code></h3></a>
<p>Do wyszukiwania informacji w bazach danych służy narzędzie <code>esearch</code>. Przy podstawowym użyciu, przyjmuje dwa argumenty:</p>
<ul>
<li><code>-db</code> - określający bazę do której zostanie wysłane zapytanie</li>
<li><code>-query</code> - zapytanie</li>
</ul>
<p>Wywołanie programu będzie wyglądało tak:</p>
<pre><code>esearch -db identyfikator_bazy -query zapytanie
</code></pre>
<p>Jeśli zapytanie składa się z wielu słów, należy je zamknąć w cudzysłowach.</p>
<p>Lista identyfikatorów wybranych baz danych znajduje się pod adresem <a href="https://www.ncbi.nlm.nih.gov/books/NBK25497/table/chapter2.T._entrez_unique_identifiers_ui/?report=objectonly">https://www.ncbi.nlm.nih.gov/books/NBK25497/table/chapter2.T._entrez_unique_identifiers_ui/?report=objectonly</a>. Jak widać jest ich wiele. Nas będzie interesowała teraz baza ,,Nucleotide'', która ma identyfikator <code>nuccore</code> lub <code>nucleotide</code>. To właśnie z niej wcześniej korzystaliśmy przez stronę internetową.</p>
<p>Warto też przejrzeć wbudowaną pomoc programu, gdzie znajdziemy nie tylko identyfikatory baz ale też opisy innych opcji programu. Uruchamiamy ją wpisując:</p>
<pre><code>$: esearch -h
</code></pre>
<p>Uruchom  polecenie:</p>
<pre><code>$: esearch -db nucleotide -query &quot;atp6 Orobanche&quot;
</code></pre>
<p>Pokaże się wynik:</p>
<pre><code>&lt;ENTREZ_DIRECT&gt;
  &lt;Db&gt;nucleotide&lt;/Db&gt;
  &lt;WebEnv&gt;NCID_1_33234224_130.14.18.34_9001_1517069868_100176055_0MetA0_S_MegaStore_F_1&lt;/WebEnv&gt;
  &lt;QueryKey&gt;1&lt;/QueryKey&gt;
  &lt;Count&gt;17&lt;/Count&gt;
  &lt;Step&gt;1&lt;/Step&gt;
&lt;/ENTREZ_DIRECT&gt;
</code></pre>
<p>Nie wydaje się zbyt przydatny, ale można zrozumieć, że znaleziono 17 wyników. Nie widać żadnych sekwencji. Zaraz pokażę jak uzyskać bardziej użyteczny rezultat.</p>
<a class="header" href="#pobieranie-sekwencji---efetch" id="pobieranie-sekwencji---efetch"><h3>Pobieranie sekwencji - <code>efetch</code></h3></a>
<p>Drugim narzędziem pakietu Entrez Direct z którego będziemy korzystać jest <code>efetch</code> służący, jak wskazuje nazwa, do pobierania danych.</p>
<p>Znając numer dostępowy sekwencji można ją pobrać w ten sposób:</p>
<pre><code>efetch -db identyfikator_bazy -format format_wyniku -id numer_dostępowy
</code></pre>
<p>Na przykład:</p>
<pre><code>$: efetch -db nucleotide -id KU180461 -format fasta
</code></pre>
<p>Wynik jest zgodny z oczekiwaniami:</p>
<pre><code>&gt;KU180461.1 Orobanche coerulescens clone 12 ATPase subunit 6 (atp6) gene, partial cds; mitochondrial
CTGCTAACTCTCAGTTTGGTCCTACTTCTGATTCATTTTGTTACTAAAAAGGGAGGAGGAAACTCAGTAC
CAAATGCTTGGCAATCCGTGGTAGAGTTTATTTATGATTTCGTGCTGAACCTGGTAAACGAACAAATAGG
GGGTCTTTCCGGAAATGTTAAACAAAAGTTTTTCCCTTGCATCTTGGTCACTTTTACTTTTTTGTTATTT
TGTAATCTTCAGGGTATGATACCTTATAGCTTCACAGTTACAAGTCATTTTCTCATTACTTTAGGTCTCT
CATTTTCTCTTTTTATTGGCATTACTATAGTGGGATTTCAAAGAAATGGGCTTCATTTTTTAAGCTTCTT
ATTACCCGCAGGAGTCCCACTGCCATTAGCACCTTTTTTAGTACTCCTTGAGCTAATTTCTTATTGTTTT
CGCGCATTAAGCTTAGGAATACGTTTATTTGCTAATATGATGGCCGGTCATAGTTTAGTAAAGATTTTAA
GTGGGTTCGCTTGGACTATGCTATGTATGAATGATCTTTTGTATTTTATAGGGGATCTTGGTCCTTTATT
TATAGTTCTTGCATTAACCGGTCTTGAATTAGGTGTAGCTATATCACAAGCTCATGTTTCTACGATCTCA
ATCTGTATTTAC
</code></pre>
<p>Wynik oczywiście możemy zapisać w pliku używając znaku <code>&gt;</code>:</p>
<pre><code>efetch -db nucleotide -id KU180461 -format fasta &gt; atp6.fasta
</code></pre>
<p>Przejrzyj pomoc programu, którą wywołasz komendą:</p>
<pre><code>efetch -h
</code></pre>
<p>Poeksperymentuj z różnymi formatami wyniku.</p>
<p>Teraz sprobujemy użyć polecenia <code>efetch</code> do pobrania serii sekwencji, tych samych, które należało pobrać przy pomocy przeglądarki w poprzedniej części.
Zapisz ich numery, po jeden w każdej linii w pliku <code>atp6_numery.txt</code></p>
<pre><code>KU180471
KU180476
FJ595983
KC879635
HQ593782
KU180469
KU180474
KU180475
KU180468
KU180466
AF095276
</code></pre>
<p>Teraz napiszemy skrypt (<code>, który w pętli będzie kolejno odczytywał numery sekwencji i przekazywał je do polecenia</code>efetch`, które będzie je pobierało i zapisywało w pliku. Nazwę pliku z danymi i nazwę pliku wynikowego będziemy podawać jako argumenty przy wywoływaniu skryptu.</p>
<pre><code>#!/bin/bash

# Nazwa pliku z danymi podana jako pierwszy argument
dane=$1
# Nazwa pliku wynikowego podana jako drugi argument
fileout=$2

# Tworzony jest plik wynikowy, jeśli istnieje zostaje nadpisany
echo &gt; $fileout

# Pętla odczytująca numery sekwencji z pliku $dane,
# są one przechowywane w zmiennej nrGB
while read nrGB
do
    # Informacje o obieraniu i zapisywaniu sekwencji
    echo &quot;Pobieram sekwencję $nrGB i zapisuję do pliku $fileout&quot;
    # Pobieranie i zapisywanie sekwencji
    efetch -db nucleotide -id $nrGB -format fasta &gt;&gt; $fileout
done &lt; $dane
</code></pre>
<p>Następnie uruchamiamy skrypt:</p>
<pre><code>$: ./pobierz_sekwencje.sh atp6_numery.txt atp6_sekwencje.fasta

Pobieram sekwencję KU180471 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję KU180476 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję FJ595983 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję KC879635 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję HQ593782 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję KU180469 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję KU180474 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję KU180475 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję KU180468 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję KU180466 i zapisuję do pliku atp6_sekwencje.fasta
Pobieram sekwencję AF095276 i zapisuję do pliku atp6_sekwencje.fasta
</code></pre>
<p>Sprawdź zawartość pliku wynikowego.</p>
<a class="header" href="#efetch---pobieranie-fragmentów-sekwencji" id="efetch---pobieranie-fragmentów-sekwencji"><h2><code>efetch</code> - pobieranie fragmentów sekwencji</h2></a>
<p>Dzięki programowi <code>efetch</code> można też uzyskać fragment sekwencji podając miejsce pierwszego i ostatniego nukleotydu żądanego fragmentu. Służą do tego opcje: <code>-seq_start</code> i <code>-seq_stop</code>.</p>
<p>Na przykład wytnijmy sekwencję genu <code>nad2</code> z genomu mitochondrialnego <em>Arabidopsis thaliana</em> o identyfikatorze <code>NC_001284</code>. Miejsca początku i końca genu odczytamy z wyniku wyszukiwania:</p>
<p><img src="genbank_cli/start_stop.png" alt="Zakres genu" /></p>
<p>Teraz przekażmy je do polecenia:</p>
<pre><code>efetch -db nuccore -id NC_001284 -format fasta -seq_start 134071 -seq_stop 138153
</code></pre>
<p>Otrzymamy żądany fragment genomu.</p>
<p>Teraz powróćmy do problemu pobieraniu sekwencji we fragmentach z którym zetknęliśmy się <a href="cwiczenia/16-genbank.html">w lekcji poświęconej pobieraniu sekwencji z GenBank-u przy pomocy strony internetowej</a>. Sekwencja genu <code>nad2</code> w genomie <em>Arabidopsis thaliana</em> (nr. NC_001284) występowała tam w dwu, oddzielonych od siebie fragmentach, przy czym część kodująca (<code>CDS</code>) miała aż pięć części.</p>
<p><img src="genbank/GB-join.png" alt="nad2 u Arabidopsis thaliana" /></p>
<p>W dodatku były to sekwencje komplementarne (i odwrócone). Teraz pokażę jak używając prostego skryptu pobrać żądane fragmenty i połączyć je w jedną sekwencję.</p>
<p>Można oczywiście po kolei wykonywać polecenia pobierania fragmentów z sekwencji, za pomocą narzędzia <code>efetch</code> jak pokazałem powyżej i dołączać wyniki do pliku <code>FASTA</code>.</p>
<pre><code>efetch -db nuccore -id NC_001284 -format fasta -seq_start 327890 -seq_stop 328078 &gt; nad2_A_thaliana.fasta
efetch -db nuccore -id NC_001284 -format fasta -seq_start 329735 -seq_stop 330306 &gt;&gt; nad2_A_thaliana.fasta
efetch -db nuccore -id NC_001284 -format fasta -seq_start 332945 -seq_stop 333105 &gt;&gt; nad2_A_thaliana.fasta
efetch -db nuccore -id NC_001284 -format fasta -seq_start 79740 -seq_stop 80132 &gt;&gt; nad2_A_thaliana.fasta
efetch -db nuccore -id NC_001284 -format fasta -seq_start 81113 -seq_stop 81297 &gt;&gt; nad2_A_thaliana.fasta
</code></pre>
<p>Komendy możesz wpisywać i uruchamiać w terminalu, albo umieścić je w skrypcie (np. <code>pobierz_odcinki.sh</code>) i go uruchomić.</p>
<p>Otrzymany plik będzie miał taką zawartość:</p>
<pre><code>
&gt;NC_001284.2:327890-328078 Arabidopsis thaliana mitochondrion, complete genome
TTAAAGATATGAACTGAGTGCCATTTGATGAGTAACTGAGAACAAAGGAGAGGGGTATAGCAAGGATGAA
GTAATGAAAAAGGAAGTCATTGCTAGTAGTAACGACTTATTACGATCCATTGGTTCATATAGAATCCATG
TCCTAGGTGTATCAAAAAACATTCTTTTCACTAAGCGTATATAATAAAA
&gt;NC_001284.2:329735-330306 Arabidopsis thaliana mitochondrion, complete genome
ACGACCTATAACGCTAGTCACTACTCCCACTGGGGCTAGAAAGTAAGCCCCACAACCCAAAGCGGCGAAG
AACAAATAGAATTTGCTACAAAAGCCGGCTAACGGGGGTATTCCTGCGTATGAGAACATAGTAATGGAGA
AGGTAATAGCCGAAATAGGATTCGTTTTGGCTAGAGCGCCCAAATCCGCTATATATTTGACACGGGTTTG
CCGTAATGCTGAAACTATGGCGAATGCATCCATCGTCATTAATGCATAAATAAAGATACCAATTAGTAGT
GATTGAATTCCTTCTATGGTTCCACATGAGAAACCAGTACGAATATAACCTACATGTCCAATTGAACTAT
GAGCTAGAGGTCTTTTGACTTTCGTTTGGGCCATGGCGGCCAGTGCTCCTAAGATCATAGAAGCAATGCT
GCAGAAAAAGAAGATTTGTTGCAATGTAGCTCCATAGGAACCATAAATAGAAACACGTAAAATATTAGCA
GAAATAGAGATTTTAGGCGCAATAGAAAGGAATGCTGTAACCGGGGTGGGTGAACCCTCATAGATATCTG
GTGCCCACATAT
&gt;NC_001284.2:332945-333105 Arabidopsis thaliana mitochondrion, complete genome
GAAAAGGAACTGCAGTGATCTTGAATAGGAATCCTACAGCGATAGACAGAATCCCCATAAAAATACCACT
AGATCGAGCACCAGTGATTTCGTATCCGGTCAAAATCTTGGCTAATTGATCGAAGTGGGTAGCTCCAGTA
GACCCATAGATCATGGAACAA
&gt;NC_001284.2:79740-80132 Arabidopsis thaliana mitochondrion, complete genome
CCAAACAATAATATTCCAGAGGAAAATGCACCTAAGATCAAATATTTCGAGCCGGCTTCCGTGGAAAATT
CAGACTTTCTTTTTGATGCTGCGATTACATAAAAACATAAACTTTGAGGCTCAATAGCTAAATACATGGC
AATTAAATCATGAGCCGAGATCATAAAGAGCATACCGCGAGTAGGAAGTGGAATTAATACAATGAATTCA
AAAGCATCAAACCTCTCTTGGTCGGAAGAATCGAAACACATCGAAATGGTACCAGCCGTACTTAATAATA
GAAAGATTTGGCAGAAATATGTAAAATTGTCCCTCCTAAAAAGATTATTCCAGAATAAATGGGCAATAGT
TAGGAGAGGTGCGCCAGCGGCGAGCAGAAGCAAGGTTATTAGA
&gt;NC_001284.2:81113-81297 Arabidopsis thaliana mitochondrion, complete genome
ACACTAAGTAATCCAAGCCAACCCACATTACTGGCTAACGGCGGATAATCATATTTCTTAGAGGTACTAA
ATACAACTCCATGAATGAGCAAAATGGAGGTTGCATTAATGATAAAGATCTCTGGGGAAACCGCTAAAAA
AAGATTGAACATGTGTGGGAGGATCCGAACGAATTCTGCTTTCAT
</code></pre>
<p>Zamiast uruchamiać wielokrotnie tą samą komendę, można utworzyć plik tekstowy z miejscami początku i końca fragmentów sekwencji a następnie stworzyć skrypt, który w pętli po kolei je pobierze i umieści w pliku.</p>
<p>Najpierw utworzymy plik, w którym zapiszemy kolejne miejsca początku i końca fragmentów sekwencji oddzielone znakiem tabulatora (<code>odcinki.tsv</code>).</p>
<pre><code>327890	328078
329735	330306
332945	333105
79740	80132
81113	81297
</code></pre>
<p>Teraz skrypt:</p>
<pre><code>#!/bin/bash
# Plik z danymi podany jako argument 1 przy uruchamianiu skryptu
data=$1
# Plik wyjściowy podany jako argument 2 przy uruchamianiu skryptu
fileout=$2
# Numer sekwencji w GenBank-u podany jako argument 3
nrGB=$3

# Tworzymy plik wejściowy, jeśli już istnieje to jego zawartość zostaje usunięta
echo &gt; $fileout

# Pętla. Wartości start i stop odczytywane są z pliku $data
while read start stop
do
    # Skrypt informuje, który fragment pobiera
    echo &quot;Pobieram fragment: $start - $stop z sekwencji $nrGB i zapisuję do pliku $fileout&quot;
    # Pobranie fragmentu i zapisanie do pliku
    efetch -db nuccore -id $nrGB -format fasta -seq_start $start -seq_stop $stop &gt;&gt; $fileout
done &lt; $data
</code></pre>
<pre><code>$: ./pobierz_odcinki_petla.sh odcinki.tsv nad2_A_thaliana.fasta NC_001284 

Pobieram fragment: 327890 - 328078 z sekwencji NC_001284 i zapisuję do pliku nad2_A_thaliana.fasta
Pobieram fragment: 329735 - 330306 z sekwencji NC_001284 i zapisuję do pliku nad2_A_thaliana.fasta
Pobieram fragment: 332945 - 333105 z sekwencji NC_001284 i zapisuję do pliku nad2_A_thaliana.fasta
Pobieram fragment: 79740 - 80132 z sekwencji NC_001284 i zapisuję do pliku nad2_A_thaliana.fasta
Pobieram fragment: 81113 - 81297 z sekwencji NC_001284 i zapisuję do pliku nad2_A_thaliana.fasta
</code></pre>
<p>Sprawdź plik wynikowy.</p>
<a class="header" href="#Łączymy-efetch-sed-tr-i-rev" id="Łączymy-efetch-sed-tr-i-rev"><h2>Łączymy <code>efetch</code>, <code>sed</code>, <code>tr</code> i <code>rev</code></h2></a>
<p>Jak widać poszczególne fragmenty występują oddzielnie. Teraz powinniśmy połączyć je w jedną sekwencję. Można to zrobić w edytorze tekstu ale od czego mamy linię komend i narzędzia <a href="cwiczenia/12-pliki_tekstowe.html"><code>sed</code>, <code>tr</code> i <code>rev</code></a>?</p>
<p>Zadanie wykonamy w pięciu etapach:</p>
<ol>
<li>Usuniemy linie z opisami sekwencji</li>
<li>Połączymy fragmenty w jedną sekwencję</li>
<li>Przekształcimy ją w sekwencję komplementarną</li>
<li>Odwrócimy sekwencje</li>
<li>Dodamy opis w pierwszej linii pliku</li>
</ol>
<p>Zastanów się, najpierw ogólnie, jak te zadania zrealizować używając programów <code>sed</code>, <code>tr</code> i <code>rev</code>?</p>
<ol>
<li>Usunąć linie zaczynające się od znaku <code>&gt;</code>: <code>tr</code> lub <code>sed</code></li>
<li>Usunąć wszystkie znaki końca linii: <code>\n</code>: <code>tr</code></li>
<li>Zmienić na sekwencję komplementarną: <code>tr</code></li>
<li>Odwrócić sekwencję: <code>rev</code></li>
<li>Wprowadzić do pierwszej linii pliku opis sekwencji</li>
</ol>
<p>Teraz przekształćmy pomysł w konkretny kod. Utwórz skrypt <code>polacz_odcinki.sh</code>:</p>
<pre><code>#!/bin/bash

# Nazwa pliku z sekwencjami
surowy=nad2_A_thaliana.fasta
# Plik wyjściowy
file=polaczony_$surowy

# Kopiujemy plik z sekwencjami do pliku wyjściowego, 
# który będziemy modyfikować
cp $surowy $file

# Usuwanie linii z opisami, czyli linii zaczynających się od znaku &gt; 
sed -i '/^&gt;/d' $file

# Łączymy wszystkie linie w jedną, usuwając oznaczenia końca linii
# Wynik umieszczamy w pliku tymczasowym
cat $file | tr -d &quot;\n&quot; &gt; $file.tmp

# Zmieniamy na sekwencję komplementarną, wynik umieszczamy 
# w drugim pliku wyjściowym

cat $file.tmp | tr &quot;ACGT&quot; &quot;TGCA&quot; &gt; $file.tmp2
# Odwracamy sekwencję, wynik umieszczamy w pliku wyjściowym 
# zmieniając jego zawartość

cat $file.tmp2 | rev &gt; $file

# Wstawiamy pierwszą linię z opisem i znak nowej linii
sed -i '1s/^/&gt;NC_001284_Arabidopsis_thaliana_nad2\n/' $file

# Usuwamy pliki tymczasowe
rm $file.tmp*

</code></pre>
<p>Można też skonstruować ,,jednolinijkowca'':</p>
<pre><code>cat nad2_A_thaliana.fasta | sed '/^&gt;/d' | tr -d &quot;\n&quot; | tr &quot;ACGT&quot; &quot;TGCA&quot; | rev | sed '1s/^/&gt;NC_001284_Arabidopsis_thaliana_nad2\n/' &gt; polaczony_RC_nad2_A_thaliana.fasta
</code></pre>
<a class="header" href="#Łączymy-esearch-i-efetch" id="Łączymy-esearch-i-efetch"><h2>Łączymy <code>esearch</code> i <code>efetch</code></h2></a>
<p>Dotychczas używaliśmy dwu narzędzi: służący do wyszukiwania <code>esearch</code> i pobierający sekwencje <code>efetch</code> oddzielnie. Ale możemy je razem połączyć za pomocą potoku tak aby wyszukiwanie połączyć z pobieraniem.</p>
<pre><code>esearch -db nucleotide -query &quot;atp6[All Fields] AND Orobanche[Organism]&quot; | efetch -format fasta &gt; atp6_Orobanche.fasta
</code></pre>
<a class="header" href="#samtools-faidx--pobieranie-sekwencji-z-pliku-fasta" id="samtools-faidx--pobieranie-sekwencji-z-pliku-fasta"><h2><code>samtools faidx</code>- pobieranie sekwencji z pliku <code>FASTA</code></h2></a>
<p>Pobierz plik <code>http://ggoralski.pl/files/filogenetyka-data/Orobanchaceae-trnL-trnF-aligned.fasta</code></p>
<p>Sprawdź jego zawartość. Używaliśmy go już we wcześniejszych ćwiczeniach, zawiera wyrównane sewkencje <code>trnL-trnF</code>.</p>
<p>Teraz sprawdź nazwy sekwencji używając komendy <code>grep</code>:</p>
<pre><code>$: grep &quot;&gt;&quot; Orobanchaceae-trnL-trnF-aligned.fasta 

&gt;KY484464_O._teucrii
&gt;KY484493_O._flava
&gt;KY484489_O._mayeri
&gt;KY484471_O._kochii
&gt;KY484474_O._elatior
&gt;KU238865_O._coerulescens
&gt;KY484502_P._ramosa
&gt;KY484503_P._purpurea
&gt;KX524675_Lindenbergia_siniaca
</code></pre>
<p>Teraz będziemy chcieli pobrać z pliku sekwencję o nazwie <code>KX524675_Lindenbergia_siniaca</code>. Można to zrobić oczywiście używając edytora tekstu lub programu do pracy z plikami <code>FASTA</code>, ale czasem wygodniej to zrobić używając linii komend. Użyjemy do tego zadania programu <code>faidx</code>, który jest częścią pakietu <code>samtools</code>.</p>
<p>Pakiet <code>samtools</code> zawiera wiele przydatnych programów do pracy z sekwencjami, przede wszystkim w innych formatach niż <code>FASTA</code>, ale <code>faidx</code> jest dość przydatne w codziennej pracy także w tym formacie.</p>
<p>Strona domowa projektu znajduje się pod adresem: <a href="http://www.htslib.org/">http://www.htslib.org/</a>. Tam też można przeczytać manuale programów.</p>
<p>Na Debianie można zainstalować pakiet komendą:</p>
<pre><code>sudo apt-get install samtools
</code></pre>
<p>W innym przypadku, można pobrać pliki źródłowe ze strony i skompilować wg. znajdującej się tam instrukcji.</p>
<p>Uruchamianie narzędzi z pakietu <code>samtools</code> wygląda następująco:</p>
<pre><code>samtools nazwa_narzedzia opcje
</code></pre>
<p>W przypadku <code>faidx</code> będzie to wyglądało tak:</p>
<pre><code>samtools faidx opcje
</code></pre>
<p>Opcjami, które użyjemy będzie kolejno nazwa pliku, z którego pobierzemy sekwencję i nazwa sekwencji.
Uruchom:</p>
<pre><code>samtools faidx Orobanchaceae-trnL-trnF-aligned.fasta KX524675_Lindenbergia_siniaca
</code></pre>
<p>Na ekranie wyświetli się żądana sekwencja, oczywiście można ją zapisać w pliku używając <code>&gt;</code>.</p>
<p>Zauważ, że podajemy pełną nazwę sekwencji (bez znaku <code>&gt;</code>), wpisanie jej fragmentu nie zadziała. Może to być pewnym mankamentem, na przykład gdy nazwy są długie albo gdy chcemy pobrać wiele sekwencji, których nazwy mają jakąś część wspólną (np. nazwę rodzaju.). W taki przypadku pomocne będzie polecenie <code>grep</code>.</p>
<p>Uruchom:</p>
<pre><code>$: grep &quot;O.&quot; Orobanchaceae-trnL-trnF-aligned.fasta

&gt;KY484464_O._teucrii
&gt;KY484493_O._flava
&gt;KY484489_O._mayeri
&gt;KY484471_O._kochii
&gt;KY484474_O._elatior
&gt;KU238865_O._coerulescens
</code></pre>
<p>W ten sposób otrzymujemy pełne nazwy wszystkich sekwencji należących do <em>Orobanche</em>. Teraz powinniśmy je przekazać do polecenia <code>faidx</code>, ale najpierw musimy pozbyć się znaków <code>&gt;</code>:</p>
<pre><code>$: grep &quot;O.&quot; Orobanchaceae-trnL-trnF-aligned.fasta | sed 's/&gt;//'

KY484464_O._teucrii
KY484493_O._flava
KY484489_O._mayeri
KY484471_O._kochii
KY484474_O._elatior
KU238865_O._coerulescens
</code></pre>
<p>Czas użyć ich przy wywołaniu <code>faidx</code>. Polecenie:</p>
<pre><code>grep &quot;O.&quot; Orobanchaceae-trnL-trnF-aligned.fasta | sed 's/&gt;//' | samtools faidx Orobanchaceae-trnL-trnF-aligned.fasta
</code></pre>
<p>nie zadziała. Trzeba wykorzystać <code>xargs</code>:</p>
<pre><code>grep &quot;O.&quot; Orobanchaceae-trnL-trnF-aligned.fasta | sed 's/&gt;//' | xargs samtools faidx Orobanchaceae-trnL-trnF-aligned.fasta &gt; Orobanche-trnL-trnF.fasta
</code></pre>
<p>Sprawdź zawartość pliku wynikowego.</p>
<p>Przy okazji pobierania sekwencji, można je oczywiście zmodyfikować. Na przykład możemy zmienić skrót <code>O.</code> na pełną nazwę rodzajową <code>Orobanche</code> i usunąć wszystkie znaki <code>-</code> oznaczające brak nukleotydu. Użyjemy w tym celu poecenia <code>sed</code>. Przy usuwaniu <code>-</code> pamiętaj o dodaniu <code>g</code>, który pozwala na wykonaniu polecenia na wszystkich znakach w linii.:</p>
<pre><code>grep &quot;O.&quot; Orobanchaceae-trnL-trnF-aligned.fasta | sed 's/&gt;//' | xargs samtools faidx Orobanchaceae-trnL-trnF-aligned.fasta | sed 's/O\./Orobanche/' | sed 's/-//g' | &gt; Orobanche-trnL-trnF.fasta
</code></pre>
<a class="header" href="#blast---wyszukiwanie-podobnych-sekwencji" id="blast---wyszukiwanie-podobnych-sekwencji"><h1>BLAST - wyszukiwanie podobnych sekwencji</h1></a>
<a class="header" href="#czym-jest-blast-i-do-czego-służy" id="czym-jest-blast-i-do-czego-służy"><h2>Czym jest BLAST i do czego służy?</h2></a>
<p><a href="https://blast.ncbi.nlm.nih.gov">BLAST</a> to narzędzie, dostępne przez stronę internetową pozwalające znaleźć w bazie danych sekwencje nukleotydowe lub proteinowe podobne do szukanej. Można je znaleźć pod adresem: <a href="https://blast.ncbi.nlm.nih.gov">https://blast.ncbi.nlm.nih.gov</a>. Jak widać w adresie strony, podobnie jak GenBank, BLAST jest udostępniany przez NCBI, oba narzędzia są ze sobą ściśle powiązane. Istnieje także BLAST w formie programu obsługiwanego z linii komend, ale nim nie będziemy posługiwać się na kursie.</p>
<p>BLAST jest potężnym narzędziem o wielu możliwościach. Na kursie poznamy tylko podstawowe funkcje, ograniczone do pracy z sekwencjami DNA.</p>
<a class="header" href="#wyszukanie-podobnej-sekwencji-dna" id="wyszukanie-podobnej-sekwencji-dna"><h2>Wyszukanie podobnej sekwencji DNA</h2></a>
<p>Po wejściu <a href="https://blast.ncbi.nlm.nih.gov">na witrynę BLAST</a> widzimy taką stronę:</p>
<p><img src="blast/blast-start.png" alt="Strona główna BLAST" /></p>
<p>Można na niej wybrać wyszukiwanie sekwencji nukleotydów na podstawie sekwencji nukleotydów, wyszukiwanie sekwencji aminokwasów na podstawie sekwencji aminokwasów, wyszukiwanie sekwencji aminokwasów na podstawie sekwencji nukleotydów lub odwrotnie. Skupimy się na pierwszej możliwości (<code>blastn</code>), kliknij na ,,Nucleotide BLAST'':</p>
<p><img src="blast/nucleotide-blast.png" alt="Wyszukiwanie sekwencji nukleotydów na podstawie sekwencji nukleotydów" />.</p>
<p>Pokazuje się strona wyszukiwarki:</p>
<p><img src="blast/blastn-start.png" alt="BLASTN" /></p>
<p>Pierwsza część służy wprowadzeniu zapytania.</p>
<p><img src="blast/enter-query.png" alt="Wprowadzanie zapytania" /></p>
<p>Jak widać, można przesłać plik z sekwencją w formacie <code>FASTA</code> albo użyć okienka ,,<em>Enter accession number(s), gi(s), or FASTA sequence(s)</em>'' do wprowadzenia sekwencji lub numeru identyfikacyjnego używanego przez GenBank.</p>
<p>Wklej do niego sekwencję:</p>
<pre><code>GGATCTACTGATCGAGGTCACCTTAGAATGGGGTTGTTTTACGGCGTACCTCCCGAACACCCTTTAGCGA
ATAGTTTCCACAACGCTTAGGGGACAGAAGACCCAGCCGGACGATTTGAGGCACGCGGCGGACCGCGTTG
CCCAATACCAAGCGAGGCTTGAGTGGTGAAATGACGCTCGAACAGGCATGCCCCCCGGAATACCAGGGGG
CGCAATGTGCGTTCAAAGATTCRATGATTCACTGAATTCTGCAATTCACATTACTTATCGCATTTCGCTG
CGTTCTTCATCGATGCCAGAACCAAGAGATCCGTTGTTAAAAGTTTTAATTTATTAATTAAGTTTACTCA
GACTGCAAAGTTACGCAAGAGTTTGAAGTGTCCACCCGGAGCCCCCGCCCGAAGGCAGGGTCGCCCCGGA
GGCAACAGAGTCGGACAACAAAGGGTTATGAATAACCAGGCCGAAGCCCGGGCGTTCTTGKAATGATCCC
TCCGCAGGTTCACCTACGGAGACCTTGTTACGACTG
</code></pre>
<p>Jest to fragment sekwencji <a href="https://en.wikipedia.org/wiki/Internal_transcribed_spacer">ITS</a> jednego z gatunków rodzaju <em>Phelipanche</em>. Podczas badań filogenetycznych okazało się, że jedna z otrzymanych sekwencji (którą właśnie umieściliśmy w okienku wyszukiwarki) wyraźnie różni się od pozostałych. Teraz spróbujemy sprawdzić jakie może być jej pochodzenie. Między innymi do takich zadań stworzony został BLAST.</p>
<p>W okienku ,,<em>Job Title</em>'' możemy nadać naszemu wyszukiwaniu jakąś nazwę.
Przy okazji zauważ, że w wielu miejscach znajdują ikony z pytajnikiem, kierujące nas do pomocy.</p>
<p><img src="blast/enter-query-wypelnione.png" alt="Zapytanie" /></p>
<p>Pominiemy sekcję ,,Choose Search Set'', która pozwala zawęzić obszar poszukiwań i przejdziemy do kolejnej ,,Program selection''.</p>
<p><img src="blast/program-selection.png" alt="Wybór programu" /></p>
<p>Tutaj wybieramy stopień podobieństwa wyszukiwanych sekwencji (i używany algorytm). W zależności od tego jaki stopień podobieństwa nas interesuje wybieramy jedną z trzech opcji. Zostawiamy pierwszą, domyślną.</p>
<p>Poniżej znajdujemy przycisk ,,BLAST'', który uruchamia wyszukiwanie oraz, poniżej link ,,<em>Algorithm parameters</em>''. Jak można się domyślić, rozwija on menu pozwalające ustawić parametry wyszukiwania.</p>
<p><img src="blast/algorithm-parameters.png" alt="Parametry algorytmu wyszukiwania" /></p>
<p>Zostawimy domyślne ustawienia i wciskamy przycisk ,,BLAST''.</p>
<p>Pokazuje się strona wyświetlająca postęp wyszukiwania, nie należy jej odświeżać, robi to sama.</p>
<p><img src="blast/blast-postep.png" alt="Wyszukiwanie w toku" /></p>
<p>W końcu otwiera się strona z wynikami. Na górze znajdują się informacje dotyczące wyszukiwania oraz linki do różnych opcji, narzędzi, pobrania wyników  w różnych formatach oraz innych rodzajów podsumowania wyszukiwania.</p>
<p><img src="blast/blast-wynik-naglowek.png" alt="Wynik wyszukiwania - informacje" /></p>
<p>Poniżej widzimy wyniki w formie graficznej:</p>
<p><img src="blast/blast-wynik-grafika.png" alt="Wynik wyszukiwania w formie graficznej" /></p>
<p>Zielonkawy pasek przedstawia sekwencję, którą wysłaliśmy jako zapytanie (,,Query''). Powyżej znajduje się skala wyjaśniająca związek koloru pasków wyników z ich jakością. Poniżej znajdują się paski przedstawiające dopasowane do wyszukiwania sekwencje. Jak widać jakość wszystkich wyników znajduje się w przedziale &gt;200 - co oznacza wysoki stopień dopasowania, co więcej większość z nich obejmuje całą długość wyszukiwanej sekwencji.
Po najechaniu kursorem na pasek z wynikiem pojawia się krótka informacja o sekwencji.</p>
<p><img src="blast/blast-wynik-info.png" alt="Informacja o sekwencji" /></p>
<p>Klikając na pasku, możemy uzyskać nieco więcej informacji w tym numer GenBank-u znalezionej sekwencji a także link do dopasowania sekwencji o czym za chwilę.</p>
<p><img src="blast/blast-wynik-wiecej-informacji.png" alt="Więcej informacji o sekwencji" /></p>
<p>Poniżej sekcji z graficznym przedstawieniem wyników znajduje się sekcja ,,<em>Descriptions</em>'' czyli z opisem wyników wyszukiwania.</p>
<p><img src="blast/blast-wynik-opisy.png" alt="Opis wyników" /></p>
<ul>
<li>Pierwsza kolumna służy do zaznaczania poszczególnych wyników, np. w celu ich pobrania.</li>
<li>Druga (,,<em>Description</em>'') to oczywiście informacja na temat znalezionej sekwencji. Klikając na nią, przechodzimy do przyrównania obu sekwencji w kolejnej sekcji.</li>
<li>Trzecia i czwarta (,,<em>Max score</em>'' i ,,<em>Total score</em>'') to punktacje wyniku, nie będziemy w nie wnikać.</li>
<li>Piąta (,,<em>Query cover</em>'') oznacza stopień pokrycia zapytania przez wynik.</li>
<li>Szósta (,,<em>E-value</em>'') przedstawia ,,znaczenie'' dopasowania (w sensie zbliżonym do terminu ,,znaczący statystycznie''). Wartość E mieści się między 0 a 1. Wartość 1 odpowiada losowemu podobieństwu. Im mniejsza wartość, tym wynik jest bardziej ,,znaczący''. Zauważ, że jest wynik przedstawiany jest w notacji naukowej, więc np. ,,1e-21'' to mniej niż ,,6e-20'' (akurat w tym wyniku dopasowane sekwencje mają wartość 0.0). Domyślnie tabela jest sortowana wg. tej wartości od najmniejszej do największej. Więc na górze znajdują się najbardziej ,,znaczące'' wyniki.</li>
<li>Siódma (,,<em>Ident</em>'') to oczywiście stopień identyczności obu sekwencji</li>
<li>Ósma (,,<em>Accession</em>'') zawiera numer dostępowy Gen-Banku. Klikając na niego, wchodzimy na stronę GenBank-u sekwencji.</li>
</ul>
<p>Zwróć uwagę, jakie organizmy znalazły się na liście. Są to grzyby. Pierwszy wynik należy do <em>Davidella tassiana</em> (inaczej <em>Cladosporium herbarum</em>), który infekuje wiele gatunków roślin, kolejne do znanego alergikom rodzaju <em>Cladosporium</em> obejmujący grzyby rozkładające martwe szczątki organiczne oraz pasożytujące na roślinach. W zasadzie zagadka została już rozwiązana - najprawdopodobniej tajemnicza sekwencja pochodzi od grzyba, który zanieczyścił próbkę. Przyjrzyjmy się  jednak jeszcze niektórym innym informacjom, które dostarcza nam BLAST.</p>
<p>Kolejna sekcja zawiera znalezione przyrównania. Pierwszy rekord wygląda tak:</p>
<p><img src="blast/blast-wynik1-alignments.png" alt="Pierwsze przyrównanie" /></p>
<p>Na samej górze widzimy ikonę umożliwiającą nam pobranie znalezionej sekwencji w całości w formacie <code>FASTA</code>, tylko fragmentu dopasowanego w formacie <code>FASTA</code> lub całej sekwencji w formacie <code>GenBank</code> a także linki do strony GenBank sekwencji i widoku graficznego przyrównania.</p>
<p><img src="blast/blast-wynik-download.png" alt="Pobranie znalezionej sekwencji" /></p>
<p>Dalej umieszczone są informacje na temat sekwencji (z bazy GenBank), jego numer, funkcjonujący jako link do strony z informacjami na temat tej sekwencji w GenBank-u oraz dodatkowe informacje na temat przyrównania. Jak widać jest to sekwencja ITS (18S ribosomal RNA gene, partial sequence; internal transcribed spacer 1, 5.8S ribosomal RNA gene, and internal transcribed spacer 2, complete sequence; and 28S ribosomal RNA gene, partial sequence) należący (co stwierdziliśmy już wcześniej, do <em>Davidiella tassiana</em>.</p>
<p>Poniżej znajduje się informacja dotycząca długości przyrównania oraz linki do strony GenBank-u sekwencji oraz przedstawienia graficznego przyrównania. Po kliknięciu na ten drugi, pokazuje się taki widok.</p>
<p><img src="blast/blast-graphics.png" alt="Widok graficzny przyrównania" /></p>
<p>Nie będziemy go teraz analizować.</p>
<p>Poniżej widać dalsze informacje na temat przyrównania: wynik punktowy (<em>Score</em>), wartość E (<em>Expect</em>), liczby miejsc identycznych (<em>Identities</em>), liczba i udział indeli (<em>Gaps</em>) oraz orientację obu sekwencji (<em>Strand</em>). W tym przypadku orientacja jednej nici jest odwrócona względem drugiej. Warto na to zwrócić uwagę - jak widać BLAST wyszukuje sekwencje niezależnie od ich orientacji. Po wejściu na stronę dopasowanej sekwencji widać, że występuje ona tam w formie odwróconej i komplementarnej względem szukanej.</p>
<p>Poniżej widać przyrównanie obu sekwencji wraz z numerami nukleotydów rozpoczynających i kończących każdy z odcinków. Po numerach widać, że jedna sekwencja jest odwrócona względem drugiej. Linie pionowe łączące nukleotydy oznaczają ich zgodność.</p>
<p>Jeśli nie znamy pozycji systematycznej znalezionych dopasowań, można na stronie sekwencji kliknąć w nazwę organizmy w polu <code>ORGANISM</code>:</p>
<p><img src="blast/organism.png" alt="Pole ORGANISM" /></p>
<p>Zauważ, że nazwa gatunkowa w tym polu nie jest taka sama jak w opisie. Taka rozbieżność nie musi wynikać z błędu ale z różnego nazewnictwa taksonu. Przy okazji ważna uwaga: taksonomia, którą znajdziesz w GenBank-u nie powinna być uważana za oficjalne źródło nazewnictwa i klasyfikacji organizmów, ma ona charakter wyłącznie pomocniczy. Widać to zresztą w uwadze, którą możemy przeczytać na stronie, która otworzy się po kliknięciu:</p>
<p><img src="blast/wynik-taksonomia.png" alt="Pozycja taksonomiczna organizmu" /></p>
<p>Znajdziemy tam także opis pozycji taksonomicznej organizmu. Strona na której znaleźliśmy się jest częścią kolejnej bazy <code>NCBI</code> związanej z GenBankiem. Umożliwia ona m. in. wyszukiwanie sekwencji wg. pozycji taksonomicznej organizmów. Nie będziemy jednak tego tematu teraz rozwijać.</p>
<a class="header" href="#pozycja-taksonomiczna-wyników" id="pozycja-taksonomiczna-wyników"><h2>Pozycja taksonomiczna wyników</h2></a>
<p>Jeśli nie wiemy jaka jest pozycja taksonomiczna organizmów, które znalazły się na liście znalezionych dopasowań można skorzystać z ,,Raportu taksonomicznego''. W tym celu wracamy na górę strony z wynikami i klikamy na <code>Taxonomy report</code>:</p>
<p><img src="blast/blast-wynik-naglowek2.png" alt="Link do Taxonomy report" /></p>
<p>Otrzymujemy raport pokazujący położenie systematyczne organizmów:</p>
<p><img src="blast/blast-taxonomy-report.png" alt="Taxonomy report" /></p>
<a class="header" href="#fragment-genomu" id="fragment-genomu"><h2>Fragment genomu</h2></a>
<p>Wyszukaj następującą sekwencję:</p>
<pre><code>CATGTTAGTGTGCTGTTCATCGACTAGAAGGTGATGGGCGTTCGGATTGACTTCTGAAACGCTTAAGATA
TAGTCAGACTCTACTTGAAAAAGTACAGGGTATCGAAAGAATATCTGTTTATTGGATATTGTAATGAATG
TTACAGCTATTTAGAGGGAAAGTCCTATAATAGGATGAATTCGTATCTGGGATTACTCCAAGCCTTCGCG
GATGCACTAAAGCTTATATTAAAAGAGTACGTAT
</code></pre>
<p>Opis znalezionego dopasowania wygląda tak:</p>
<p><img src="blast/claviceps-sekwencja.png" alt="Dopasowanie sekwencji" /></p>
<p>Jak widać, jest to fragment genomu (40310 do 40553) mitochondrialnego <em>Claviceps purpurea</em> (Buławinki czerwonej). Nie wiemy jednak nic więcej na temat tej sekwencji. W takim przypadku może pomóc przestudiowanie opisu sekwencji na stronie GenBank-u. Nie należy jednak otwierać strony całego genomu ale dopasowanego fragmentu. W Tym celu kliknij na link <code>GenBank</code> we wskazanym miejscu:</p>
<p><img src="blast/claviceps-do-GB.png" alt="Link do dopasowanego fragmentu w GenBank-u" /></p>
<p>Otwiera się strona GenBank z dopasowanym fragmentem i jego opisem:</p>
<p><img src="blast/claviceps-dopasowanie-GB.png" alt="Strona dopasowanego fragmentu w GenBank-u" /></p>
<p>Można z niego wyczytać, że szukana sekwencja należy do genu <code>NAD1</code>.</p>
<a class="header" href="#zadanie-1" id="zadanie-1"><h2>Zadanie</h2></a>
<p>Sprawdź do jakich genów (sekwencji) i jakich organizmów należą następujące sekwencje:</p>
<p>Sekwencja 1:</p>
<pre><code>CTACTCACTCTCAGTTTGGTCCTACTTTTTGTTCATTTTGTTACTAAAAAGGGAGGAGGAAAGTCAGTAC
CAAATGCTTTTCAATCCGTGTTAGAGCTTATTTATGATTTTGTGCCGAACCTGGTAAACGAACAAATAGG
TGGTCTTTCCGGAAATGTGAAACAACAGTTTTTCCCTTGCATCTCGGTTACTTTTACTTTTTCGTTATTT
CGTAATCTTCAGGGTATGATACCTTATAGCTTCACAGTAACAAGTCATTTTATCGTTACTTTGGGTCTCT
CATTTTCTCTTTTTATTGGCATTACTATAGTGGGATTTCAAAAAAATGGGCTTCATTTTTTAAGCTTCTC
ATTACCCGCAGGAGTCCCACTGCCGTTAGCACCTTTTTTAGTACTCCTTGAGCTAATCCCTCATTGTTTT
CGCGCATTAAGCTTAGGAATACGTTTATTTGCTAATATGATGGCCGGTCATAGTTTAGTAAAGATTTTAA
GTGGGTTCGCTTGGACTATGCTATGTATGAATGATCTTTTATATTTCATAGGGGATCCTGGTCCTTTATT
TATAGTTCTTGCATTAACCGGTCTTGAATTAGGTGTAGCTATATCACAAGCTCATGTTTCTACGATCTCA
ATCTGTATTTAC
</code></pre>
<p>Sekwencja 2:</p>
<pre><code>GGGGCTGCGTGCAGACACACCAAGGAAAAAGCTCCAGGAACCAAATGAATAACATTGTGTTGGGGTGGAA
CTCCCTCGAAATTAGGAAAGAAGGGCTTTATACATATAATGCACACGTATAAATACTGACATAGCAAACG
ATTAATCACGGAACCCATATCATAATATAGGTTCTTTATTT
</code></pre>
<p>Sekwencja 3:</p>
<pre><code>AATAAATCCAGTTTACTGATTGTGAAACGATTAATTACTCGAATGTATCAACAGAATTATTGGATTATTT
CTACTAATGATTCATCGAATCAAAATAGATTTTGGGCGCGCAACAATAATTTGTATTCTCAAATCATATC
AGAGGGGTTTGCTTTTATTGTGGAAATTCCATTTAATCTACGATTAATATCTTGTCTAGAAGGGAAAAAT
CAAAAGATAGTAAAATCTCAGAATTTACGATCAATTCATTCAATATTTCCCTTTTTAGAGGACAATTTTT
CACATTTAAATTTTTTATTAGATATACTAATACCCCACCCTGTCCATGGGGAAATCTTGGTTCAAACTCT
TCGCTATTGGGTAAAAGATGCTTCTTCTTTGCATTTATTACGATTCTTTCTCAACAAGTATTGGAGTCTT
ATTACTCCAAAGAAAGCCAGTTCCTTTTTTTCAAAAAGGAATCAAAGATTATTCTTATTCTTATATAATT
CTCATGTATGTGAATATGAATCTATTTTAGTCTTTCTACGTAACCAATCTTCTCATTTACGATCAACATC
TTTTGGAGTTCTTCTTGAACGAATCTATTTCTATGGAAAAATAGAACGTCTTGTGAACCTTTTTGTTAAG
GTTAAGGGTTTTCGGGCGAACCTATGGTTGTTCAAGGAACCTTGTATGCATTCTATTAGGTATCAAAGAA
AATCTATTCTGGCTTTAAAAGGGACGTC
</code></pre>
<p><a href="cwiczenia/../README.html">← Spis treści</a></p>
<a class="header" href="#dopasowanie-sekwencji-1" id="dopasowanie-sekwencji-1"><h1>Dopasowanie sekwencji</h1></a>
<p>Kolejnym etapem budowania drzew filogenetycznych jest dopasowanie sekwencji. Jest to bardzo ważny proces, złe dopasowanie sekwencji skutkuje utworzeniem nieprawidłowych drzew.</p>
<a class="header" href="#etapy-i-programy" id="etapy-i-programy"><h2>Etapy i programy</h2></a>
<p>Po zebraniu sekwencji w pliku <code>FASTA</code> przechodzimy do ich dopasowania. Dopasowanie można wykonywać przy pomocy programów uruchamianych z linii komend. Kolejnym etapem jest ręczne poprawianie dopasowania zwykle połączone z przycinaniem zebranych funkcji. Ten etap najwygodniej jest wykonywać używając programów ,,okienkowych''. Programy z interfejsem graficznym zwykle mają także funkcje dopasowania sekwencji, często zresztą poprzez uruchamianie programów działających w linii komend.</p>
<p>Długą listę takich programów można znaleźć np. na <a href="https://en.wikipedia.org/wiki/List_of_sequence_alignment_software">Wikipedii</a></p>
<a class="header" href="#programy-dopasowujące-wiele-sekwencji-uruchamiane-z-linii-komend" id="programy-dopasowujące-wiele-sekwencji-uruchamiane-z-linii-komend"><h2>Programy dopasowujące wiele sekwencji uruchamiane z linii komend</h2></a>
<p>Programów uruchamianych z linii komend jest wiele, zwykle każdy z nich używa osobnego algorytmu dopasowania lub jego modyfikacje. Należą do nich:</p>
<ul>
<li><a href="http://www.clustal.org/">Clustal W i Clustal Omega</a></li>
<li><a href="http://www.drive5.com/muscle/">MUSCLE</a></li>
<li><a href="https://mafft.cbrc.jp/alignment/software/">MAFFT</a></li>
<li><a href="http://www.tcoffee.org/Projects/tcoffee/">T-Coffee</a></li>
<li><a href="http://wasabiapp.org/software/prank/">PRANK</a></li>
</ul>
<p>Można je zainstalować na Debianie lub innych debianopodobnych dystybucjach komendą (usuń nazwy programów, których nie chcesz instalować):</p>
<pre><code>sudo apt-get install clustalw clustalo muscle mafft t-coffee prank
</code></pre>
<p>W internecie można także łatwo znaleźć strony, które umożliwiają procesu dopasowania online z wykorzystaniem tych (i innych) programów.</p>
<a class="header" href="#programy-z-interfejsem-graficznym-do-edycji-dopasowań" id="programy-z-interfejsem-graficznym-do-edycji-dopasowań"><h2>Programy z interfejsem graficznym do edycji dopasowań</h2></a>
<p>W pracy z zestawami sekwencji praktyczne są programy z interfejsem graficznym, które posiadają szereg użytecznych funkcji ułatwiających ich porządkowanie i edycję.  a także np. uruchamianie programów dopasowujących wstępnie sekwencje czy obliczanie i rysowanie drzew.</p>
<a class="header" href="#praktyka-proste-dopasowanie-sekwencji-atp6" id="praktyka-proste-dopasowanie-sekwencji-atp6"><h2>Praktyka: Proste dopasowanie sekwencji <code>atp6</code></h2></a>
<p>Pobierz z GenBank-u następujące sekwencje i zapisz je w pliku <code>atp6-surowe.fasta</code>:</p>
<pre><code>AY007817 Daucus carota
AY847285 Brassica juncea
AY961627 Oryza sativa
EU882268 Sapria himalayana
FJ595983 Helianthus annuus
GU075810 Zea mays
HQ593780 Ajuga reptans
HQ593782 Mimulus guttatus
KC825300 Fragaria virginiana
KC879635 Magnolia stellata
KU180476 Centaurea scabiosa
KX524674 Lindenbergia siniaca
</code></pre>
<p>Zmień domyślne nazwy ,,GenBankowe'' na nazwy wg. schematu: <code>nr_rodzaj_gatunek</code>, np: <code>AY007817_Daucus_carota</code>. Wykonaj poprawki w edytorze tekstu. Zapisz jako <code>atp6-surowe.fasta</code>.</p>
<p>Zanim przejdziemy do dopasowania sekwencji w linii komend, użyjemy programu <em>AliView</em>, który można pobrać ze strony domowej programu: <a href="http://ormbunkar.se/aliview/">http://ormbunkar.se/aliview/</a>. AliView pozwala na wygodne przeglądanie i edycję zestawu sekwencji a także posiada szereg innych przydatnych funkcji do których z pewnością należy możliwość uruchamiania programów dopasowujących sekwencje. Warto zajrzeć na stronę programu <a href="http://ormbunkar.se/aliview/">http://ormbunkar.se/aliview/</a> gdzie przedstawione są jego możliwości.</p>
<p>Uruchom AliView i otwóż plik z sekwencjami.</p>
<p><img src="dopasowanie/aliview-01.png" alt="AliView - interfejs" /></p>
<p>Aliview dopasowuje sekwencje używając zewnętrznych programów.</p>
<p>Można zmienić uruchamiany program wybierając z menu</p>
<p><img src="dopasowanie/change-align-program-01.png" alt="AliView - zmiana programu dopasowującego sekwencje - menu" /></p>
<p>Pokazuje się okno:</p>
<p><img src="dopasowanie/change-align-program-02.png" alt="AliView - zmiana programu dopasowującego sekwencje" /></p>
<p>Tu można wybrać program z domyślnie udostępnionych przez program, dodać inne i dostosować opcje ich uruchamiania. Instrukcje można znaleźć na stronie programu. Teraz zmień program na <code>Mutt</code> (ten wyżej).</p>
<p>Wybierz z paska narzędziowego <code>Align-&gt;Realign everything</code></p>
<p><img src="dopasowanie/aliview-02.png" alt="AliView - Dopasuj wszystko" /></p>
<p>Program zapyta czy na pewno dopasować sekwencje, zatwierdzamy. Pokazuje się okno z postępem pracy programu i w końcu widać wynik. Przesuń suwakiem na dole ekranu zestawienie sekwencji w prawo. Przyjrzyj się jak wyglądają dopasowane sekwencje.</p>
<p>Jak widać mają one różną długość, w końcu jednak znajduje się strefa dopasowania, która obejmuje odcinki wszystkich sekwencji, od 563 miejsca dopasowania. Przy okazji przyjrzyj się informacjom widocznym w pasku na dole okna. Są one dość jasne:</p>
<p><img src="dopasowanie/aliview-03.png" alt="AliView - dopasowanie" /></p>
<p>Teraz kliknij na czwartą ikonę od lewej. Zaznaczone zostają kolorami kodony odpowiadające różnym aminokwasom.</p>
<p><img src="dopasowanie/aliview-translate.png" alt="AliView - ,,translacja''" /></p>
<p>Pojawiają się także nowe ikony pozwalające na zmianę m. in. sposobu wyświetlania a także ustawienia początkowego nukleotydu dla odczytu kodonów. Domyślnie ,,translacja'' rozpoczyna się od pierwszej pozycji zestawienia. Prawidłową pozycję startu odczytywania kodonu można odczytać np. z GenBanku. Sprawdź dane dla sekwencji <code>KU180476</code>. Sprawdź gdzie zaczyna się prawidłowe miejsce początku pierwszego kompletnego kodonu w części wspólnej dopasowanych sekwencji.</p>
<p><img src="dopasowanie/start-kodonu.png" alt="AliView - ,,translacja''" /></p>
<p>Teraz wróć do domyślnego widoku sekwencji i zaznacz wszystkie kolumny na lewo od miejsca, w którym rozpoczyna się wspólna część sekwencji:</p>
<p><img src="dopasowanie/aliview-04.png" alt="AliView - interfejs" /></p>
<p>Następnie usuń je używając skrótu klawiszowego <code>&lt;Ctrl&gt;+&lt;Del&gt;</code> (warto go zapamiętać) lub odpowiedniej pozycji w pasku menu: <code>Edit-&gt;Delete selected</code>.</p>
<p>Podobnie przytnij prawą część dopasowania.</p>
<p>Teraz znów możesz sprawdzić ,,translację'' sekwencji, przy okazji zauważ, że (co nie jest zaskoczeniem) przy złym ustawieniu miejsca początku kodonu pojawia się wiele miejsc <code>STOP</code> oznaczonych szarym kolorem.</p>
<p><img src="dopasowanie/aliview-05.png" alt="AliView - zły początek kodonu" /></p>
<p>Jeśli ustawimy podgląd za pomocą jednoliterowych oznaczeń aminokwasów, miejsca <code>STOP</code> będą wyświetlone jako litera <code>x</code>.</p>
<p><img src="dopasowanie/aliview-06.png" alt="AliView - oznaczenia jednoliterowe" /></p>
<p>Teraz zastanów się, jak można znaleźć prawidłowe miejsce początku kodonów w działających genach, jeśli go nie znamy.</p>
<p>Wróć teraz do standardowego wyświetlania sekwencji i znajdź miejsce, w którym znajdują się indele w dwu sekwencjach. Zauważ, że pierwszym nukleotydem flankującym indel w sekwencji <em>Oryza sativa</em> jest <code>G</code>, który w zasadzie pasowałby równie dobrze po obu stronach indelu. Nieco inaczej jest w <em>Ajuga reptans</em>, tam nukleotyd <code>C</code> nie pasuje do żadnego nukleotydu w innych sekwencjach:</p>
<p><img src="dopasowanie/aliview-07.png" alt="AliView - indele" /></p>
<p>W ich prawidłowym umieszczeniu może pomóc podświetlenie kodonów:</p>
<p><img src="dopasowanie/aliview-08.png" alt="AliView - podświetlenie kodonów" /></p>
<p>Pamiętając, że indele w działających genach kodujących białka powinny obejmować trójki nukleotydów lub ich wielokrotność (inaczej zmienia się ramka odczytu), widać że <code>G</code> w pierwszej sekwencji zostało umieszczone prawidłowo, natomiast <code>C</code> przy drugim indelu należy przesunąć w lewo. Nukleotydy przesuwamy klikając na nie i przeciągając kursorem myszy, przy więcej niż jednym nukleotydzie należy wcześniej zaznaczyć odcinek, który chcemy przemieścić.</p>
<p>Teraz kodony są kompletne:</p>
<p><img src="dopasowanie/aliview-09.png" alt="AliView - indele dopasowane" /></p>
<p>Zapisz plik jako <code>atp6-dopasowane.fasta</code>.</p>
<p>Przy pracy z AliView warto korzystać z licznych dostępnych opcji ułatwiających pracę. Przejrzyj te dostępne w menu, zazwyczaj łatwo domyślić się jakie mają zastosowanie.</p>
<a class="header" href="#dopasowanie-sekwencji-z-linii-komend" id="dopasowanie-sekwencji-z-linii-komend"><h2>Dopasowanie sekwencji z linii komend</h2></a>
<p>Teraz przyszedł czas na dopasowanie sekwencji z użyciem linii komend. Najpierw użyjemy w tym celu programu <code>muscle</code>. Sprawdź jak go używać używając komendy:</p>
<pre><code>muscle -h 
</code></pre>
<p>lub</p>
<pre><code>man muscle
</code></pre>
<p>W najprostszej formie podajemy plik wejściowy i nazwę pliku wyjściowego:</p>
<pre><code>muscle -in atp6-surowe.fasta -out atp6-wyrownanie-muscle.fasta
</code></pre>
<p>Sprawdź plik wynikowy w <code>Aliview</code>.</p>
<p>Program <code>mafft</code> oferuje dużo więcej opcji niż <code>muscle</code>, uruchom:</p>
<pre><code>man mafft
</code></pre>
<p>Jak widać można w tym programie ustawiać np. wartości kar za otwieranie czy wydłużanie indeli, co może być przydatne przy sekwencjach, które mają ich wiele, zaraz się z takimi spotkamy, na razie uruchom <code>mafft</code> bez dodatkowych opcji:</p>
<pre><code>mafft atp6-surowe.fasta &gt; atp6-wyrownanie-mafft.fasta
</code></pre>
<p>Po otwarciu pliku wynikowego w <code>Aliview</code> widać, <code>mafft</code> domyślnie zmienia wielkość liter w sekwencjach na małe, raczej tego nie chcemy, dlatego użyjemy opcji <code>--preservecase</code></p>
<pre><code>mafft --preservecase atp6-surowe.fasta &gt; atp6-wyrownanie-mafft.fasta
</code></pre>
<p>Teraz pobierz sekwencje o poniższych numerach i zapisz je w pliku <code>trnL-trnF-GB.fasta</code>:</p>
<pre><code>JX073793
KU238878
GU818008
KX524675 
AY743457
AY575533
KU238873
KU238869
KU238874
KU238865
KU238864
KU238875
KU238866
KU238871
KU238876
KU238867
KU238877
KU238868
KU238872
KU238870
GU323356
</code></pre>
<p>Sugeruję zrobić to za pomocą skryptu. W takim wypadku sprawdź czy pierwsza linia pliku <code>FASTA</code> nie jest pusta, jeśli tak to usuń ją.</p>
<p>Zmień nazwy sekwencji wg. schematu dla sekwencji <code>atp6</code>.</p>
<p>Teraz spróbuj dopasować sekwencje za pomocą programu <code>muscle</code>.</p>
<p>Następnie spróbuj <code>mafft</code>, także z opcją <code>--auto</code> oraz <code>--op</code> (sprawdź co oznaczają).</p>
<p>Porównaj wyniki i spróbuj poprawić wybrane dopasowanie ręcznie.</p>
<p><a href="cwiczenia/../README.html">← Spis treści</a></p>
<a class="header" href="#dopasowanie-modelu-ewolucji-molekularnej" id="dopasowanie-modelu-ewolucji-molekularnej"><h1>Dopasowanie modelu ewolucji molekularnej</h1></a>
<p>Mając dopasowane zestawy sekwencji powoli dochodzimy do etapu konstruowania drzew filogenetycznych. Najpierw jednak należy do naszego zestawu sekwencji dopasować odpowiedni model ewolucji molekularnej (substytucji).</p>
<a class="header" href="#dopasowanie-modelu-ewolucji-molekularnej-jmodeltest-2---gui" id="dopasowanie-modelu-ewolucji-molekularnej-jmodeltest-2---gui"><h2>Dopasowanie modelu ewolucji molekularnej: jModelTest 2 - GUI</h2></a>
<p>Niektóre programy konstruujące drzewa filogenetyczne, jak na przykład omawiany dalej <code>iqtree</code> potrafią same oszacować, który model jest odpowiedni dla danego zestawu sekwencji.  W innych przypadkach powinniśmy wcześniej go znaleźć. Jednym z programów, które dobrze się do tego nadają jest <code>jModelTest 2</code>. Można go uruchomić z linii komend ale posiada też interfejs graficzny.</p>
<p>Program można pobrać ze strony <a href="https://github.com/ddarriba/jmodeltest2/releases">https://github.com/ddarriba/jmodeltest2/releases</a>.</p>
<p>Pobrany plik należy rozpakować. W powstałym katalogu znajdziemy m. in. pliki uruchamiające program. Warto też pobrać obszerny manual. Czynności te można oczywiście wykonać z linii komend:</p>
<pre><code>cd ~
wget https://github.com/ddarriba/jmodeltest2/files/157117/jmodeltest-2.1.10.tar.gz
# rozpakowanie pliku
tar -xvzf jmodeltest-2.1.10.tar.gz
# zmiana nazwy katalogu na bardziej przyjazny i uniwersalny
mv jmodeltest-2.1.10 jmodeltest
# pobranie manuala do katalogu programu
cd jmodeltest
wget https://github.com/ddarriba/jmodeltest2/files/157130/manual.pdf
</code></pre>
<p>Powyższe linki kierują do najnowszej wersji programu w chwili pisania tego skryptu. Warto najpierw sprawdzić czy w międzyczasie nie ukazała się kolejna wersja i w takim wypadku zaktualizować adresy do plików.</p>
<p>Teraz wejdźmy do katalogu programu:</p>
<pre><code>$: cd jmodeltest
$: ls
CHANGELOG     INSTALL         resources
conf          jModelTest.jar  runjmodeltest-cluster.sh
COPYING       lib             runjmodeltest-gui.bat
example-data  log             runjmodeltest-gui.sh
exe           manual.pdf      THIRDPARTYLICENSES
extra         README          trees
</code></pre>
<p>Uruchamiany plik programu to <code>jModelTest.jar</code>. Jest to program napisany w języku Java i uruchamiamy go wydając komendę:</p>
<pre><code>java -jar jModelTest.jar
</code></pre>
<p>Nie jest to zbyt wygodne, dlatego użyjemy dostarczonego skryptu <code>runjmodeltest-gui.sh</code> (sprawdź jego zawartość).</p>
<pre><code>./runjmodeltest-gui.sh
</code></pre>
<p>Możesz oczywiście zmienić jego nazwę na jeszcze wygodniejszą, np <code>run.sh</code>.</p>
<p>Po uruchomieniu programu pojawia się okno:</p>
<p><img src="dopasowanie_modelu/jmodeltest2-01.png" alt="jModelTest - okno główne" /></p>
<p>Teraz trzeba wybrać zestaw dopasowanych (!) sekwencji. Wybieramy z menu <code>Load DNA alignment</code> (lub używamy skrótu <code>&lt;Ctrl&gt;+O</code>).</p>
<p><img src="dopasowanie_modelu/jmodeltest2-02.png" alt="jModelTest - wybieranie zestawu dopasowanych sekwencji" /></p>
<p>Przejdź do katalogu, w którym zostały zapisane dopasowane sekwencje z poprzedniej lekcji.
Niestety, okienko służące do wybierania plików domyślnie wyświetla tylko pliki o nazwach  <code>*.phy, *.fas, *.nex</code>, jeśli więc nasze zestawienie zostało zapisane z przedłużeniem <code>fasta</code> to nie będzie widoczne.</p>
<p><img src="dopasowanie_modelu/jmodeltest2-03.png" alt="jModelTest - wybieranie pliku" /></p>
<p>Nie jest to duży problem, wystarczy zmienić opcję na <code>All files</code>:</p>
<p><img src="dopasowanie_modelu/jmodeltest2-04.png" alt="jModelTest - widoczne pliki *.fasta" /></p>
<p>Wybierz plik w którym znajdują się dopasowane i przycięte sekwencje <code>atp6</code> tu: <code>atp6-dopasowane.fasta</code>.</p>
<p>Po otwarciu pliku a dole okna głównego pojawia się informacja dotycząca liczby sekwencji i miejsc:</p>
<p><img src="dopasowanie_modelu/jmodeltest2-05.png" alt="jModelTest - Załadowany zestaw sekwencji" /></p>
<p>Przy okazji zwróć uwagę na komunikat na dole ekranu w czerwonym kolorze. Zanim znajdziemy model ewolucji musimy obliczyć ,,Likelihood scores'' co można przetłumaczyć jako ,,Wyniki wiarygodności''.</p>
<p><img src="dopasowanie_modelu/jmodeltest2-06.png" alt="jModelTest - Obliczanie wyników wiarygodności" /></p>
<p>Pokazuje się okno w którym można ustawić parametry:</p>
<p><img src="dopasowanie_modelu/jmodeltest2-07.png" alt="jModelTest - Ustawianie parametrów wiarygodności" /></p>
<p>Oczywiście wartość ,,Number of processors requested'' odpowiadająca liczbie rdzeni procesora(ów), które mogą być użyte w obliczeniach zależy od parametrów komputera na którym uruchamiamy obliczenia. Nie będę omawiał wszystkich sekcji, zwrócę jedynie uwagę na ,,Number of substitution schemes'' gdzie wybieramy liczbę testowanych schematów substytucji. Nie jest to liczba testowanych modeli, ponieważ dany schemat podstawień może uwzględniać lub nie zmienną frekwencję nukleotydów. Na przykład modele JC i F81, mają taki sam schemat substytucji, zakładają takie same prawdopodobieństwo zmiany każdej zasady w inną ale w F81 poszczególne zasady mogą mieć różne frekwencje, czego nie uwzględnia JC. Tak więc wybierając wartość 11 tak naprawdę testowanych jest 14 modeli (o ile zaznaczona jest opcja ,,Base frequences''). Dodatkowo domyślnie badane są parametry G i I (sekcja ,,Rate variation'') oraz ich kombinacja, co daje w tym przypadku 88 możliwości.</p>
<p>Mogło by się wydawać, że im większą wartość zaznaczymy, tym lepiej. Jednak niekoniecznie jest to prawda. Jednym z powodów ograniczenia testowanej liczby modeli jest czas obliczeń. Czasem jednak po prostu program, który będziemy później używać do wyliczania drzew, przyjmuje ograniczony zestaw modeli (np. <code>mrBayes</code>).</p>
<p>Dokładniejszy opis poszczególnych opcji można znaleźć w manualu jModelTest, przy opisie parametrów podawanych przy uruchamianiu programu z linii komend.</p>
<p>Po ustaleniu opcji, klikamy ,,Compute Likelih...''</p>
<p>Pokazuje się okno pokazujące postęp obliczeń:</p>
<p><img src="dopasowanie_modelu/jmodeltest2-08.png" alt="jModelTest - postęp obliczeń" /></p>
<p>Po zakończeniu obliczeń w oknie głównym pokazują się wyniki dla poszczególnych modeli i ich parametrów.
Nie będziemy ich tu omawiać, ale przejrzyj je i spróbuj z nich jak najwięcej odczytać.</p>
<p>Wyniki dla poszczególnych modeli można wygenerować w wersji tabelarycznej wybierając w menu:</p>
<p><code>Results-&gt;Show results table</code></p>
<p><img src="dopasowanie_modelu/jmodeltest2-09.png" alt="jModelTest - tabela z wynikami" /></p>
<p>Sprawdź teraz pozycję ,,Analysis'' w menu. Kilka opcji wcześniej nieaktywnych teraz jest odblokowanych.
Teraz będą nas interesowały dwie: <code>Do AIC calculations...</code> oraz <code>Do BIC calculations...</code>.</p>
<p><code>AIC</code> (<em>Akaike Information Criterion</em>) oraz <code>BIC</code> (<em>Bayesian Information Criterion</em>) to kryteria wyboru modelu z dostępnych oparte na zasadzie znalezienia tak złożonego modelu jak to potrzebne, ale nie bardziej. Czyli ,,karane'' są modele zbyt złożone, przy czym <code>BIC</code> jest pod tym względem bardziej restrykcyjny. Jak zwykle, na pytanie ,,który jest lepszy'' nie podam jednoznacznej odpowiedzi. Rozważania na ten temat można znaleźć na przykład <a href="https://stats.stackexchange.com/questions/577/is-there-any-reason-to-prefer-the-aic-or-bic-over-the-other">tu</a>.</p>
<p>Najpierw wybierz <code>Analysis-&gt;Do AIC calculations...</code>.</p>
<p><img src="dopasowanie_modelu/jmodeltest2-11.png" alt="jModelTest - parametry obliczenia AIC" /></p>
<p>Pozostawiamy ustawienia domyślne i klikamy `Do AIC calculations``.
Wynik pojawia się w oknie głównym programu.
Na górze widać wybrany model i dopasowane do niego parametry:</p>
<pre><code> Model selected: 
   Model = GTR+G
   partition = 012345
   -lnL = 2120.8289
   K = 31
   freqA = 0.2348 
   freqC = 0.2056 
   freqG = 0.1950 
   freqT = 0.3646 
   R(a) [AC] =  2.2923
   R(b) [AG] =  1.9116
   R(c) [AT] =  0.3302
   R(d) [CG] =  1.2019
   R(e) [CT] =  4.6955
   R(f) [GT] =  1.0000
   gamma shape = 0.3990 
</code></pre>
<p>Jak widać, jest to model <code>GTR+G</code></p>
<p>Poniżej znajduje się coś co wygląda znajomo:</p>
<pre><code>Tree for the best AIC model = 
(AY961627_Oryza_sativa:0.02366168,GU075810_Zea_mays:0.01789166,(AY847285_Brassica_juncea:0.02137636,(HQ593780_Ajuga_reptans:0.22926226,((FJ595983_Helianthus_annuus:0.00917802,KU180476_Centaurea_scabiosa:0.00000013):0.00768867,(EU882268_Sapria_himalayana:0.04572619,((HQ593782_Mimulus_guttatus:0.00495932,KX524674_Lindenbergia_siniaca:0.00186868):0.01282359,(AY007817_Daucus_carota:0.02199468,(KC825300_Fragaria_virginiana:0.03215909,KC879635_Magnolia_stellata:0.01610002):0.00190086):0.01009171):0.00901775):0.03013788):0.00218864):0.00652333):0.06453377);
</code></pre>
<p>Tak to drzewo zapisane w formacie <code>Newick</code>. Można szybko podejrzeć jego topologię np. na stronie <a href="http://www.trex.uqam.ca/index.php?action=newick">Trex-online</a>.</p>
<p>Dalej znajduje się tabela z wynikami dla poszczególnych modeli:</p>
<pre><code>* AIC MODEL SELECTION : Selection uncertainty
 
Model             -lnL    K      AIC       delta       weight   cumWeight
------------------------------------------------------------------------- 
GTR+G       2120.82891   31  4303.657820   0.000000    0.427531   0.427531 
GTR+I+G     2120.16864   32  4304.337280   0.679460    0.304386   0.731916 
TIM1+G      2124.06649   29  4306.132980   2.475160    0.124020   0.855937 
TIM1+I+G    2123.49268   30  4306.985360   3.327540    0.080984   0.936921 
GTR+I       2123.25396   31  4308.507920   4.850100    0.037825   0.974746 
...
</code></pre>
<p>Zwróć uwagę na kolumnę <code>AIC</code>. Wybrany model to ten, który ma najniższą wartość.</p>
<p>Przejdźmy teraz na koniec wygenerowanych informacji.</p>
<pre><code>* AIC MODEL SELECTION : Best Model's command line
 
phyml  -i /tmp/jmodeltest1199799651667664719.phy -d nt -n 1 -b 0 --run_id GTR+G -m 012345 -f m -c 4 -a e --no_memory_check -o tlr -s NNI
</code></pre>
<p>Tak, to jest podana komenda uruchomienia programu <code>phyml</code>, który generuje drzewa filogenetyczne, wraz z potrzebnymi parametrami.
Sprawdź zawartość podanego przy parametrze <code>-i</code> pliku. Zapewne u Ciebie będzie miał inną nazwę niż w podanym przykładzie. Zachowaj jego kopię w dogodnym miejscu na później. Teraz możesz wypróbować zaproponowaną komendę i podejrzeć wynik na podanej powyżej stronie internetowej wizualizującej drzewa.</p>
<p>Sprawdźmy teraz jaki wynik da nam kryterium <code>BIC</code>. Okienko z opcjami również pozostawiamy bez zmian:</p>
<p><img src="dopasowanie_modelu/jmodeltest2-12.png" alt="jModelTest - parametry BIC" /></p>
<p>Format wyników jest podobny jak poprzednio, choć wynik inny. W tym przypadku najmniejszą wartość <code>BIC</code> otrzymał model TIM1+G.</p>
<p>Wejdź teraz w menu do opcji <code>Results-&gt;Show results table</code>. Zauważ, że teraz aktywne stały się zakładki z wynikami <code>AIC</code> i <code>BIC</code>.
Kliknij w zakładkę <code>AIC</code>. Jak można było przypuszczać, znajdują się tam wyniki w formie tabelarycznej. Model o najlepszym wyniku, czyli najniższej wartości <code>AIC</code> jest zaznaczony na czerwono. Klikając w nagłówek kolumny <code>AIC</code> tabela zostanie posortowana wg. tej wartości, więc ,,zwycięzca'' znajdzie się na szczycie.</p>
<p><img src="dopasowanie_modelu/jmodeltest2-13.png" alt="jModelTest - tabela z wynikami" /></p>
<p>Teraz w menu wybierz <code>Results-&gt;Build HTML log</code>.
Wygenerowany plik zapisz w miejscu domyślnym, czyli w katalogu programu <code>jModelTest 2</code>.
Otwórz go w przeglądarce internetowej i sprawdź co potrafisz z niego odczytać.
Można również skorzystać z linków pozwalających podejrzeć wizualizację drzew. Przy czym w zależności od systemu operacyjnego, przeglądarki i ustawień może się ta sztuka nie udać ze względu na zablokowanie apletu Javy.</p>
<a class="header" href="#dopasowanie-modelu-ewolucji-molekularnej-jmodeltest-2---linia-poleceń" id="dopasowanie-modelu-ewolucji-molekularnej-jmodeltest-2---linia-poleceń"><h2>Dopasowanie modelu ewolucji molekularnej: jModelTest 2 - linia poleceń</h2></a>
<p>Na razie używaliśmy programu <code>jModelTest 2</code> przez interfejs graficzny. Teraz sprawdźmy jak można uzuskać wyniki przez linię poleceń.</p>
<p>Uruchom polecenie (dopasuj ścieżki jeśli to konieczne):</p>
<pre><code>java -jar ~/jmodeltest/jModelTest.jar -d atp6-dopasowane.fasta -g 4 -i -f -AIC -BIC -o atp6-jmodeltest-results.txt
</code></pre>
<p>Użyte opcje oznaczają:</p>
<ul>
<li><code>-d atp6-dopasowane.fasta</code> - plik wejściowy</li>
<li><code>-g 4</code> - sprawdź cztery kategorie gamma. <sup id="a1"><a href="#f1">1</a></sup></li>
<li><code>-i</code> - sprawdź modele z parametrem <code>I</code> (<em>Invariable sites</em>)</li>
<li><code>-f</code> - sprawdź modele z nierównym udziałem różnych zasad</li>
<li><code>-AIC</code> - oblicz kryterium <code>AIC</code></li>
<li><code>-BIC</code> - oblicz kryterium <code>BIC</code></li>
<li><code>-o atp6-jmodeltest-results.txt</code> - plik w którym zostaną zapisane wyniki.</li>
</ul>
<p>Domyślnie program sprawdza trzy pary (-f) modeli, co w raz z parametrami <code>G</code> oraz <code>I</code> daje w sumie 24 testowane modele. Można zwiększyć ich liczbę używając parametru <code>-s</code> i jednej z liczb z zestawu (3, 5, 7, 11, 203). Więcej szczegółów można znaleźć w manualu programu.</p>
<p>Zgodnie z powyższymi ustawieniami wyniki obliczeń zapisane zostały w pliku <code>atp6-jmodeltest-results.txt</code>. Jeśli chcesz przejść od razu do podsumowania użyj polecenia <code>tail</code>. Z kolei polecenie <code>grep 'phyml'</code> pozwoli znaleźć ustawienia dla programu <code>phyml</code>.</p>
<p>Programu można użyć także do konwersji pliku z dopasowanymi sekwencjami do formatu <code>PHYLIP</code>, wymaganego przez niektóre programy wyliczające drzewa filogenetyczne (np. <code>phyml</code>). Służy do tego opcja <code>-getPhylip</code>:</p>
<pre><code>java -jar ~/jmodeltest/jModelTest.jar -d atp6-dopasowane.fasta -getPhylip
</code></pre>
<p>Nazwa pliku wynikowego będzie miała przedłużenie <code>.phy</code></p>
<p>Program posiada jeszcze wiele innych parametrów, warto zajrzeć do manuala.</p>
<a class="header" href="#dopasowanie-modelu-ewolucji-molekularnej-za-pomocą-programu-iqtree" id="dopasowanie-modelu-ewolucji-molekularnej-za-pomocą-programu-iqtree"><h2>Dopasowanie modelu ewolucji molekularnej za pomocą programu <code>iqtree</code></h2></a>
<p>Program <a href="http://www.iqtree.org"><code>iqtree</code></a>, będziemy niebawem używać do konstruowania drzew filogenetycznych metodą <em>Maximum Likelihood</em>. Można jednak zastosować go do znalezienia optymanego modelu ewolucji molekularnej. Prosty przykład wygląda tak:</p>
<pre><code>iqtree -m TESTONLY -nt AUTO -s atp6-dopasowane.fasta
</code></pre>
<p>Program wygeneruje kilka plików z wynikami, wśród których znajdziesz także drzewo filogenetyczne.</p>
<p>Znaczenie użytych opcji:</p>
<ul>
<li><code>-m TESTONLY</code> - znajdź model i wyjdź</li>
<li><code>-nt AUTO</code> - automatycznie dopasuj liczbę użytych wątków podczas obliczeń</li>
</ul>
<p>Inną pożyteczną opcją jest <code>-mset</code>, która pozwala m. in. dopasować listę badanych modeli do tych, które są obsługiwane przez niektóre programy.</p>
<p>Na przykład poniższe polecenie wyszuka model dla programu <code>mrBayes</code>:</p>
<pre><code>iqtree -m TESTONLY -nt AUTO -mset mrbayes -s atp6-dopasowane.fasta
</code></pre>
<p>Jeśli używamy <code>iqtree</code> do wygenerowania drzewa filogenetycznego, znaleziony model zostanie automatycznie użyty w dalszych etapach obliczeń, o czym więcej w następnej części.</p>
<hr />
<p><sup><b id="f1">1</b></sup> Ciekawą dyskusję na temat liczby kategorii gamma przy konstruowaniu drzew filogenetycznych można przeczytać <a href="https://www.researchgate.net/post/How_do_you_establish_the_number_of_discrete_gamma_categories_in_ML_tree_construction">tu</a>.
<a href="#a1">↩</a></p>
<a class="header" href="#konstruowanie-drzew-filogenetycznych" id="konstruowanie-drzew-filogenetycznych"><h1>Konstruowanie drzew filogenetycznych</h1></a>
<a class="header" href="#generowanie-drzew-metodą-maximum-likelihood-za-pomocą-programu-phyml" id="generowanie-drzew-metodą-maximum-likelihood-za-pomocą-programu-phyml"><h2>Generowanie drzew metodą <em>Maximum Likelihood</em> za pomocą programu <code>phyml</code></h2></a>
<p>Jednym z popularnych programów liczących drzewa filogenetyczne z użyciem algorytmu <em>Maximum Likelihood</em> jest <code>phyml</code>.
Utwórz katalog <code>phyml</code>, następnie wejdź do niego i skopiuj tam plik <code>atp6-dopasowane.fasta</code>.</p>
<p>W poprzedniej części pokazałem jak dopasować model ewolucji molekularnej dla zestawu sekwencji przy użyciu programu <code>JModelTest 2</code>:</p>
<pre><code>java -jar ~/jmodeltest/jModelTest.jar -d atp6-dopasowane.fasta -g 4 -i -f -AIC -BIC -s 11 -o atp6-jmodeltest-results.txt
</code></pre>
<p>Wspomniałem też, że w pliku wynikowym można łatwo znaleźć parametry dla programu <code>phyml</code>:</p>
<pre><code>$: grep phyml atp6-jmodeltest-results.txt 

 Phyml path = /home/grzeg/jmodeltest/exe/phyml/
phyml  -i /tmp/jmodeltest9047391708413796278.phy -d nt -n 1 -b 0 --run_id GTR+G -m 012345 -f m -c 4 -a e --no_memory_check -o tlr -s BEST
phyml  -i /tmp/jmodeltest9047391708413796278.phy -d nt -n 1 -b 0 --run_id TIM1+G -m 012230 -f m -c 4 -a e --no_memory_check -o tlr -s BEST
</code></pre>
<p>Jeden z nich jest zestawem dla kryterium <code>AIC</code>, drugi dla <code>BIC</code>. Użycie polecenia <code>grep</code> z parametrem <code>-B</code> (jak <em>Before</em>), które pokazuje także linie poprzedzające linię z dopasowaniem szukanego ciągu znaków pozwala zidentyfikować, który jest który (nawiasem mówiąc jest też parametr <code>-A</code> od <em>After</em>):</p>
<pre><code>$: grep phyml -B 2 atp6-jmodeltest-results.txt

 Phyml version = 20130103
 Phyml binary = PhyML_3.0_linux64
 Phyml path = /home/grzeg/jmodeltest/exe/phyml/
--
* AIC MODEL SELECTION : Best Model's command line
 
phyml  -i /tmp/jmodeltest9047391708413796278.phy -d nt -n 1 -b 0 --run_id GTR+G -m 012345 -f m -c 4 -a e --no_memory_check -o tlr -s BEST
--
* BIC MODEL SELECTION : Best Model's command line
 
phyml  -i /tmp/jmodeltest9047391708413796278.phy -d nt -n 1 -b 0 --run_id TIM1+G -m 012230 -f m -c 4 -a e --no_memory_check -o tlr -s BEST

</code></pre>
<p>Skupmy się na wyniku dla <code>AIC</code>. Używając zainstalowanego manuala (<code>man phyml</code>) sprawdź co oznaczają poszczególne opcje.</p>
<p>Kilka z nich zmodyfikujemy. Zaczniemy od pliku z sekwencjami. Powyższy wynik wskazuje na plik <code>phy</code> w katalogu tymczasowym, możesz sprawdzić czy istnieje. Jeśli tak to można go wykorzystać do dalszej pracy, ale zrobimy inaczej.</p>
<p>Najpierw stworzymy (zgodnie z instrukcją z poprzedniej części) plik w formacie <code>PHYLIP</code>:</p>
<pre><code>java -jar ~/jmodeltest/jModelTest.jar -d atp6-dopasowane.fasta -getPhylip
</code></pre>
<p>W katalogu pojawił się plik <code>atp6-dopasowane.fasta.phy</code>. To jego użyjemy jako pliku wejściowego. Zmodyfikuj zatem komendę i wykonaj ją:</p>
<pre><code>phyml  -i atp6-dopasowane.fasta.phy -d nt -n 1 -b 0 --run_id GTR+G -m 012345 -f m -c 4 -a e --no_memory_check -o tlr -s BEST
</code></pre>
<p>W katalogu pojawiły się dwa nowe pliki:</p>
<pre><code>atp6-dopasowane.fasta.phy_phyml_stats.txt_GTR+G
atp6-dopasowane.fasta.phy_phyml_tree.txt_GTR+G
</code></pre>
<p>Sprawdź ich zawartość. Jak widać, drugi z nich (jak zresztą wskazuje nazwa) zawiera drzewo zapisane w formacie <code>Newick</code>.</p>
<p>Teraz sprawdźmy jak to drzewo może wyglądać. Użyjemy do tego celu programu <code>FigTree</code>. Po jego uruchomieniu, otwórz plik z drzewem.</p>
<p><img src="konstruowanie_drzew/figtree-01.png" alt="Okno główne Figtree" /></p>
<p>Drzewo nie wygląda zbyt pięknie, ale kwestiami wizualnymi zajmiemy się kiedy indziej. Drzewo, które się wyświetliło wyraźnie nie jest ukorzenione.
Można to zmienić, zaznaczając (klikając) gałąź z grupą zewnętrzną (outgrupą) i klikając odpowiednią ikonę (,,Reroot''). Grupą zewnętrzna w naszym zestawie jest <em>Magnolia stellata</em>.
Jednak spróbujemy to zrobić inaczej, tak aby <code>phyml</code> od razu wygenerował ukorzenione drzewo. Otwórz plik <code>*.phy</code> w ulubionym edytorze tekstu i dodaj gwiazdkę na końcu nazwy sekwencji z outgrupą, usuń przy tym nadmiarową spację tak aby sekwencje były wyrównane:</p>
<pre><code>...
KU180476_Centaurea_scabiosa    TCCTACTTCT GATTCATTTT GTTACTAAAA AAGGAGGAGG AAACTTAGTA 
AY007817_Daucus_carota         TCCTACTTTT GGTTCATTTT GTTACTAAAA ACGGAGGAGG AAACTCAGTA 
KC879635_Magnolia_stellata*    TCCTACTTCT GGTTCATTTT GTTACTAAAA ACGGAGGGGG AAACTCAGTA 
HQ593782_Mimulus_guttatus      TCCTACTTTT TGTTCATTTT GTTACTAAAA AGGGAGGAGG AAACTCAGTA 
KX524674_Lindenbergia_siniaca  TCCTACTTTT TGTTCATTTT GTTACTAAAA AGGGAGGAGG AAACTCAGTA 
...
</code></pre>
<p>Ponownie wygeneruj drzewo i otwórz w <code>FigTree</code>. Przy okazji w rozwijanym menu po lewej możesz zwiększyć czcionkę dla tekstu opisującego liście:</p>
<p><img src="konstruowanie_drzew/figtree-02.png" alt="Ukorzenione drzewo" /></p>
<p>Zauważ, że teraz drzewo jest ukorzenione.</p>
<p>Naszemu drzewu brakuje jednak jeszcze jednego elementu - bootstrapu. Zmieniamy więc opcje w poleceniu, ustawiając wartość parametru <code>-b</code> na 1000:</p>
<pre><code>phyml  -i atp6-dopasowane.fasta.phy -d nt -n 1 -b 1000 --run_id GTR+G -m 012345 -f m -c 4 -a e --no_memory_check -o tlr -s BEST
</code></pre>
<p>To chwilę potrwa. Jeśli masz powolny komputer, dla celów testowych możesz ustawić mniejszą wartość, np. 100.</p>
<p>Ponownie otwórz plik wynikowy w programie <code>FigTree</code>. Tym razem pojawi się okienko, w którym możemy wpisać nazwę wartości:</p>
<p><img src="konstruowanie_drzew/figtree-03.png" alt="FigTree- pytanie o nazwę wartości" /></p>
<p>Wpisz <code>bootstrap</code>.</p>
<p>Jeśli drzewo nie jest prawidłowo ukorzenione, czyli <em>Magnolia stellata</em> nie stanowi wyraźnej grupy zewnętrznej, to je ukorzeń. Ustaw odpowiednią wielkość czcionki, a następnie zaznacz i otwórz zakładkę ,,Branch Label'' i ustaw parametry wyświetlania bootstrapu.</p>
<p><img src="konstruowanie_drzew/figtree-04.png" alt="FigTree - drzewo z wartościami bootstrapu" /></p>
<p>Wartości bootstrap generowane przez <code>phyml</code> przedstawiają liczbę wygenerowanych drzew na których występuje dana gałąź. Przy czym, jak widać, choć podaliśmy <code>1000</code> jako liczbę powtórzeń, w sumie było ich 1002, ponieważ program dostosowuje tą wartość do liczby używanych procesorów/rdzeni/wątków. W tym przypadku było ich 3, więc liczba powtórzeń musiała być podzielna przez 3.</p>
<p>Zwykle wartości bootstrapu nie przestawia się jako wartości bezwzględnych ale raczej jako wartość procentową (bez znaku <code>%</code>). Toteż należałoby je poprawić w pliku z zapisanym drzewem, albo później poprawiając plik graficzny.</p>
<a class="header" href="#generowanie-drzew-metodą-maximum-likelihood-za-pomocą-programu-iq-tree" id="generowanie-drzew-metodą-maximum-likelihood-za-pomocą-programu-iq-tree"><h2>Generowanie drzew metodą <em>Maximum Likelihood</em> za pomocą programu <code>IQ-TREE</code></h2></a>
<p>Innym programem wykorzystującym metodę ,,Maximum Likelihood'' do generowania drzew filogenetycznych jest <code>IQ-TREE</code>, z którym zetknęliśmy się w poprzednim rozdziale. Na stronie domowej programu, pod adresem <a href="http://www.iqtree.org/">http://www.iqtree.org</a>, można znaleźć m. in. pliki instalacyjne dla różnych systemów operacyjnych a także dokumentację.
Pod Debianem i pokrewnymi dystrybucjami Linuksa można zainstalować go poleceniem:</p>
<pre><code>sudo apt-get install iqtree
</code></pre>
<p>Jedną z zalet <code>IQ-TREE</code> jest to, że automatycznie dobiera dobiera model ewolucji molekularnej, który jest następnie używany przy generowaniu drzew filogenetycznych. Ponadto można zastosować ultraszybki bootstrap (<em>ultrafast bootstrap</em>), który jak nazwa wskazuje, znacznie przyspiesza etap oceny wiarygodności wyników.</p>
<p>Pobierz zestaw sekwencji:
<a href="http://ggoralski.pl/files/filogenetyka-data/ccmFn.fasta">http://ggoralski.pl/files/filogenetyka-data/ccmFn.fasta</a></p>
<p>Teraz utwórz katalog, np. o nazwie <code>iqtree</code>, umieść tam plik z sekwencjami. W katalogu wykonaj komendę:</p>
<pre><code>iqtree -s ccmFn.fasta -m TEST -nt AUTO -bb 1000 -o Cycas_taitungensis_NC_010303
</code></pre>
<p>Znaczenie parametrów jest takie:</p>
<ul>
<li><code>-s ccmFn.fasta</code> - plik wejściowy</li>
<li><code>-m TEST</code> - należy znaleźć model substytucji</li>
<li><code>-nt AUTO</code> - automatyczne dopasowanie liczby rdzeni procesora do obliczeń</li>
<li><code>-bb 1000</code> - ultraszybki bootstrap, 1000 powtórzeń</li>
<li><code>-o Cycas_taitungensis_NC_010303</code> - outgrupa: podajemy nazwę sekwencji z pliku <code>FASTA</code></li>
</ul>
<p>Obserwuj komunikaty, które pokazują się w trakcie obliczeń. Jak widać w początkowej fazie program wyszukuje model ewolucji molekularnej wg. trzech kryteriów, a następnie do dalszych analiz wybrany ten, który został dopasowany wg. kryterium <code>BIC</code> (co można oczywiście zmienić). W końcu zostaje wygenerowanych kilka plików z wynikami, najbardziej nas będzie interesował <code>ccmFn.fasta.treefile</code>, w którym zapisane jest drzewo. Z kolei w pliku <code>ccmFn.fasta.log</code> zapisane zostają komunikaty wyświetlane przez program.</p>
<p>Po otwarciu pliku z drzewem w programie <code>FigTree</code>, ręcznemu wskazaniu outgrupy (<em>Cycas</em>) i dopasowaniu wyglądu powinien pokazać się mniej więcej taki widok:</p>
<p><img src="konstruowanie_drzew/iqtree-01.png" alt="Drzewo dla sekwencji ccmFn" /></p>
<p>Program <code>IQ-TREE</code> posiada wiele dodatkowych opcji i możliwości dopasowania parametrów obliczeń dla drzewa. Warto zajrzeć do dokumentacji i tutoriala dostępnego na <a href="http://www.iqtree.org">stronie domowej programu</a>.</p>
<a class="header" href="#szybkie-drzewo---fasttree" id="szybkie-drzewo---fasttree"><h2>Szybkie drzewo - <code>FastTree</code></h2></a>
<p>Kolejnym programem służącym do generowania drzew metodą <em>Maximum Likelihood</em> jest <code>FastTree</code>. Nie jest to program posiadający zbyt wiele opcji, ma natomiast niewątpliwą zaletę - jak sama nazwa wskazuje generuje drzewa szybko. Warto go wykorzystać szczególnie gdy generujemy wiele drzew, które mają raczej wstępny charakter.</p>
<p>Przykładowe uruchomienie programu może wyglądać tak:</p>
<pre><code>fasttree -nt -gtr atp6.fasta &gt; atp6.tree
</code></pre>
<p>Opcja <code>-nt</code> oznacza, że mamy do czynienia z plikiem zawierającym nukleotydy, <code>-gtr</code> że używamy modelu <code>GTR</code>.</p>
<p>Do oceny wiarygodności program używa test Shimodaira-Hasegawa, którego nie omawialiśmy.</p>
<a class="header" href="#generowanie-drzew-metodą-bayesowską---mrbayes" id="generowanie-drzew-metodą-bayesowską---mrbayes"><h2>Generowanie drzew metodą bayesowską - <code>MrBayes</code></h2></a>
<p><code>MrBayes</code> jest jednym z programów pozwalających na wygenerowanie drzew filogenetycznych metodą bayesowską. O ile metoda <em>Maximum Likelihood</em> wyszukuje drzewa, dla którego dane są najbardziej prawdopodobne, to metoda bayesowska wyszukuje najbardziej prawdopodobne drzewo dla bieżącego zestawu sekwencji. Sposób szukania takiego drzewa przypomina nieco proces ewolucji. Wygenerowane losowo drzewa w każdym ,,pokoleniu'' zmieniają się (,,mutują''), co oznacza zmianę ich parametrów. Zmiany które zwiększają ich prawdopodobieństwo są akceptowane, te które je zmniejszają zostają na ogół odrzucane, choć czasem (w sposób losowy) są również akceptowane, co pomaga uniknąć wpadnięcia drzewa w ,,lokalne optimum''. Domyślnie prowadzone są obliczenia dla dwóch drzew, które są porównywane ze sobą. Obliczenia kończą się, automatycznie lub decyzją użytkownika (parametr <code>stoprule</code>) kiedy różnice między nimi spadną poniżej określonego poziomu (parametr <code>stopval</code>) albo zostanie przekroczona ustawione liczna pokoleń (parametr <code>ngen</code>).</p>
<p><code>MrBayes</code> umożliwia pracę w dwu trybach - obu tekstowych. W pierwszym uruchamiamy program (polecenie <code>mb</code>) a następnie wprowadzamy kolejno komendy i ustawiamy parametry obliczeń. W drugim trybie przygotowujemy wszystko w odpowiednio sformatowanych plikach, które program odczytuje i uruchamia proces generowania drzewa. Przyjrzymy się drugiej metodzie.</p>
<p>Jak zwykle, warto zajrzeć na stronę domową programu: <a href="http://mrbayes.sourceforge.net">http://mrbayes.sourceforge.net</a> gdzie znajdziemy m. in. manual.</p>
<p>Instalacja pod Debianem (i dystrybucjach pokrewnych) przebiega standardowo:</p>
<pre><code>sudo apt-get install mrbayes
</code></pre>
<p>Utwórz katalog, np. o nazwie <code>mrbayes</code>. Skopiuj do niego plik z sekwencjami <code>ccmFn.fasta</code></p>
<p>Najpierw znajdziemy model substytucji spośród obsługiwanych przez program <code>mrbayes</code>, użyjemy w tym celu <code>IQ-TREE</code> (zob. poprzedni rozdział).</p>
<pre><code>iqtree -m TESTONLY -nt AUTO -mset mrbayes -s ccmFn.fasta
</code></pre>
<p>W wynikach znajdujemy dopasowany model: <code>GTR+F+G4</code> czyli <code>GTR</code> + <code>gamma</code>.</p>
<p>Teraz należy przekonwertować plik z formatu <code>FASTA</code> do formatu <code>Nexus</code>. Można do tego wykorzystać program <code>AliView</code>. Otwórz w nim plik <code>ccmFn.fasta</code>, następnie wybierz z menu <code>File-&gt;Save as Nexus</code>. Należy pamiętać, że <code>mrBayes</code> jest wrażliwy na ,,niewłaściwe'' znaki znajdujące się w opisach sekwencji co może prowadzić do błędów po uruchomieniu obliczeń. Zatem jeśli nie ma pewności, że używamy wyłącznie dozwolonych znaków, lepiej wybrać przy eksporcie opcję <code>Save as Nexus (illegal name chars replaced by _ (e.g. for MrBayes)</code>.</p>
<p><img src="konstruowanie_drzew/export-do-nexus.png" alt="Zapis w formacie Nexus" /></p>
<p>Plik zapisz jako <code>ccmFn.nexus</code>, otwórz go w edytorze tekstu, zobacz jak zapisane są w nim dane.</p>
<p>Następnie przygotuj plik <code>mrBayes.bay</code> o treści:</p>
<pre><code>begin mrbayes;
    execute ccmFn.nexus;
    outgroup Cycas_taitungensis_NC_010303; 
    lset applyto=(all) nst=6 rates=gamma;            
    mcmcp ngen=1000000;
    mcmcp stoprule = yes; 
    mcmcp stopval = 0.01; 
    mcmcp savebrlens=yes; 
    mcmc;
    sumt;	
end;
</code></pre>
<p>Jest to proste ustawienie komend i parametrów dla programu.</p>
<p>Uruchom obliczenia:</p>
<pre><code>$: mb mrBayes.bay
</code></pre>
<p>Obliczenia chwilę potrwają. Podczas działania programu przyjrzyjmy się znaczeniu użytych poleceń nie zagłębiając się jednak w szczegóły.</p>
<ul>
<li><code>execute ccmFn.nexus</code> - wczytanie pliku z sekwencjami</li>
<li><code>outgroup Cycas_taitungensis_NC_010303</code> - wskazanie outgrupy</li>
<li><code>lset applyto=(all) nst=6 rates=gamma</code> - ustawienie modelu substytucji <code>GTR+G+I</code></li>
<li><code>mcmcp ngen=1000000</code> - liczba pokoleń</li>
<li><code>mcmcp stoprule = yes</code> - obliczenia zatrzymają się gdy wartość różnice pomiędzy generowanymi drzewami spadną poniżej określonego poziomu (zob. poniżej)</li>
<li><code>mcmcp stopval = 0.01</code> - wartość graniczna dla opcji <code>stoprule</code></li>
<li><code>mcmcp savebrlens=yes</code> - zapisanie długości gałęzi drzewa w pliku wynikowym</li>
<li><code>mcmc</code> - uruchomienie obliczeń</li>
<li><code>sumt</code> - zapis wyników</li>
</ul>
<p>Powyższy plik zmienia domyślne ustawienia programu w minimalnym stopniu, pozostałe opcje, ich wartości domyślne oraz znaczenie można poznać studiując manual dostępny pod adresem <a href="http://mrbayes.sourceforge.net/mb3.2_manual.pdf">http://mrbayes.sourceforge.net/mb3.2_manual.pdf</a> lub wbudowaną pomoc (komenda <code>help</code> w trybie interaktywnym).</p>
<p>Teraz wróćmy do uruchomionych obliczeń. Program w końcu powinien przekroczyć minimalną wartość różnic między generowanymi drzewami i zakończyć działanie. W katalogu znajdziemy szereg plików z wynikami. Drzewo znajduje się w pliku przedłużeniu <code>.tre</code>. Otwórz plik w programie FigTree</p>
<p>W sekcji <code>Node Labels</code> ustaw parametr <code>Display</code> na <code>prob</code> z liczbą znaków znaczących (<code>Sig. Digits</code>) na 2. Ukorzeń drzewo i ustaw parametry wyświetlania.</p>
<p><img src="konstruowanie_drzew/mrbayes-tree.png" alt="Drzewo bayesowskie" /></p>
<p>Zauważ, że o ile wartości bootstrap mieściły się w zakresie 0-100, to prawdopodobieństwa <em>a posteriori</em> obecne na drzewie bayesowskim  znajdują się między 0 a 1.</p>
<p>Otwórz plik z drzewem (<code>ccmFn.nexus.con.tre</code>). Jego format bardziej skomplikowany niż pliki w formacie <code>newick</code>, które analizowaliśmy wcześniej. Jest to format <code>Nexus</code>. Zawiera on też więcej danych, m. in. różne wartości statystyczne opisujące gałęzie. Niestety, wiele programów nie jest ich w stanie odczytać. Można plik wynikowy zapisać w prostszym, bardziej uniwersalnym formacie dodając w linii z komendą <code>sumt</code> odpowiednią opcję:</p>
<pre><code>sumt conformat = simple;
</code></pre>
<p>Otwórz plik wynikowy w edytorze tekstu i przejrzyj go. Zauważ, że zapisane są tam dwa drzewa: jedno zawierające topologię, długości gałęzi oraz wartości prawdopodobieństw, drugie przedstawiające tylko topologię i długość gałęzi. Jeśli jedno z nich jest zbędne (zwykle to drugie) to możesz je po prostu usunąć ale uważaj, żeby przy okazji nie usunąć komendy <code>end;</code> z końca pliku.</p>
<a class="header" href="#wizualizacja-drzew-filogenetycznych" id="wizualizacja-drzew-filogenetycznych"><h1>Wizualizacja drzew filogenetycznych</h1></a>
<a class="header" href="#uwagi-ogólne" id="uwagi-ogólne"><h2>Uwagi ogólne</h2></a>
<p>Wygenerowane drzewa należy odpowiednio zwizualizować, tak aby w czytelny sposób pokazały wyniki badań. Poniżej krótko scharakteryzuję kilka wybranych (subiektywnie) programów, o różnych możliwościach i sposobie użytkowania, które można wykorzystać w tym celu. Nieco dłużej zatrzymam się na dostępnym przez przeglądarce narzędziu <code>iTOL</code>. Warto jednak samemu sprawdzić dokładniej dostępne opcje i możliwości każdego z nich.</p>
<p>Szerszą listę można znaleźć np. <a href="https://en.wikipedia.org/wiki/List_of_phylogenetic_tree_visualization_software">na Wikipedii</a>.</p>
<a class="header" href="#etapy-wizualizacji-drzew" id="etapy-wizualizacji-drzew"><h2>Etapy wizualizacji drzew</h2></a>
<p>Każdy program generuje dendrogram w formie domyślnej, która rzadko odpowiada temu co chcemy osiągnąć. Zwykle zatem dopasowujemy wygląd drzewa posługując się funkcjami oferowanymi przez program. Do najczęściej stosowanych modyfikacji należą:</p>
<ul>
<li>wybór typu drzewa (filogram, dendrogram)</li>
<li>wybór wyglądu drzewa (prostokątny, trójkątny, kołowy, radialny...)</li>
<li>dopasowanie wyświetlanych wartości i ich formatu (boostrap, prawdopodobieństwo <em>aposteriori</em>, długość gałęzi...)</li>
<li>ukorzenianie drzewa</li>
<li>obracanie gałęzi</li>
<li>łączenie gałęzi (np. poniżej określonej wartości bootstrap)</li>
<li>ustalenie wielkości i proporcji drzewa (wysokość i szerokość)</li>
<li>umieszczenie nazw liści na końcach gałęzi lub wyrównanie ich w kolumnie</li>
<li>korekta nazw liści</li>
<li>dopasowanie innych aspektów wizualnych (wielkość i rodzaj czcionki, grubość i kolor gałęzi...)</li>
<li>zaznaczanie kladów i innych części drzew</li>
</ul>
<p>Programy do wizualizacji drzew w różnym stopniu pozwalają na wykonanie powyższych czynności, zatem dobór programu zależy m. in. od tego w jakim stopniu drzewo zamierzamy modyfikować. Często chcemy jeszcze dokonać dodatkowej edycji drzewa w sposób, który nie jest możliwy z poziomu używanego programu albo na przykład ułożyć kilka drzew w postaci jednej ilustracji. W takim przypadku warto zapisać drzewo w formacie graficznym <code>SVG</code> lub <code>PDF</code> a następnie otworzyć w programie służącym edycji grafiki wektorowej (np. darmowym <a href="https://inkscape.org"><code>Inkscape</code></a>) i dokonać dalszych poprawek. Oczywiście nie mogą one zmieniać drzewa w sposób, który prowadziłby do zafałszowania wyników badań.</p>
<p>W tym miejscu warto poświęcić kilka słów na temat formatów graficznych w których możemy zapisywać drzewo. Formaty plików przechowujących grafikę, można podzielić na dwie podstawowe kategorie: <a href="https://pl.wikipedia.org/wiki/Grafika_rastrowa">grafikę rastrową</a> i <a href="https://pl.wikipedia.org/wiki/Grafika_wektorowa">grafikę wektorową</a>. Każda z nich ma swoje zalety i wady. Nie wchodząc w szczegóły, generalnie w przypadku obrazów składających się z kształtów, które można sprowadzić do figur geometrycznych, jak drzewa filogenetyczne, lepiej stosować grafikę wektorową, ponieważ jest ona skalowalna (przy powiększaniu nie ma zjawiska ,,pikselozy'') oraz łatwiej można ją modyfikować. Wspomniane powyżej formaty <code>SVG</code> i <code>PDF</code> to właśnie formaty grafiki wektorowej. Sugeruję zawsze zapisać drzewo w formacie wektorowym, jeśli tego potrzebujemy to także w jednym z formatów rastrowych (<code>jpg</code>, <code>png</code>, <code>tiff</code>...), przy czym należy pamiętać, że programy do grafiki wektorowej (np. <code>Inkscape</code>, <code>Ilustrator</code>, <code>CorelDraw</code>) mają funkcje eksportu do grafiki rastrowej. Zmiana formatu w drugą stronę jest dużo bardziej skomplikowana.</p>
<a class="header" href="#wybrane-programy-do-wizualizacji-drzew-filogenetycznych" id="wybrane-programy-do-wizualizacji-drzew-filogenetycznych"><h2>Wybrane programy do wizualizacji drzew filogenetycznych</h2></a>
<a class="header" href="#figtree" id="figtree"><h2>FigTree</h2></a>
<p>Strona domowa: <a href="http://tree.bio.ed.ac.uk/software/figtree/">http://tree.bio.ed.ac.uk/software/figtree/</a></p>
<p>Z programem <code>FigTree</code> spotkaliśmy się w poprzednim rozdziale. Do zalet należą: dość prosty i czytelny interfejs, spore możliwości dopasowania wyglądu drzewa, odczyt złożonego formatu plików generowanych przez program <code>MrBayes</code>, eksport do kilku formatów zapisu drzewa (<code>NEXUS</code>, <code>Newick</code> <code>JSON</code>).</p>
<p><img src="wizualizacja/figtree-01.png" alt="FigTree" /></p>
<a class="header" href="#dendroscope" id="dendroscope"><h2>Dendroscope</h2></a>
<p>Strona domowa: <a href="http://dendroscope.org">http://http://dendroscope.org</a></p>
<p><code>Dendroscope</code> to również program desktopowy. Przy otwieraniu pliku z drzewem pokazuje się okienko z zapytaniem o sposób interpretacji wartości przypisanych do węzłów, są to zwykle wartości bootstrap lub prawdopodobieństw, w taki wypadku należy wybrać opcję ,,Interpret as edge labels (such a bootstrap values)''.</p>
<p><img src="wizualizacja/dendroscope-01.png" alt="Dendroscope - otwieranie pliku" /></p>
<p>Program oferuje wiele możliwości ustawienia typu i wyglądu drzewa, sposobu jego wyświetlania a także edycję nazw liści. Jest także sporo dostępnych formatów zapisu drzew (w formie plików tekstowych) oraz dendrogramów.</p>
<p><img src="wizualizacja/dendroscope-02.png" alt="Dendroscope" /></p>
<a class="header" href="#itol" id="itol"><h2>iTOL</h2></a>
<p>Strona domowa: <a href="http://itol.embl.de">http://itol.embl.de</a></p>
<p>Kolejne narzędzie, które przedstawię to <code>iTOL</code>. Nazwa jest skrótem od <em>Interactive Tree of Life</em>. W przeciwieństwie do poprzednich, jest obsługiwany przez przeglądarkę internetową. Posiada wiele możliwości modyfikacji wyglądu drzew, ich opisywania a także po założeniu konta, można gromadzić i organizować online własne drzewa filogenetyczne. Można te także udostępniać publicznie. Poświęcę mu nieco więcej uwagi.</p>
<p>Po wejściu na witrynę <a href="http://itol.embl.de">http://itol.embl.de</a> pokazuje się strona główna programu:</p>
<p><img src="wizualizacja/itol-01.png" alt="iTOL - strona główna" /></p>
<p>Na górze znajduje się pasek nawigacyjny. Po kliknięciu na ,,Tree of Life'' pokazuje się, jak nazwa wskazuje, ,,drzewo życia'', zawierające organizmy z różnych gałęzi ewolucyjnych. Domyślnie otwierają się także trzy okienka z różnymi opcjami pozwalającym na modyfikację drzewa. Ma ono charakter interaktywny, np. po najechaniem kursora na takson, pojawia się okienko z informacjami na jego temat, łącznie ze zdjęciem i linkami do dodatkowych informacji.</p>
<p><img src="wizualizacja/itol-02.png" alt="iTOL - drzewo życia" /></p>
<p>Drzewo życia daje dość dobry podgląd na możliwości <code>iTOL</code>. Poeksperymentuj z różnymi ustawieniami wyświetlania drzewa. Drzewo można zapisać w formacie <code>SVG</code> w zakładce <code>Export</code> w okienku <code>Controls</code>.</p>
<p>Warto też zajrzeć w galerię drzew (<em>Tree gallery</em>) znajdującą się w menu <code>Help</code>. Znajdują się tam przykłady różnych form drzew utworzonych przez użytkowników,</p>
<p>Pozycja ,,Upload'' otwiera stronę na której możemy załadować z pliku, lub wkleić drzewo (zawartość pliku tekstowego z drzewem), które chcemy zwizualizować. Zanim zdecydujemy się na to, warto przeczytać ostrzeżenia, które tam się znajdują. Nasze drzewo będzie publicznie dostępne i każdy będzie mógł je zmodyfikować. Jeśli zamierzamy pracować w <code>iTOL</code> to zdecydowanie lepszą opcją jest utworzenie tam prywatnego konta. W tym celu wybieramy ,,Login'' i dalej link ,,create a personal iTOL account'' znajdujący się na górze lub ,,please register first'' na dole strony.
Tam znajdziemy standardowy formularz.</p>
<p>Po utworzeniu konta możemy się zalogować. Na pasku menu pojawia się link ,,My Trees'' prowadzący do strony umożliwiającej załadowanie własnych drzew i ich organizację.</p>
<p><img src="wizualizacja/itol-03.png" alt="iTOL - konto" /></p>
<p>Po kliknięciu w link prowadzący do drzewa zostajemy przekierowani do strony edycji. Po lewej znajduje się okno z narzędziami.</p>
<p><img src="wizualizacja/itol-04.png" alt="iTOL - edycja drzewa" /></p>
<p>Zwykle domyślny widok drzewa nie jest satysfakcjonujący. Jeśli wolisz, żeby nazwy taksonów wyświetlały się na końcu gałęzi kliknij w okienku narzędziowym na opcję ,,At tips'' w ustawieniach ,,Labels'' (zakładka ,,Basic'').</p>
<p>Aby ukorzenić drzewo, należy kliknąć w wybraną gałąź prowadzącą do outgrupy a następnie w okienku, które się pojawi wybrać ,,Tree structure'' -&gt; ,,Reroot the tree here''. Przy okazji zwróć uwagę na inne opcje pozwalające na modyfikację gałęzi.</p>
<p><img src="wizualizacja/itol-05.png" alt="iTOL - ukorzenianie drzewa" /></p>
<p>Domyślnie nie wyświetlają się wartości bootstrap/prawdopodobieństw. Aby to zmienić wybierz w oknie narzędzi zakładkę ,,Advanced'', kliknij w linii ,,Bootstraps / metadata'' na ,,Display'' a następnie poniżej na ,,Text''. Teraz możesz ustawić parametry tekstu dla tych wartości (wielkość, miejsce, zaokrąglanie) a także zakres wyświetlanych wartości.</p>
<p><img src="wizualizacja/itol-06.png" alt="iTOL - wyświetlanie wartości bootstrap/prawdopodobieństw" /></p>
<p>To oczywiście tylko niewielka część możliwości modyfikacji wyglądu drzewa oferowanych przez <code>iTOL</code>. Warto spędzić trochę czasu aby poznać bliżej to narzędzie.</p>
<p>Kiedy wygląd drzewa będzie (przynajmniej z grubsza) odpowiadał naszym oczekiwaniom, pobieramy plik w formacie <code>SVG</code> w zakładce export (wybierz opcję ,,Full image''). Dendrogram zwykle trzeba jeszcze dopracować, zwłaszcza przesunąć skalę i dopasować wielkość obrazka do drzewa. Jak wspomniałem wcześniej można do tego użyć np. <code>Inkscape</code>.</p>
<a class="header" href="#poprawki-dendrogramu-w-inkscape" id="poprawki-dendrogramu-w-inkscape"><h3>Poprawki dendrogramu w Inkscape</h3></a>
<p>Po otwarciu pliku w <code>Inkscape</code>, drzewo wygląda mniej więcej tak:</p>
<p><img src="wizualizacja/inkscape-01.png" alt="Inkscape - otwarty plik" /></p>
<p>Wykonamy teraz dwie operacje: przesuniemy skalę na dół drzewa a następnie dopasujemy stronę do obrazka.</p>
<p>Rysunek wektorowy składa się z ,,obiektów'' (figur, liter itd), które domyślnie są ze sobą zgrupowane. Zaczniemy więc od ich rozdzielenia. Kliknij na drzewo tak aby rysunek był zaznaczony, następnie wybierz z menu ,,Obiekt'' -&gt; ,,Rozdziel grupę''.
Teraz można osobno zaznaczyć skalę i drzewo. Gdybyś chciał zmodyfikować poszczególne elementy drzewa, np. zmienić opisy taksonów czy skrócić korzeń, należy proces rozdzielania grupy (drzewa) prowadzić wielokrotnie aż do uzyskania poszczególnych obiektów. Łatwiej to zrobić używając skrótu klawiszowego <code>Shift+Ctrl+G</code>.</p>
<p>Skalę możesz teraz przeciągnąć w odpowiednie miejsce, np. w lewy dolny róg obrazka.</p>
<p><img src="wizualizacja/inkscape-02.png" alt="iTOL - przeniesienie skali" /></p>
<p>Teraz wybierz z menu ,,Plik'' -&gt; ,,Właściwości dokumentu''. Pojawi się okno w którym m. in. możemy ustawić właściwości strony. Rozwiń ,,Dopasuj stronę do zawartości'' i ustaw wartości marginesów np. na 10 pikseli.</p>
<p><img src="wizualizacja/inkscape-03.png" alt="iTOL - dopasowanie strony" /></p>
<p>Następnie kliknij w ,,Dopasuj stronę do rysunku lub zaznaczenia'' i zamknij okno.</p>
<p>Teraz strona jest dopasowana do rysunku:</p>
<p><img src="wizualizacja/inkscape-04.png" alt="iTOL - dopasowana strona" /></p>
<p>Używając odpowiednich opcji w menu ,,Plik'' możemy teraz zapisać plik do jednego z formatów wektorowych (,,Zapisz jako'', ,,Zapisz kopię...'') lub bezpośrednio wyeksportować do rastrowego formatu <code>PNG</code> (,,Wyeksportuj jako PNG...'').</p>
<p>Jeśli chcemy aby <code>iTOL</code> zapamiętał zmiany w wyglądzie drzewa, zapisujemy je klikając na ,,Save/restore view'' w zakładce ,,Export'' i dalej  wybieramy ,,Save as default view''.</p>
<p><code>Inkscape</code> jest bardzo rozbudowanym programem do pracy z grafiką wektorową, warto we własnym zakresie go bliżej poznać, niekoniecznie tylko w celu obróbki dendrogramów.</p>
<a class="header" href="#newick-utilities" id="newick-utilities"><h2>Newick Utilities</h2></a>
<p>Strona domowa: <a href="http://cegg.unige.ch/newick_utils">http://cegg.unige.ch/newick_utils</a></p>
<p><code>Newick Utilities</code> to kolekcja programów uruchamianych z linii komend służących do pracy z drzewami filogenetycznym. Warto przejrzeć dokumentację choćby w celu poznania listy programów i ich zastosowań. Teraz będą nas interesować dwa z nich: <code>nw_reroot</code> oraz <code>nw_display</code>. Pierwszy z nich służy ukorzenianiu drzewa, drugi do jego wizualizacji.
Warto ich używać np. jako elementów ciągu poleceń generujących robocze drzewa i dendrogramy, zwłaszcza gdy je tworzymy seryjnie. Zobaczmy jak to działa na przykładzie.</p>
<p>Utwórz katalog <code>fasttree</code> do którego skopiuj plik <code>ccmFn.fasta</code>. Korzystaliśmy z niego w poprzedniej lekcji, jeśli go nie masz, można do pobrać z adresu: <a href="http://ggoralski.pl/files/filogenetyka-data/ccmFn.fasta">http://ggoralski.pl/files/filogenetyka-data/ccmFn.fasta</a>.</p>
<p>W katalogu wykonaj komendę:</p>
<pre><code>fasttree -nt -gtr ccmFn.fasta &gt; ccmFn.tree
</code></pre>
<p>Zostaje utworzony plik <code>ccmFn.tree</code> z drzewem zapisanym w formacie <code>Newick</code>. Teraz trzeba je ukorzenić.</p>
<pre><code>nw_reroot ccmFn.tree Cycas_taitungensis_NC_010303 &gt; ccmFn-rooted.tree
</code></pre>
<p>Teraz utworzymy dendrogram, najpierw w formacie tekstowym:</p>
<pre><code>nw_display ccmFn-rooted.tree &gt; ccmFn-dendrogram.txt
</code></pre>
<p>Sprawdź zawartość pliku.</p>
<p>Oczywiście zwykle jednak potrzebujemy dendrogramu w formie graficznej. W tym celu użyjemy opcji <code>-s</code>:</p>
<pre><code>nw_display -s ccmFn-rooted.tree &gt; ccmFn-dendrogram.svg
</code></pre>
<p>Zostanie utworzony plik w formacie <code>SVG</code>, możemy go otworzyć np. w <code>Inkscape</code>.</p>
<p>Niestety, drzewo nie wygląda zbyt dobrze:</p>
<p><img src="wizualizacja/nwdisplay-01.png" alt="Fragment drzewa wygenerowanego przez nw_display" /></p>
<p>Spróbujmy zatem nieco zmodyfikować jego wygląd:</p>
<pre><code>nw_display -w 1000 -v 25 -b 'opacity:0' -s ccmFn-rooted.tree &gt; ccmFn-dendrogram.svg
</code></pre>
<p>Teraz drzewo wygląda zdecydowanie lepiej:</p>
<p><img src="wizualizacja/nwdisplay-02.png" alt="Fragment drzewa wygenerowanego przez nw_display z poprawionymi parametrami" /></p>
<p>Co znaczą nowo użyte opcje?</p>
<ul>
<li><code>-w 1000</code> - szerokość drzewa, dendrogram został poszerzony</li>
<li><code>-v 25</code> - odległość między liśćmi w pionie, dendrogram został zmniejszony w pionie</li>
<li><code>-b 'opacity:0'</code> - zmiana wyglądu etykiet gałęzi, ustawiliśmy je jako przeźroczyste, więc zniknęły z dendrogramu</li>
</ul>
<p>Zmianę wyglądu, którą zastosowaliśmy dla usunięcia opisu gałęzi, dotyczy także innych elementów drzewa i aspektów wyglądu. Stosuje się tu tzw. <a href="https://pl.wikipedia.org/wiki/Kaskadowe_arkusze_styl%C3%B3w">kaskadowe arkusze stylów</a> (<code>CSS</code>), których jednak nie będziemy to bliżej omawiać.</p>
<p>Format <code>SVG</code> jest wygodny w dalszej edycji, np. w programie <code>Inkscape</code> ale niekoniecznie w szybkim podglądzie wyniku. Bardziej przydałby się tu format <code>PDF</code>. Konwersji możemy dokonać z linii komend przy użyciu <code>Inkscape</code>:</p>
<pre><code>inkscape -f ccmFn-dendrogram.svg -A ccmFn-dendrogram.pdf
</code></pre>
<p>Powyższe narzędzia uruchamiane w linii komend można wykorzystać do utworzenia skryptu, który automatycznie wygeneruje dendrogramy w formatach <code>SVG</code> i <code>PDF</code> dla wszystkich plików <code>*.fasta</code> (muszą zawierać dopasowane sekwencje) w bieżącym katalogu. Dla uproszczenia zakładam, że wszystkie mają taką samą outgrupę (tu Cycas_taitungensis_NC_010303)
, której nazwę podajemy jak parametr przy uruchamianiu skryptu, który nazwiemy <code>utworz-drzewa.sh</code>.</p>
<pre><code>#!/bin/bash

# Tworzenie katalogów dla dendrogramów
mkdir SVG
mkdir PDF

# Outgupa dla drzew podana jako argument skryptu
outgupa=$1

# Skrypt generuje drzewa dla wszystkich plików fasta w bieżącym katalogu
for file in *.fasta
do 
    echo &quot;Plik: $file&quot;
    # generowanie drzewa
    fasttree -nt -gtr $file &gt; $file.tree 
    # ukorzenianie drzewa
    nw_reroot $file.tree $outgrupa &gt; $file-rooted.tree
    # Generowanie dendrogramu w formacie SVG
    nw_display -w 1000 -v 25 -b 'opacity:0' -s $file-rooted.tree &gt; SVG/$file-dendrogram.svg
    # Konwersja drzewa 
    inkscape -f SVG/$file-dendrogram.svg -A PDF/$file-dendrogram.pdf
done
</code></pre>
<p>Uruchamiamy skrypt:</p>
<pre><code>./utworz-drzewa.sh Cycas_taitungensis_NC_010303
</code></pre>
<p>W katalogach <code>SVG</code> i <code>PDF</code> powinny znaleźć się dendrogramy.</p>
<a class="header" href="#drzewa-filogenetyczne-i-zegar-molekularny" id="drzewa-filogenetyczne-i-zegar-molekularny"><h1>Drzewa filogenetyczne i zegar molekularny</h1></a>
<p>Drzewa filogenetyczne, które tworzyliśmy dotychczas pokazywały relacje filogenetyczne pomiędzy badanymi organizmami i ich stopień podobieństwa, jednak nie pozwalały na odniesienie poszczególnych wydarzeń, takich jak rozdzielanie się kladów, do czasu w którym mogły się wydarzyć.</p>
<p>Drzewa posiadające informacje na temat długości gałęzi (filogramy) pozwalają szacować względne odległości między taksonami ale aby dopasować je do ram czasowych potrzebujemy sposobu ich ,,wykalibrowania'' tak aby można było znaleźć relacje pomiędzy liczbą mutacji a czasem.</p>
<p>Kalibracja drzewa może przebiegać na przynajmniej dwa sposoby. Jeśli znamy tempo ewolucji badanych sekwencji to można dopasować skalę czasową na podstawie liczby mutacji na poszczególnych gałęziach. Można też podejść do problemu z drugiej strony. Znając przybliżony czas w którym doszło do rozdzielenia się kladów, na przykład opierając się na danych opartych na skamieniałościach, można dopasować go do odpowiedniego węzła na drzewie i na tej podstawie wyliczyć związek między czasem a liczbą mutacji. Tutaj pokażę prosty przykład tego drugiego podejścia.</p>
<p>W praktyce trzeba pamiętać, że nie tylko różne rodzaje sekwencji ewoluują z różną prędkością, ale także ten sam typ sekwencji może mieć różne tempo ewolucji u różnych grup organizmów. Oznacza to, że różne części naszego drzewa mogą mieć różne tempo ewolucji. Zatem lepiej jest wyznaczyć kilka ,,markerów'' - w przypadku pierwszego podejścia wyznaczyć tempo ewolucji dla różnych kladów, dla drugiego oznaczyć czas dla kilku węzłów.</p>
<p>Do najczęściej używanych programów pozwalających na użycie zegara molekularnego do drzew filogenetycznych należą obsługiwany z linii komend <code>r8s</code> oraz ,,okienkowy'' i dużo bardziej złożony <code>BEAST</code>. Skupimy się na tym pierwszym.</p>
<a class="header" href="#r8s" id="r8s"><h1><code>r8s</code></h1></a>
<p>Program <code>r8s</code> można pobrać z internetu ze strony: <a href="https://sourceforge.net/projects/r8s">https://sourceforge.net/projects/r8s</a>. Następnie należy rozpakować pobrany plik.</p>
<p>Niestety, w pobranej formie program nie uruchamia się pod Linuksem, trzeba go skompilować. Co więcej, przynajmniej w dystrybucji, której używam (Debian 7.3.0-16) należało dokonać pewnych zmian w pliku <code>Makefile.linux</code> aby kompilacja się powiodła. Poniżej zamieszczam zawartość skryptu, który napisałem, automatyzującego proces pobierania, modyfikacji i kompilacji programu. Możesz go zapisać (np. pod nazwą <code>install-r8s.sh</code>) i uruchomić.</p>
<pre><code>#!/bin/bash

# Skrypt pobierający i kompilujący program r8s

# Instalacja potrzebnych pakietów do kompilacji
sudo apt-get install make gcc gfortran 
cd ~

# Pobranie i rozpakowanie plików
wget https://sourceforge.net/projects/r8s/files/r8s1.81.tar.gz
tar -xvzf r8s1.81.tar.gz

# Zmiana nazwy na krótszą
mv r8s1.81 r8s

# Idziemy do katalogu z plikami źródłowymi
cd r8s/src/  
# usuwamy plik r8s
rm r8s

# Poprawki w pliku Makefile.linux - inaczej się nie skompiluje
sed -i 's/continuousML.o:continuousML.h/#continuousML.o:continuousML.h/' Makefile.linux
sed -i 's/blas.o tn.o TNwrapper.o continuousML.o ancestral.o covarion.o/blas.o tn.o TNwrapper.o ancestral.o covarion.o #continuousML.o/' Makefile.linux
sed -i 's|CFLAGS|LPATH = -L/usr/local/gfortran/lib # correct location as of August 2011.\nCFLAGS|' Makefile.linux
sed -i 's|memory.o: /usr/include/errno.h /usr/include/sys/errno.h|memory.o: /usr/include/errno.h # /usr/include/sys/errno.h|' Makefile.linux
sed -i 's|memory.o: /usr/include/stdlib.h memory.h|memory.o: /usr/include/stdlib.h # memory.h|' Makefile.linux
sed -i 's|CFLAGS = -g -std=c99 -pedantic|#CFLAGS = -g -std=c99 -pedantic |' Makefile.linux

#Kompilacja
make -f Makefile.linux

# Uprawnienia do wykonywania
chmod u+x r8s

# Kopiujemy program do katalogu głównego programu 
cp r8s ..
cd ..
</code></pre>
<p>Po uruchomieniu skryptu, w katalogu domowym użytkownika powinien znaleźć się katalog <code>r8s</code> z gotowym programem. Zajrzyj do niego. W katalogu znajdziemy kilka plików i katalogów:</p>
<pre><code>examples
LICENSE
r8s
r8s1.7.manual.pdf
README
src
</code></pre>
<p>Katalog <code>examples</code>, jak wskazuje nazwa, zawiera przykładowe pliki z danymi oraz konfiguracjami programu. Zaraz do niego wrócimy.
<code>LICENCE</code> i <code>README</code> to pliki, których nazwy jasno wskazują na ich znaczenie.
<code>r8s</code> jest plik programu, będziemy go uruchamiać.
<code>8s1.7.manual.pdf</code> zawiera manual, warto zauważyć, że odnosi się do starszej wersji programu.
W katalogu <code>src</code> znajdują się głównie pliki źródłowe programu, po jego skopmilowaniu nie będą raczej nas już interesować.</p>
<p>Otwórz w edytorze tekstu plik <code>examples/SAMPLE_SIMPLE</code>. Jest to prosty plik wejściowy dla programu <code>r8s</code>, przejrzyj jego zawartość. Teraz na postawie tego i innych plików przykładowych z tego katalogu stworzymy własny plik, będziemy go uruchamiać i stopniowo rozwiać poznając wybrane, podstawowe możliwości programu. Trzeba zaznaczyć, że <code>r8s</code> nie wylicza drzew, ale korzysta z już gotowych.</p>
<p>Utwórz katalog roboczy, np. <code>zegar</code> a w nim plik <code>rosliny.set</code> (przedłużenie pliku nie ma specjalnego znaczenia).</p>
<p>Umieść w nim poniższą zawartość:</p>
<pre><code>#NEXUS 

[ * Blok trees, obowiązkowy ]

begin trees;

tree rosliny = (Marchantia:0.033817,(Lycopodium:0.040281,((Equisetum:0.048533,(Osmunda:0.033640,Asplenium:0.036526):0.000425):0.011806,((((Cycas:0.009460,Zamia:0.018847):0.005021,Ginkgo:0.014702):1.687e-86,((Pinus:0.021500,(Podocarpac:0.015649,Taxus:0.021081):0.006473):0.002448,(Ephedra:0.029965,(Welwitsch:0.011298,Gnetum:0.014165):0.006883):0.016663):0.006309):0.010855,((Nymphaea:0.016835,(((((Saururus:0.019902,Chloranth:0.020151):1.687e-86,((Araceae:0.020003,(Palmae:0.006005,Oryza:0.031555):0.002933):0.007654,Acorus:0.038488):0.007844):1.777e-83,(Calycanth:0.013524,Lauraceae:0.035902):0.004656):1.687e-86,((Magnolia:0.015119,Drimys:0.010172):0.005117,(Ranunculus:0.029027,((Nelumbo:0.006180,Platanus:0.002347):0.003958,(Buxaceae:0.013294,((Pisum:0.035675,(Fagus:0.009848,Carya:0.008236):0.001459):0.001994,(Ericaceae:0.019136,Solanaceae:0.041396):0.002619):1.687e-86):0.004803):1.687e-86):0.006457):0.002918):0.007348,Austrobail:0.019265):1.687e-86):1.687e-86,Amborella:0.019263):0.003527):0.021625):0.012469):0.019372);

end;
</code></pre>
<p>Na początku pliku znajduje się deklaracja, że jest to plik w formacie <code>NEXUS</code>. Dalej znajduje się komentarz - jak widać ograniczony jest parą nawiasów klamrowych.</p>
<p>Polecenia <code>begin</code>, po którym następuje nazwa oraz <code>end</code> ograniczają blok kodu. W tym przypadku jest to blok <code>trees</code>, niezbędny do działania programu (co jest zrozumiałe). Zauważ, ze komendy kończą się średnikiem.</p>
<p>W bloku znajduje się drzewo (komenda <code>tree</code>), zapisane w formacie <code>newick</code>, które będzie miało nazwę <code>rosliny</code>. Zawartość drzewa została skopiowana z pliku <code>SAMPLE_SIMPLE</code>.</p>
<p>Teraz zapisz plik i uruchom program:</p>
<pre><code>$: ~/r8s/r8s -b -f rosliny.set
Reading tree rosliny
</code></pre>
<p>Opcja <code>-f</code> oznacza wczytanie pliku, <code>-b</code> to tzw. <em>batch mode</em>, czyli tryb wsadowy co oznacza w tym przypadku odczytanie pliku i zakończenie działania. Bez tej flagi program wczyta zawartość pliku i będzie oczekiwał na kolejne polecenia. Z programu można wyjść przez podanie komendy <code>q</code>.</p>
<p>Jak widać program wczytał drzewo i zakończył działanie.</p>
<p>Dopisz do pliku blok z poleceniami dla programu <code>r8s</code>:</p>
<pre><code>[* Blok z komendami ]

begin rates;

[ * Informacje na temat drzewa]

blformat nsites=952 lengths=persite;

[ * Komenda, która pozwala programowi radzić sobie z gałęziami o zerowej długości ]

collapse;

[* Definicje wybranych elementów drzewa ]

mrca LAND_PLANTS marchantia pisum;
mrca GYMNOSPERMS Ginkgo Gnetum;
mrca ANGIOSPERMS amborella pisum;

[ * Ustawianie sztywnych wartości czasowych dla węzłów ]

fixage taxon=LAND_PLANTS age=450;
constrain taxon=GYMNOSPERMS min_age=310;
constrain taxon=ANGIOSPERMS min_age=200 max_age=245;

[ * Wyliczanie czasów przy użyciu zadeklarowanej metody i algorytmu ]

divtime method=lf algorithm=tn;

[ * Czytelna prezentacja wyników ]

showage;

[ * Generowanie chronogramu (tryb tekstowy)- gałęzie proporcjonalne do czasu ]

describe plot=chronogram;

[ * Generowanie filogramu (tryb tekstowy)- gałęzie proporcjonalne do liczby zmian ]

describe plot=phylogram;

[ * Generowanie drzewa w formacie nexus ]

describe plot=tree_description;

[ * Sprawdzamy, czy nie ma innych rozwiązań ]

set num_time_guesses=3;
divtime method=lf algorithm=tn;

end;
</code></pre>
<p>Komenda <code>blformat</code> opisuje drzewo, które badamy. <code>nsites</code> to liczba miejsc w sekwencjach, które zostały użyte przy tworzeniu drzewa. <code>lengths</code> informuje o znaczeniu liczb określających długość gałęzi: opcja <code>persite</code> oznacza liczbę mutacji na miejsce w sekwencji, jeśli oznaczałyby całkowitą liczbę mutacji to użylibyśmy opcji <code>total</code>.</p>
<p>Komenda <code>collapse</code>, nie wchodząc w szczegóły pozwala radzić sobie programowi w sytuacjach, w których gałęzie mają zerową długość.</p>
<p>Następnie definiujemy/nazywamy, używając komendy <code>mrca</code> dwa wewnętrzne węzły. Nazwa komendy to skrót od <em>recent common ancestor</em>, czyli ostatni wspólny przodek. Podając nazwy dwóch taksonów, określamy, że podana nazwa odnosi się do węzła w którym rozdzieliły się ich drogi ewolucyjne.</p>
<p>W naszym przykładzie oznaczamy węzły ostatnich wspólnych przodków (badanych) roślin lądowych (<code>LAND_PLANTS</code>), nagonasiennych (<code>GYMNOSPERMS</code>) oraz okrytonasiennych (<code>ANGIOSPERMS</code>).</p>
<p>Dalej, wykorzystujemy utworzone wcześniej nazwy do umiejscowienia ich w czasie, co pozwala na ,,wyskalowanie'' drzewa. Komenda <code>fixage</code> ustawia ,,na sztywno'' czas, natomiast <code>constrain</code> pozwala określić zakres czasowy w którym doszło do rozdzielenia się linii ewolucyjnych, poprzez wyznaczenie jednej (maksymalną lub minimalną) lub obu granic. W naszym pliku czas jest określony w milionach lat.</p>
<p>Komenda <code>divtime</code> wylicza czasy dla pozostałych węzłów przy użyciu wybranej metody i algorytmu. Nie będziemy ich analizować. Wyniki zostają wypisane w sposób mało czytelny, dlatego dalej używamy komendy <code>skowage</code>, która je prezentuje w sposób bardziej przejrzysty.</p>
<p>Następnie trzykrotnie zostaje wywołana komenda <code>descriptions</code> z różnymi wartościami parametru <code>plot</code>, dzięki której otrzymujemy wyniki w formie drzew w różnych formatach. Dwa pierwsze drzewa prezentowane są w trybie wizualno-tekstowym: chronogram, w którym długości gałęzi odpowiadają czasowi (dlatego są wyrównane do prawej krawędzi) oraz filogram, posiadający gałęzie o długościach proporcjonalnych do  liczby mutacji. Trzecie drzewo jest zapisane w formacie <code>nexus</code>.</p>
<p>Istnieje możliwość, że dla danego zestawu danych istnieje więcej niż jedno optymalne rozwiązanie. Dlatego na końcu sprawdzamy trzykrotnie (można ustawić inną wartość) obliczenia, za każdym razem program (nie wchodząc w szczegóły) używając innych wewnętrznych wartości startowych. Jeśli otrzymujemy dla każdej serii wyliczeń otrzymujemy inne wyniki, oznacza to, że istnieją różne optymalne rozwiązania.</p>
<p>Zapisz plik i uruchom, obejrzyj wyniki na ekranie i spróbuj dopasować je do kolejnych poleceń. Wynik warto też zapisać w pliku:</p>
<pre><code>~/r8s/r8s -b -f rosliny.set &gt; rosliny.out
</code></pre>
<p>Teraz skopiuj z pliku wynikowego (lub z terminala) drzewo wynikowe w formacie <code>newick</code> i zapisz je w osobnym pliku (np. <code>rosliny-out.newick</code>)</p>
<pre><code>tree rosliny = (Marchantia:450.000000,(Lycopodium:407.944406,((Equisetum:305.471826,Osmunda:305.471826,Asplenium:305.471826):75.632633,(((Cycas:179.379676,Zamia:179.379676):130.620324,Ginkgo:310.000000,((Pinus:233.179335,(Podocarpac:169.510283,Taxus:169.510283):63.669052):29.512298,(Ephedra:169.287671,(Welwitsch:106.917284,Gnetum:106.917284):62.370386):93.403963):47.308367)GYMNOSPERMS:20.366923,(Nymphaea:245.000000,(Saururus:221.224524,Chloranth:221.224524,((Araceae:152.187678,(Palmae:133.203210,Oryza:133.203210):18.984468):41.024457,Acorus:193.212135):28.012388,(Calycanth:191.261350,Lauraceae:191.261350):29.963173,((Magnolia:132.585525,Drimys:132.585525):72.700419,(Ranunculus:179.388935,(Nelumbo:55.366372,Platanus:55.366372):124.022563,(Buxaceae:160.720310,(Pisum:147.492625,(Fagus:117.113994,Carya:117.113994):30.378631):13.227685,(Ericaceae:153.034649,Solanaceae:153.034649):7.685662):18.668625):25.897009):15.938580):23.775476,Austrobail:245.000000,Amborella:245.000000)ANGIOSPERMS:85.366923):50.737536):26.839947):42.055594)LAND_PLANTS;
</code></pre>
<p>Zauważ, że zawiera ono opisy węzłów, które im nadaliśmy a także wyliczone czasy. Brak natomiast wartości odpowiadających długości gałęzi w odniesieniu do liczby mutacji.</p>
<p>Otwórz plik w programie <code>FigTree</code>. Przy pytaniu o nazwę etykiet dla węzłów wpisz ,,Opis''.</p>
<p><img src="zegar-molekularny/figtree-01.png" alt="Opis węzłów" /></p>
<p>Jak zwykle dopasuj czcionki itp. aby drzewo było bardziej czytelne. Następnie zaznacz zakładkę ,,Node Labels'' wyświetlaną wartość na ,,Node ages''. Po dopasowaniu parametrów czcionki i liczby miejsc po przecinku powinieneś uzyskać mniej więcej taki obraz:</p>
<p><img src="zegar-molekularny/figtree-02.png" alt="Wiek węzłów" /></p>
<p>Jak widać, na drzewie widoczny jest wyliczony (i ustawiony przez nas) wiek dla poszczególnych węzłów, oznaczający miliony lat, które upłynęły od momentu rozdzielnia się poszczególnych linii ewolucyjnych.</p>
<p>Ustawiając ,,opisy'' zamiast ,,Node ages'', otrzymasz drzewo z etykietkami, które przypisaliśmy do węzłów.</p>
<p>Teraz (dla przejrzystości) wyłącz wyświetlanie ,,Node Labels'' a włącz w ,,Branch labels'' i ustaw tam wyświetlanie wartości na ,,Branch times''.</p>
<p><img src="zegar-molekularny/figtree-03.png" alt="Wartości czasu wyświetlane dla gałęzi" /></p>
<p>Teraz widać czas przypisany do każdej gałęzi, odpowiadający milionom lat, które upłynęły pomiędzy rozdzieleniem się kolejnych kladów.</p>
<p>Powyższy przykład pokazał podstawy używania programu <code>r8s</code>. Studiując dołączone do programu pliki z przykładami a zwłaszcza tutorial można dowiedzieć się znacznie więcej na temat jego możliwości, do czego zachęcam.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
